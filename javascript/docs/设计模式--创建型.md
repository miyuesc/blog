# 设计模式（二）——创建型模式

**创建型模式**，即处理对象创建过程的设计模式，根据实际情况来使用合适的模式创建对象。

创建型模式主要是将系统所需要的用到的**具体类**封装起来，在内部实现这些具体类的创建和结合，并对外隐藏这个过程细节。外部无法直接访问这个对象的创建和组合过程。使用者只需要关心**何时、何地、由谁、怎样**创建这个对象。

## 使用场景

《设计模式：可复用面向对象软件的基础（Design Patterns: Elements of Reusable Object-Oriented Software）》中使用了一个实现迷宫游戏的程序来说明创建型模式相关的集中模式的关系。

> “这个迷宫和游戏将随着各种模式不同而略有区别。有时这个游戏将紧紧是找到一个迷宫的出口；在这种情况下，游戏者可能仅能进到这个迷宫的局部。有时迷宫包含一些需要解决的问题和要战胜的危险，并且这些游戏可能会提供已经被探索过的那部分迷宫地图。我们将忽略许多迷宫中的细节以及一个迷宫游戏中有一个还是多个游戏者，我们仅关注迷宫是怎样被**创建**的。”
>
>  --- 《设计模式：可复用面向对象软件的基础》 P 54

在创建这个迷宫游戏的时候，我们可以将迷宫的所有部件简化成一个正方形的房间，整个迷宫由很多部件组成。

每个房间我们可以定义一个基础类 `MapSite` ，内部包含这个房间的四个墙面（或者说方向）的属性 `direction: ["North", "South", "East", "West"]` ，并且都有一个方法 `Enter()` ，即进入这个房间。

在这个基础类之上，我们需要定义一个具体类 `Zoom` ，这个类包含自身的房间编号 `zoomNumber` ，以及与周围房间的关联关系的引用 `sides` 。

因为不是所有的房间的每一面都是门，所以我们还需要两个类：墙壁 `Wall` 和 门 `Door` 。

现在部件所需要的内容定义完成之后，我们还需要一个表示房间集合的类 `Maze`，来实现根据房间号 `zoomNumber` 查找具体房间的方法，最后我们需要一个类 `MazeGame` ，用来创建一个完整的迷宫游戏，内部实现了一个实例化迷宫游戏的方法 `createMaze()`。



上面这个例子看上去比较简单，但是定义了很多的类，这样可能会造成在最终创建迷宫游戏实例的时候变得很复杂。当然可以在定义 `Zoom` 的时候就初始化房间的每一个面是墙壁还是门，但是这样如果在以后需要增加新的部件（比如一个咒语门 `DoorNeedSpell` ，或者有“宝藏”的房间 `EnchantedRoom`），就需要修改多处代码，不符合设计模式复用的原则。

从这个例子可以大致总结出来，创建型模式的适用范围：

1. 内部的对象、产品、接口等相互独立，类似墙壁和门；
2. 隐藏类库的具体实现，只对外提供接口和方法，以及可访问的属性；
3. 一个类希望它的子类实现它所创建的对象；
4. 一组相关的对象被设计为需要一起使用。

另外还有一个"单例模式"，在一个类有且只能有一个实例的时候使用。

## 1. 单例模式

单例模式的目的是创建一个类的实例，保证这个类只有一个实例，并对外提供一个全局的访问节点。比如一个国家只有一个官方政府，一个封建王朝只有一个皇帝，一个学校只有一个校长等。

### 1.1 特点

单例模式具有以下特点：

1. 只有一个实例对象
2. 这个实例对象只能有这个单例类自行创建
3. 只对外提供一个该单例类的实例的全局访问节点

### 1.2 优缺点

因为单例模式只有一个实例，可以减少内存和资源的开销，优化共享资源的访问；但是单例模式也有几个比较严重的缺点：

1. 一般没有接口，扩展困难
2. 单例类职责过重，既充当了工厂角色，提供创建对象的工厂方法，又充当了产品角色，包含了一些业务逻辑
3. 代码过多，不利于后期调试

> 单例模式在多线程中还可能被创建多个实例（JavaScript 中则不存在这个问题）

### 1.3 结构

单例模式内部主要包含一个角色：单例类

![image-20210207172200948](screenshot/image-20210207172200948.png)

> 截图来自[REFEACTORING](https://refactoringguru.cn/design-patterns/singleton)

### 1.4 实现

单例模式的实现有两种方式：“懒汉式单例”和“饿汉式单例”，其实两者的区别就是是否在类加载的时候就初始化一个单例实例。

#### 1.4.1 懒汉式单例

通常会对外提供一个获取单例的方法，在第一次调用的时候进行实例化。

```typescript
class LazySingleton {
    private static instance: Singleton;
    // 构造函数必须是私有的，避免外部使用 new 关键字进行实例化
    private constructor() { }
    // 对外提供的访问方法，如果方式没有则创建一个实例
    public static getInstance(): Singleton {
        if (!Singleton.instance) {
            Singleton.instance = new Singleton();
        }
        return Singleton.instance;
    }
    // 业务逻辑
    public someBusinessLogic() {
        // ...
    }
}
```

#### 1.4.2 饿汉式单例

在类中直接进行单例类的实例化，保证对外提供的接口在调用的时候已经创建了对应的实例。

```typescript
class LazySingleton {
    private static instance: Singleton = new Singleton();
    // 构造函数必须是私有的，避免外部使用 new 关键字进行实例化
    private constructor() { }
    // 对外提供的访问方法，如果方式没有则创建一个实例
    public static getInstance(): Singleton {
        return Singleton.instance;
    }
    // 业务逻辑
    public someBusinessLogic() {
        // ...
    }
}
```













