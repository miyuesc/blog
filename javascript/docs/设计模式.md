# JavaScript 设计模式

> 内容来自 《JavaScript设计模式》张容铭 著 （2015年）、《大话设计模式》程杰 著

---

**序：**

设计模式（Design Patterns），指软件/程序开发过程中被经常使用的一种代码逻辑设计经验的集合，目的是为了提高代码的安全性、可靠性、可读性、可维护性、可拓展性。

使用设计模式来进行开发，就是为了降低代码的耦合度，增加代码复用的可能性。

---

## 0. 前置内容

在学习设计模式之前，我们先要了解一下内容：

1. JavaScript 对象、函数和类（Class: ES6新增）
2. 抽象类：基础类，目的是为它的子类定义公共方法，通常不对抽象类直接实例化，而是通过抽象类派生出来具体类型
3. 组合优先于继承



设计模式遵循的七大原则：

1. 单一职责原则：就一个类而言，应该只有一个引起它变化的原因。
2. 开闭原则：开放扩展、关闭修改，即不能修改原来的代码
3. 里氏替换原则：超类（基础类）拥有的属性和方法在派生类的实例中也能找到，在可以使用超类（基础类）的地方也一定可以使用派生类，反过来则不成立
4. 依赖倒置原则：高层模块不应该依赖于低层模块，两者都应该依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象
5. 接口分离原则：一个类对另一个类的依赖应该建立在最小的接口上
6. 最少知道原则：个软件实体应当尽可能少地与其他实体发生相互作用。
7. 合成复用原则：尽量使用对象组合/，而不是继承关系达到软件复用的目的



设计模式目前常用的（或者说见得最多的）有23个，每个设计模式都有不同的用途。按照它们的用途大致分类，可以分为3种：

1. **创建型** `Creational Pattern`：与对象创建相关
- 简单工厂模式 `Simple Factory`
   - 工厂方法模式 `Factory Method`
   - 抽象工厂模式 `Abstract Factory`
   - 建造者模式 `Builder`
   - 原型模式 `Prototype`
   - 单例模式 `Singleton`
   
2. **结构型** `Structural Pattern`：处理类或者对象的"组合"
- 适配器模式 `Adapter`
   - 桥接模式 `Bridge`
   - 组合模式 `Composite`
   - 装饰模式 `Decorator`
   - 外观模式 `Facade`
   - 享元模式 `Flyweight`
   - 代理模式 `Proxy`
   
3. **行为型** `Behavioral Pattern`：描述类或者对象的交互方式和职责分配
- 职责链模式 `Chain of Responsibility`
   - 命令模式 `Command`
   - 解释器模式 `Interpreter`
   - 迭代器模式 `Iterator`
   - 中介者模式 `Mediator`
   - 备忘录模式 `Memento`
   - 观察者模式 `Observer`
   - 状态模式 `State`
   - 策略模式 `Strategy`
   - 模板方法模式 `Template Method`
   - 访问者模式 `Visitor`



设计模式按照作用范围可以为分为两种，作用于类的类模式、作用于对象（实例）的对象模式

1. 类模式
   - 工厂方法模式 `Factory Method`
   - 适配器模式 `Adapter`
   - 解释器模式 `Interpreter`
   - 模板方法模式 `Template Method`
2. 对象模式（包含剩下的19种）

"类模式" 主要集中处理类与子类之间的关系，这些关系通过继承来建立，再确定后便不再更改，是静态的。

"对象模式" 主要处理各对象之间的关系，可以变化，更具有动态性

## 1. 七大原则解读



### 1.1 开闭原则

定义：





里氏替换原则：

- 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法
- 子类中可以增加自己特有的方法
- 当子类的方法重载父类的方法时，方法的前置条件（即方法的输入参数）要比父类的方法更宽松
- 当子类的方法实现父类的方法时（重写/重载或实现抽象方法），方法的后置条件（即方法的的输出/返回值）要比父类的方法更严格或相等

-- 摘自 [C语言中文网-设计模式](http://c.biancheng.net/view/1324.html)

## 2. 23种设计模式用途介绍

- 简单工厂模式 `Simple Factory`：
- 工厂方法模式 `Factory Method`
- 抽象工厂模式 `Abstract Factory`：提供一个创建一系列相关或相互依赖对象的接口，无需指定具体的类
- 建造者模式 `Builder`：将一个复杂对象的构建与它的表示（实例）分离，使同样的创建过程可以创建不同的表示（实例）
- 原型模式 `Prototype`
- 单例模式 `Singleton`
- 适配器模式 `Adapter`：将一个类的接口转换为另一个需要的接口
- 桥接模式 `Bridge`：将抽象部分与实现部分分离
- 组合模式 `Composite`
- 装饰模式 `Decorator`
- 外观模式 `Facade`
- 享元模式 `Flyweight`
- 代理模式 `Proxy`
- 职责链模式 `Chain of Responsibility`：为解除请求的发送者和接收者之间耦合，而使多个对象都有机会处理这个请求
- 命令模式 `Command`
- 解释器模式 `Interpreter`
- 迭代器模式 `Iterator`
- 中介者模式 `Mediator`
- 备忘录模式 `Memento`
- 观察者模式 `Observer`
- 状态模式 `State`
- 策略模式 `Strategy`
- 模板方法模式 `Template Method`
- 访问者模式 `Visitor`