# ES2015-ES2025 新特性完全指南

## ES2015 (ES6)

### 1. let 和 const
**let**：块级作用域变量声明，避免变量提升和重复声明。
**const**：声明常量，赋值后不可更改。
```javascript
// let 示例
let x = 1;
{
  let x = 2; // 不同的块级作用域
  console.log(x); // 2
}
console.log(x); // 1

// const 示例
const PI = 3.14159;
const obj = { name: 'John' };
obj.name = 'Jane'; // 可以修改对象属性
// obj = {}; // 错误：不能重新赋值
```

### 2. 箭头函数 (Arrow Functions)
简洁的函数写法，自动绑定外部 this。
```javascript
// 基本语法
const add = (a, b) => a + b;

// 多行函数体
const multiply = (a, b) => {
  const result = a * b;
  return result;
};

// this 绑定示例
class Counter {
  constructor() {
    this.count = 0;
  }
  
  start() {
    setInterval(() => {
      this.count++; // this 正确绑定到 Counter 实例
      console.log(this.count);
    }, 1000);
  }
}
```

### 3. 模板字符串 (Template Literals)
使用反引号 ``，支持多行和变量插值。
```javascript
// 基本插值
const name = 'World';
const greeting = `Hello ${name}!`;

// 多行字符串
const html = `
  <div>
    <h1>${title}</h1>
    <p>${content}</p>
  </div>
`;

// 标签模板
function highlight(strings, ...values) {
  return strings.reduce((result, str, i) => 
    result + str + (values[i] ? `<span>${values[i]}</span>` : ''), '');
}
const highlighted = highlight`Hello ${name}!`;
```

### 4. 解构赋值 (Destructuring)
快速从数组或对象中提取值。
```javascript
// 数组解构
const [a, b, ...rest] = [1, 2, 3, 4, 5];
console.log(a, b, rest); // 1, 2, [3, 4, 5]

// 对象解构
const { name, age: userAge, ...otherProps } = { 
  name: 'Tom', 
  age: 18, 
  city: 'New York' 
};
console.log(name, userAge, otherProps); // 'Tom', 18, { city: 'New York' }

// 默认值
const { title = 'Untitled' } = {};
console.log(title); // 'Untitled'

// 嵌套解构
const { user: { name: userName } } = { user: { name: 'John' } };
console.log(userName); // 'John'
```

### 5. 类和模块 (Classes & Modules)
更接近传统面向对象写法，支持继承和模块化导入导出。
```javascript
// 类定义
class Person {
  constructor(name) {
    this.name = name;
  }
  
  sayHello() {
    console.log(`Hello, ${this.name}!`);
  }
  
  static create(name) {
    return new Person(name);
  }
}

// 继承
class Employee extends Person {
  constructor(name, role) {
    super(name);
    this.role = role;
  }
  
  sayHello() {
    super.sayHello();
    console.log(`I am a ${this.role}`);
  }
}

// 模块导出
export class User extends Person {}
export const helper = () => {};

// 模块导入
import { User, helper } from './user.js';
```

### 6. Promise
统一异步编程接口，支持链式调用。
```javascript
// 基本用法
const promise = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('done');
  }, 1000);
});

promise
  .then(result => console.log(result))
  .catch(error => console.error(error));

// 链式调用
fetch('api/data')
  .then(response => response.json())
  .then(data => processData(data))
  .catch(error => handleError(error));

// Promise.all
Promise.all([
  fetch('api/users'),
  fetch('api/posts')
])
  .then(([users, posts]) => {
    // 处理所有请求结果
  });

// Promise.race
Promise.race([
  fetch('api/data'),
  new Promise((_, reject) => 
    setTimeout(() => reject(new Error('Timeout')), 5000)
  )
]);
```

### 7. 生成器和迭代器 (Generators & Iterators)
生成器函数可暂停和恢复执行，适合异步流程和自定义迭代。
```javascript
// 基本生成器
function* generator() {
  yield 1;
  yield 2;
  yield 3;
}

for (const value of generator()) {
  console.log(value);
}

// 异步生成器
async function* asyncGenerator() {
  yield await Promise.resolve(1);
  yield await Promise.resolve(2);
}

// 自定义迭代器
const iterable = {
  *[Symbol.iterator]() {
    yield 1;
    yield 2;
    yield 3;
  }
};

for (const value of iterable) {
  console.log(value);
}
```

### 8. Map/Set/WeakMap/WeakSet
新的集合类型，支持任意类型键和值。
```javascript
// Map
const map = new Map();
map.set('key', 'value');
map.set(1, 'number');
map.set({}, 'object');

// Set
const set = new Set([1, 2, 3, 3, 4]); // 自动去重
console.log([...set]); // [1, 2, 3, 4]

// WeakMap
const weakMap = new WeakMap();
const obj = {};
weakMap.set(obj, 'value');
// 当 obj 被垃圾回收时，对应的值也会被回收

// WeakSet
const weakSet = new WeakSet();
weakSet.add(obj);
// 当 obj 被垃圾回收时，会自动从 weakSet 中移除
```

### 9. Symbol
唯一值的基本类型，常用于对象属性名避免冲突。
```javascript
// 创建 Symbol
const sym1 = Symbol('description');
const sym2 = Symbol('description');
console.log(sym1 === sym2); // false

// 作为对象属性
const obj = {
  [sym1]: 'value'
};

// 内置 Symbol
class MyArray extends Array {
  static get [Symbol.species]() {
    return Array;
  }
}

// Symbol.iterator
const iterable = {
  *[Symbol.iterator]() {
    yield 1;
    yield 2;
  }
};
```

### 10. Proxy & Reflect
元编程能力，拦截对象操作。
```javascript
// Proxy 示例
const target = { foo: 'bar' };
const handler = {
  get(obj, prop) {
    return prop in obj ? obj[prop] : 'default';
  },
  set(obj, prop, value) {
    if (typeof value === 'string') {
      obj[prop] = value;
      return true;
    }
    return false;
  }
};

const proxy = new Proxy(target, handler);
console.log(proxy.foo); // 'bar'
console.log(proxy.abc); // 'default'

// Reflect 示例
const obj = { x: 1, y: 2 };
Reflect.set(obj, 'z', 3);
console.log(Reflect.get(obj, 'z')); // 3
```

### 11. 其他
- 默认参数、剩余参数、扩展运算符、for...of、字符串/数组/对象新方法等。
```javascript
// 默认参数
function greet(name = 'Guest') {
  console.log(`Hello, ${name}!`);
}

// 剩余参数
function sum(...numbers) {
  return numbers.reduce((total, n) => total + n, 0);
}

// 扩展运算符
const arr1 = [1, 2, 3];
const arr2 = [...arr1, 4, 5];

// for...of
for (const char of 'hello') {
  console.log(char);
}

// 新方法
'hello'.includes('ell'); // true
[1, 2, 3].find(x => x > 1); // 2
Object.assign({}, { a: 1 }, { b: 2 });
```



## ES2016 (ES7)

### 1. Array.prototype.includes()
判断数组是否包含某元素，支持 NaN。
```javascript
const array = [1, 2, NaN];
console.log(array.includes(NaN)); // true
console.log(array.includes(2)); // true
console.log(array.includes(3)); // false

// 与 indexOf 的区别
console.log([NaN].indexOf(NaN)); // -1
console.log([NaN].includes(NaN)); // true
```

### 2. 指数运算符 (Exponentiation Operator)
2 ** 3 等价于 Math.pow(2, 3)
```javascript
const result = 2 ** 3; // 8
const square = 2 ** 2; // 4
const cube = 2 ** 3; // 8

// 与 Math.pow 的区别
console.log(2 ** 3 ** 2); // 512 (右结合)
console.log(Math.pow(2, Math.pow(3, 2))); // 512
```



## ES2017 (ES8)

### 1. async/await
基于 Promise 的异步编程语法糖。
```javascript
// 基本用法
async function fetchData() {
  try {
    const response = await fetch('api/data');
    const data = await response.json();
    return data;
  } catch (error) {
    console.error('Error:', error);
  }
}

// 并行请求
async function fetchMultiple() {
  const [users, posts] = await Promise.all([
    fetch('api/users').then(r => r.json()),
    fetch('api/posts').then(r => r.json())
  ]);
  return { users, posts };
}

// 异步迭代
async function* asyncGenerator() {
  yield await Promise.resolve(1);
  yield await Promise.resolve(2);
}
```

### 2. Object.values() 和 Object.entries()
快速获取对象的值数组或键值对数组。
```javascript
const obj = { a: 1, b: 2, c: 3 };

// Object.values
console.log(Object.values(obj)); // [1, 2, 3]

// Object.entries
for (const [key, value] of Object.entries(obj)) {
  console.log(`${key}: ${value}`);
}

// 转换为 Map
const map = new Map(Object.entries(obj));
```

### 3. String padding
字符串补全。
```javascript
// padStart
'x'.padStart(5, 'a'); // 'aaaax'
'123'.padStart(5, '0'); // '00123'

// padEnd
'x'.padEnd(5, 'a'); // 'xaaaa'
'123'.padEnd(5, '0'); // '12300'

// 实际应用
function formatNumber(num) {
  return num.toString().padStart(2, '0');
}
console.log(formatNumber(5)); // '05'
```

### 4. Object.getOwnPropertyDescriptors
获取对象所有属性描述符。
```javascript
const obj = {
  get name() {
    return 'John';
  }
};

const descriptors = Object.getOwnPropertyDescriptors(obj);
console.log(descriptors.name.get); // [Function: get name]

// 用于克隆对象
const clone = Object.create(
  Object.getPrototypeOf(obj),
  Object.getOwnPropertyDescriptors(obj)
);
```

### 5. SharedArrayBuffer & Atomics
多线程共享内存和原子操作，适合高性能场景。
```javascript
// 创建共享内存
const buffer = new SharedArrayBuffer(1024);
const view = new Int32Array(buffer);

// 原子操作
Atomics.store(view, 0, 123);
const value = Atomics.load(view, 0);
Atomics.add(view, 0, 1);
```



## ES2018 (ES9)

### 1. 异步迭代 (Async Iteration)
支持 for await...of 语法，异步遍历。
```javascript
// 异步生成器
async function* asyncGenerator() {
  yield await Promise.resolve(1);
  yield await Promise.resolve(2);
  yield await Promise.resolve(3);
}

// 异步迭代
(async () => {
  for await (const value of asyncGenerator()) {
    console.log(value);
  }
})();

// 实际应用：读取文件流
async function processFile(file) {
  for await (const chunk of file.stream()) {
    processChunk(chunk);
  }
}
```

### 2. Rest/Spread 属性
对象剩余/扩展属性。
```javascript
// 对象解构
const { x, y, ...rest } = { x: 1, y: 2, a: 3, b: 4 };
console.log(rest); // { a: 3, b: 4 }

// 对象合并
const obj1 = { foo: 'bar', x: 42 };
const obj2 = { foo: 'baz', y: 13 };
const clonedObj = { ...obj1 };
const mergedObj = { ...obj1, ...obj2 };
```

### 3. Promise.finally()
无论成功失败都会执行。
```javascript
fetch('api/data')
  .then(response => response.json())
  .then(data => processData(data))
  .catch(error => handleError(error))
  .finally(() => {
    // 清理工作
    cleanup();
  });
```

### 4. 正则增强
命名捕获组、s 修饰符、后行断言等。
```javascript
// 命名捕获组
const re = /(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})/;
const result = re.exec('2023-05-01');
console.log(result.groups.year); // '2023'

// s 修饰符（dotAll）
const re2 = /hello.world/s;
console.log(re2.test('hello\nworld')); // true

// 后行断言
const re3 = /(?<=\$)\d+/;
console.log(re3.exec('$123')); // ['123']
```



## ES2019 (ES10)

### 1. Array.prototype.flat() 和 flatMap()
数组扁平化和映射。
```javascript
// flat
[1, 2, [3, 4]].flat(); // [1, 2, 3, 4]
[1, 2, [3, 4, [5, 6]]].flat(2); // [1, 2, 3, 4, 5, 6]

// flatMap
[1, 2, 3].flatMap(x => [x, x * 2]); // [1, 2, 2, 4, 3, 6]

// 实际应用
const sentences = ['Hello world', 'How are you'];
const words = sentences.flatMap(s => s.split(' '));
```

### 2. Object.fromEntries()
键值对数组转对象。
```javascript
// 基本用法
const entries = [['name', 'John'], ['age', 30]];
const obj = Object.fromEntries(entries);
console.log(obj); // { name: 'John', age: 30 }

// 实际应用：URL 参数解析
const params = new URLSearchParams('name=John&age=30');
const paramsObj = Object.fromEntries(params);
```

### 3. String.trimStart/trimEnd
去除字符串首尾空白。
```javascript
// trimStart
'  hello '.trimStart(); // 'hello '

// trimEnd
'  hello '.trimEnd(); // '  hello'

// 实际应用
function formatName(name) {
  return name.trimStart().trimEnd();
}
```

### 4. 可选 catch 绑定
catch 可以省略 error 参数。
```javascript
try {
  // 可能抛出错误的代码
} catch {
  // 不需要使用 error 参数
  console.log('An error occurred');
}
```



## ES2020 (ES11)

### 1. 可选链操作符 (Optional Chaining)
安全访问多层嵌套属性。
```javascript
// 对象属性访问
const value = obj?.prop?.nested?.value;

// 数组元素访问
const first = arr?.[0];

// 函数调用
const result = obj.method?.();

// 实际应用
function getCity(user) {
  return user?.address?.city ?? 'Unknown';
}
```

### 2. 空值合并操作符 (Nullish Coalescing)
只在 null 或 undefined 时使用默认值。
```javascript
// 基本用法
const value = null ?? 'default';
const count = 0 ?? 42; // 0

// 与 || 的区别
const value1 = 0 || 42; // 42
const value2 = 0 ?? 42; // 0

// 实际应用
function greet(name) {
  return `Hello, ${name ?? 'Guest'}!`;
}
```

### 3. BigInt
支持任意精度整数。
```javascript
// 创建 BigInt
const bigInt = 9007199254740991n;
const bigInt2 = BigInt(9007199254740991);

// 运算
const sum = bigInt + 1n;
const product = bigInt * 2n;

// 实际应用：大数计算
function calculateFactorial(n) {
  let result = 1n;
  for (let i = 2n; i <= n; i++) {
    result *= i;
  }
  return result;
}
```

### 4. Promise.allSettled()
所有 Promise 完成后返回每个结果。
```javascript
// 基本用法
Promise.allSettled([
  Promise.resolve(1),
  Promise.reject('error'),
  Promise.resolve(3)
]).then(results => {
  console.log(results);
  // [
  //   { status: 'fulfilled', value: 1 },
  //   { status: 'rejected', reason: 'error' },
  //   { status: 'fulfilled', value: 3 }
  // ]
});

// 实际应用：批量请求
async function fetchAll(urls) {
  const results = await Promise.allSettled(
    urls.map(url => fetch(url))
  );
  return results.map(result => 
    result.status === 'fulfilled' ? result.value : null
  );
}
```

### 5. globalThis
统一全局对象。
```javascript
// 浏览器环境
console.log(globalThis === window); // true

// Node.js 环境
console.log(globalThis === global); // true

// 实际应用
function getGlobal() {
  return globalThis;
}
```

### 6. 动态 import
按需异步加载模块。
```javascript
// 基本用法
const module = await import('./module.js');

// 条件导入
if (condition) {
  const { default: Component } = await import('./Component.js');
}

// 实际应用：路由懒加载
const routes = [
  {
    path: '/about',
    component: () => import('./About.js')
  }
];
```



## ES2021 (ES12)

### 1. String.prototype.replaceAll()
全部替换字符串。
```javascript
// 基本用法
'hello world'.replaceAll('o', '0'); // 'hell0 w0rld'

// 与 replace 的区别
'hello world'.replace(/o/g, '0'); // 需要正则
'hello world'.replaceAll('o', '0'); // 直接使用字符串

// 实际应用
function sanitizeHTML(str) {
  return str.replaceAll('<', '&lt;').replaceAll('>', '&gt;');
}
```

### 2. Promise.any()
只要有一个 Promise 成功就返回。
```javascript
// 基本用法
Promise.any([
  Promise.reject('error1'),
  Promise.resolve('success'),
  Promise.reject('error2')
]).then(result => {
  console.log(result); // 'success'
});

// 实际应用：多源数据获取
async function fetchFromAnySource(urls) {
  try {
    const result = await Promise.any(
      urls.map(url => fetch(url).then(r => r.json()))
    );
    return result;
  } catch (error) {
    console.error('All requests failed');
  }
}
```

### 3. 逻辑赋值运算符 (Logical Assignment)
简化赋值逻辑。
```javascript
// 基本用法
let x = 1;
x ||= 2; // x = x || 2
x &&= 3; // x = x && 3
x ??= 4; // x = x ?? 4

// 实际应用
function updateConfig(config) {
  config.timeout ??= 1000;
  config.retries ||= 3;
  return config;
}
```

### 4. WeakRef & FinalizationRegistry
弱引用和终结器，适合缓存等场景。
```javascript
// WeakRef
const cache = new Map();
function getCachedData(key) {
  let ref = cache.get(key);
  if (ref) {
    const value = ref.deref();
    if (value) return value;
  }
  const value = computeExpensiveValue();
  cache.set(key, new WeakRef(value));
  return value;
}

// FinalizationRegistry
const registry = new FinalizationRegistry(heldValue => {
  console.log(`Cleaning up: ${heldValue}`);
});

registry.register(target, 'some value');
```



## ES2022 (ES13)

### 1. Class 字段声明 (Class Fields)
类字段和私有字段。
```javascript
class Person {
  // 公共字段
  name = 'John';
  
  // 私有字段
  #privateField = 'private';
  
  // 静态字段
  static count = 0;
  
  // 私有静态字段
  static #privateStaticField = 'private static';
  
  constructor() {
    Person.count++;
  }
  
  getPrivateField() {
    return this.#privateField;
  }
}
```

### 2. Top-level await
模块顶层直接使用 await。
```javascript
// 基本用法
const response = await fetch('api/data');
const data = await response.json();

// 实际应用：模块初始化
const config = await loadConfig();
export const api = createAPI(config);
```

### 3. Object.hasOwn()
判断对象自身属性。
```javascript
// 基本用法
const obj = { prop: 'value' };
console.log(Object.hasOwn(obj, 'prop')); // true
console.log(Object.hasOwn(obj, 'toString')); // false

// 与 hasOwnProperty 的区别
const obj2 = Object.create(null);
obj2.prop = 'value';
console.log(obj2.hasOwnProperty('prop')); // 错误
console.log(Object.hasOwn(obj2, 'prop')); // true
```

### 4. Error cause
错误链路。
```javascript
// 基本用法
try {
  throw new Error('fail', { cause: 'reason' });
} catch (e) {
  console.log(e.cause); // 'reason'
}

// 实际应用：错误传播
async function fetchData() {
  try {
    const response = await fetch('api/data');
    if (!response.ok) {
      throw new Error('HTTP error', { 
        cause: { status: response.status }
      });
    }
    return response.json();
  } catch (error) {
    throw new Error('Failed to fetch data', { cause: error });
  }
}
```



## ES2023 (ES14)

### 1. Array.prototype.findLast / findLastIndex
从数组末尾查找满足条件的元素或索引。
```javascript
// 基本用法
const arr = [1, 2, 3, 4, 5];
arr.findLast(x => x % 2 === 0); // 4
arr.findLastIndex(x => x % 2 === 0); // 3

// 实际应用：查找最后一个匹配项
const logs = [
  { id: 1, status: 'success' },
  { id: 2, status: 'error' },
  { id: 3, status: 'success' }
];
const lastSuccess = logs.findLast(log => log.status === 'success');
```

### 2. WeakMap 和 WeakSet 支持 Symbol 键
```javascript
// 基本用法
const weakMap = new WeakMap();
const symbol = Symbol('key');
weakMap.set(symbol, 'value');

// 实际应用：私有数据存储
const privateData = new WeakMap();
class MyClass {
  constructor() {
    privateData.set(this, {
      secret: 'value'
    });
  }
  
  getSecret() {
    return privateData.get(this).secret;
  }
}
```

### 3. Hashbang 支持
允许脚本以 `#!` 开头。
```javascript
#!/usr/bin/env node
// 现在可以直接运行脚本
console.log('Hello, world!');
```



## ES2024 (ES15)

### 1. Temporal API
新一代日期时间处理标准，支持时区、纳秒精度、不可变对象等。
```javascript
// 创建日期时间
const now = Temporal.Now.instant();
const date = Temporal.PlainDate.from('2024-01-01');
const time = Temporal.PlainTime.from('09:00:00');
const dateTime = Temporal.PlainDateTime.from('2024-01-01T09:00:00');

// 时区处理
const zonedDateTime = Temporal.ZonedDateTime.from({
  timeZone: 'Asia/Shanghai',
  year: 2024,
  month: 1,
  day: 1,
  hour: 9
});

// 日期计算
const nextWeek = date.add({ days: 7 });
const difference = date.until(nextWeek);

// 格式化
const formatted = dateTime.toLocaleString('zh-CN', {
  year: 'numeric',
  month: 'long',
  day: 'numeric'
});
```



## 草案特性合集 (Draft Features Collection)

### 1. 装饰器（Decorators，Stage 3）
为类和类成员添加元编程注解和行为扩展。
```javascript
// 类装饰器
@sealed
class Example {
  // 方法装饰器
  @readonly
  method() {}
  
  // 属性装饰器
  @validate
  name = '';
}

// 装饰器实现
function sealed(constructor) {
  Object.seal(constructor);
  Object.seal(constructor.prototype);
}

function readonly(target, propertyKey, descriptor) {
  descriptor.writable = false;
  return descriptor;
}

function validate(target, propertyKey) {
  let value = target[propertyKey];
  
  const getter = function() {
    return value;
  };
  
  const setter = function(newVal) {
    if (typeof newVal !== 'string') {
      throw new Error('Value must be a string');
    }
    value = newVal;
  };
  
  Object.defineProperty(target, propertyKey, {
    get: getter,
    set: setter
  });
}
```

### 2. 管道操作符 (Pipeline Operator，Stage 2/3)
让函数式链式调用更直观。
```javascript
// 基本用法
const double = x => x * 2;
const increment = x => x + 1;
const result = 3 |> double |> increment; // 7

// 实际应用：数据处理管道
const data = [1, 2, 3, 4, 5]
  |> filter(x => x % 2 === 0)
  |> map(x => x * 2)
  |> reduce((a, b) => a + b);
```

### 3. 部分应用 (Partial Application，Stage 3)
允许用 `?` 占位符预先填充部分参数，返回新函数。
```javascript
// 基本用法
const add = (x, y) => x + y;
const addOne = add(?, 1);
addOne(5); // 6

// 实际应用：事件处理
const handleClick = (event, id) => {
  console.log(`Clicked ${id}:`, event);
};
const handleClickWithId = handleClick(?, 'button-1');
button.addEventListener('click', handleClickWithId);
```

### 4. 模式匹配 (Pattern Matching，Stage 1/2/3)
类似于 switch，但支持结构化匹配和解构。
```javascript
// 基本用法
match (value) {
  when { type: 'success', data } => handleSuccess(data),
  when { type: 'error', error } => handleError(error),
  when { type: 'loading' } => showLoading(),
  when { type: 'idle' } => showIdle()
}

// 实际应用：状态处理
function handleResponse(response) {
  match (response) {
    when { status: 200, data } => processData(data),
    when { status: 404 } => showNotFound(),
    when { status: 500, error } => handleServerError(error)
  }
}
```

### 5. 类型注解 (Type Annotations，Stage 3)
为 JS 代码添加类型注解，未来可用于类型检查和 IDE 智能提示。
```javascript
// 基本用法
function add(x: number, y: number): number {
  return x + y;
}

// 接口定义
interface User {
  name: string;
  age: number;
  email?: string;
}

// 类型别名
type Point = {
  x: number;
  y: number;
};

// 泛型
function identity<T>(value: T): T {
  return value;
}
```

### 6. Array.prototype.groupBy（Stage 3）
根据回调结果分组数组元素。
```javascript
// 基本用法
const array = [1, 2, 3, 4, 5];
const groups = array.groupBy(x => x % 2 === 0 ? 'even' : 'odd');
// { odd: [1, 3, 5], even: [2, 4] }

// 实际应用：数据分组
const users = [
  { name: 'John', age: 20 },
  { name: 'Jane', age: 30 },
  { name: 'Bob', age: 20 }
];
const ageGroups = users.groupBy(user => user.age);
```

### 7. Array.prototype.toSorted / toReversed / toSpliced（Stage 3）
不可变数组操作方法。
```javascript
// 基本用法
const arr = [3, 1, 2];
const sorted = arr.toSorted(); // [1, 2, 3]
const reversed = arr.toReversed(); // [2, 1, 3]
const spliced = arr.toSpliced(1, 1, 4); // [3, 4, 2]

// 实际应用：不可变数据处理
function updateList(list, index, value) {
  return list.toSpliced(index, 1, value);
}
```

### 8. Set 方法扩展（Stage 3）
Set.prototype.intersection, difference, union, symmetricDifference
```javascript
// 基本用法
const a = new Set([1, 2, 3]);
const b = new Set([2, 3, 4]);

const union = a.union(b); // Set {1,2,3,4}
const intersection = a.intersection(b); // Set {2,3}
const difference = a.difference(b); // Set {1}
const symmetricDifference = a.symmetricDifference(b); // Set {1,4}

// 实际应用：集合操作
function findCommonElements(setA, setB) {
  return setA.intersection(setB);
}
```

### 9. Symbol.metadata（Stage 3）
为类和对象提供元数据存储。
```javascript
// 基本用法
@metadata({ version: '1.0' })
class MyClass {
  @metadata({ required: true })
  property = 'value';
}

// 访问元数据
const metadata = Symbol.metadata;
console.log(MyClass[metadata]); // { version: '1.0' }
```

> 注意：以上特性仍处于提案阶段，可能会发生变化。具体实现细节请参考 [TC39 提案](https://github.com/tc39/proposals)。

