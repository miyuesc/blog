# ç»“æ„å‹æ¨¡å¼ï¼šä¼˜é›…ç»„åˆçš„è‰ºæœ¯

> å¦‚æœè¯´åˆ›å»ºå‹æ¨¡å¼æ˜¯"ç”Ÿäº§"å¯¹è±¡çš„è‰ºæœ¯ï¼Œé‚£ä¹ˆç»“æ„å‹æ¨¡å¼å°±æ˜¯"ç»„è£…"å¯¹è±¡çš„è‰ºæœ¯ã€‚ä»Šå¤©æˆ‘ä»¬æ¥çœ‹çœ‹å¦‚ä½•ä¼˜é›…åœ°ç»„åˆå¯¹è±¡ï¼Œè®©ä»£ç ç»“æ„æ›´åŠ æ¸…æ™°ã€çµæ´»ã€‚

## å‰è¨€ï¼šä¸ºä»€ä¹ˆéœ€è¦ç»“æ„å‹æ¨¡å¼ï¼Ÿ

æƒ³è±¡ä¸€ä¸‹ï¼Œä½ æ­£åœ¨å¼€å‘ä¸€ä¸ªå¤æ‚çš„å‰ç«¯åº”ç”¨ï¼Œéšç€åŠŸèƒ½çš„å¢åŠ ï¼Œä½ å‘ç°ï¼š

- ç»„ä»¶ä¹‹é—´çš„å…³ç³»è¶Šæ¥è¶Šå¤æ‚ï¼Œéš¾ä»¥ç»´æŠ¤
- æƒ³è¦å¤ç”¨æŸäº›åŠŸèƒ½ï¼Œä½†ä»£ç è€¦åˆåº¦å¤ªé«˜
- éœ€è¦é€‚é…ä¸åŒçš„æ¥å£ï¼Œä½†æ”¹åŠ¨æˆæœ¬å¾ˆå¤§
- æƒ³è¦åŠ¨æ€åœ°ç»™å¯¹è±¡æ·»åŠ åŠŸèƒ½ï¼Œä½†ä¸æƒ³ä¿®æ”¹åŸæœ‰ä»£ç 

è¿™æ—¶å€™ï¼Œç»“æ„å‹æ¨¡å¼å°±æ´¾ä¸Šç”¨åœºäº†ã€‚å®ƒä»¬ä¸“æ³¨äºå¦‚ä½•å°†ç±»æˆ–å¯¹è±¡ç»„åˆæˆæ›´å¤§çš„ç»“æ„ï¼Œè®©ç³»ç»Ÿæ›´åŠ çµæ´»å’Œå¯æ‰©å±•ã€‚

## ä¸€ã€é€‚é…å™¨æ¨¡å¼ï¼šæ¥å£è½¬æ¢çš„"ç¿»è¯‘å®˜"

### 1.1 ä»€ä¹ˆæ˜¯é€‚é…å™¨æ¨¡å¼ï¼Ÿ

é€‚é…å™¨æ¨¡å¼å…è®¸æ¥å£ä¸å…¼å®¹çš„ç±»ä¸€èµ·å·¥ä½œï¼Œå®ƒå……å½“ä¸¤ä¸ªä¸å…¼å®¹æ¥å£ä¹‹é—´çš„æ¡¥æ¢ã€‚åœ¨å‰ç«¯å¼€å‘ä¸­ï¼Œè¿™ç§æ¨¡å¼éå¸¸å¸¸è§ï¼š

- ç¬¬ä¸‰æ–¹åº“çš„æ¥å£é€‚é…
- æ–°æ—§ API çš„å…¼å®¹
- ä¸åŒæ•°æ®æ ¼å¼çš„è½¬æ¢

### 1.2 ç¬¬ä¸‰æ–¹åº“é€‚é…å®æˆ˜

å‡è®¾æˆ‘ä»¬è¦é›†æˆå¤šä¸ªåœ°å›¾æœåŠ¡æä¾›å•†ï¼Œä½†å®ƒä»¬çš„ API æ¥å£å„ä¸ç›¸åŒï¼š

```javascript
// ç™¾åº¦åœ°å›¾ APIï¼ˆå‡è®¾çš„æ¥å£ï¼‰
class BaiduMap {
  constructor(container) {
    this.container = container;
    this.map = null;
  }
  
  init(lat, lng, zoom) {
    console.log(`åˆå§‹åŒ–ç™¾åº¦åœ°å›¾: çº¬åº¦${lat}, ç»åº¦${lng}, ç¼©æ”¾${zoom}`);
    this.map = {
      center: { lat, lng },
      zoom,
      type: 'baidu'
    };
  }
  
  addMarker(lat, lng, title, icon) {
    console.log(`ç™¾åº¦åœ°å›¾æ·»åŠ æ ‡è®°: ${title} at (${lat}, ${lng})`);
    return {
      id: Date.now(),
      position: { lat, lng },
      title,
      icon
    };
  }
  
  setCenter(lat, lng) {
    console.log(`ç™¾åº¦åœ°å›¾è®¾ç½®ä¸­å¿ƒç‚¹: (${lat}, ${lng})`);
    this.map.center = { lat, lng };
  }
}

// é«˜å¾·åœ°å›¾ APIï¼ˆå‡è®¾çš„æ¥å£ï¼‰
class AMapAPI {
  constructor(containerId) {
    this.containerId = containerId;
    this.mapInstance = null;
  }
  
  create(options) {
    const { center, zoomLevel } = options;
    console.log(`åˆ›å»ºé«˜å¾·åœ°å›¾: ä¸­å¿ƒç‚¹[${center[0]}, ${center[1]}], ç¼©æ”¾çº§åˆ«${zoomLevel}`);
    this.mapInstance = {
      centerPoint: center,
      zoomLevel,
      type: 'amap'
    };
  }
  
  createMarker(position, options) {
    const { title, iconUrl } = options;
    console.log(`é«˜å¾·åœ°å›¾åˆ›å»ºæ ‡è®°: ${title} at [${position[0]}, ${position[1]}]`);
    return {
      markerId: Date.now(),
      pos: position,
      title,
      iconUrl
    };
  }
  
  panTo(position) {
    console.log(`é«˜å¾·åœ°å›¾ç§»åŠ¨åˆ°: [${position[0]}, ${position[1]}]`);
    this.mapInstance.centerPoint = position;
  }
}

// è°·æ­Œåœ°å›¾ APIï¼ˆå‡è®¾çš„æ¥å£ï¼‰
class GoogleMaps {
  constructor(element) {
    this.element = element;
    this.googleMap = null;
  }
  
  initialize(config) {
    const { lat, lng, zoom } = config;
    console.log(`åˆå§‹åŒ–è°·æ­Œåœ°å›¾: åæ ‡(${lat}, ${lng}), ç¼©æ”¾${zoom}`);
    this.googleMap = {
      location: { latitude: lat, longitude: lng },
      zoomLevel: zoom,
      type: 'google'
    };
  }
  
  placeMarker(coords, markerOptions) {
    const { lat, lng } = coords;
    const { label, icon } = markerOptions;
    console.log(`è°·æ­Œåœ°å›¾æ”¾ç½®æ ‡è®°: ${label} at (${lat}, ${lng})`);
    return {
      uuid: Date.now(),
      coordinates: { lat, lng },
      label,
      icon
    };
  }
  
  moveCenter(coords) {
    const { lat, lng } = coords;
    console.log(`è°·æ­Œåœ°å›¾ç§»åŠ¨ä¸­å¿ƒ: (${lat}, ${lng})`);
    this.googleMap.location = { latitude: lat, longitude: lng };
  }
}

// ç»Ÿä¸€çš„åœ°å›¾æ¥å£
class UnifiedMapInterface {
  initialize(lat, lng, zoom) {
    throw new Error('initialize æ–¹æ³•å¿…é¡»è¢«å®ç°');
  }
  
  addMarker(lat, lng, title, icon) {
    throw new Error('addMarker æ–¹æ³•å¿…é¡»è¢«å®ç°');
  }
  
  setCenter(lat, lng) {
    throw new Error('setCenter æ–¹æ³•å¿…é¡»è¢«å®ç°');
  }
  
  getMapInfo() {
    throw new Error('getMapInfo æ–¹æ³•å¿…é¡»è¢«å®ç°');
  }
}

// ç™¾åº¦åœ°å›¾é€‚é…å™¨
class BaiduMapAdapter extends UnifiedMapInterface {
  constructor(container) {
    super();
    this.baiduMap = new BaiduMap(container);
  }
  
  initialize(lat, lng, zoom) {
    this.baiduMap.init(lat, lng, zoom);
  }
  
  addMarker(lat, lng, title, icon) {
    return this.baiduMap.addMarker(lat, lng, title, icon);
  }
  
  setCenter(lat, lng) {
    this.baiduMap.setCenter(lat, lng);
  }
  
  getMapInfo() {
    return {
      provider: 'baidu',
      center: this.baiduMap.map?.center,
      zoom: this.baiduMap.map?.zoom
    };
  }
}

// é«˜å¾·åœ°å›¾é€‚é…å™¨
class AMapAdapter extends UnifiedMapInterface {
  constructor(container) {
    super();
    this.amap = new AMapAPI(container);
  }
  
  initialize(lat, lng, zoom) {
    this.amap.create({
      center: [lng, lat], // æ³¨æ„ï¼šé«˜å¾·åœ°å›¾æ˜¯ç»åº¦åœ¨å‰
      zoomLevel: zoom
    });
  }
  
  addMarker(lat, lng, title, icon) {
    return this.amap.createMarker([lng, lat], {
      title,
      iconUrl: icon
    });
  }
  
  setCenter(lat, lng) {
    this.amap.panTo([lng, lat]);
  }
  
  getMapInfo() {
    const center = this.amap.mapInstance?.centerPoint;
    return {
      provider: 'amap',
      center: center ? { lat: center[1], lng: center[0] } : null,
      zoom: this.amap.mapInstance?.zoomLevel
    };
  }
}

// è°·æ­Œåœ°å›¾é€‚é…å™¨
class GoogleMapAdapter extends UnifiedMapInterface {
  constructor(container) {
    super();
    this.googleMap = new GoogleMaps(container);
  }
  
  initialize(lat, lng, zoom) {
    this.googleMap.initialize({ lat, lng, zoom });
  }
  
  addMarker(lat, lng, title, icon) {
    return this.googleMap.placeMarker(
      { lat, lng },
      { label: title, icon }
    );
  }
  
  setCenter(lat, lng) {
    this.googleMap.moveCenter({ lat, lng });
  }
  
  getMapInfo() {
    const location = this.googleMap.googleMap?.location;
    return {
      provider: 'google',
      center: location ? { lat: location.latitude, lng: location.longitude } : null,
      zoom: this.googleMap.googleMap?.zoomLevel
    };
  }
}

// åœ°å›¾å·¥å‚
class MapFactory {
  static createMap(provider, container) {
    switch (provider) {
      case 'baidu':
        return new BaiduMapAdapter(container);
      case 'amap':
        return new AMapAdapter(container);
      case 'google':
        return new GoogleMapAdapter(container);
      default:
        throw new Error(`ä¸æ”¯æŒçš„åœ°å›¾æä¾›å•†: ${provider}`);
    }
  }
  
  static getSupportedProviders() {
    return ['baidu', 'amap', 'google'];
  }
}

// åœ°å›¾ç®¡ç†å™¨
class MapManager {
  constructor() {
    this.maps = new Map();
    this.currentProvider = null;
  }
  
  // åˆå§‹åŒ–åœ°å›¾
  async initializeMap(provider, container, lat, lng, zoom) {
    try {
      const map = MapFactory.createMap(provider, container);
      map.initialize(lat, lng, zoom);
      
      this.maps.set(provider, map);
      this.currentProvider = provider;
      
      console.log(`âœ… ${provider} åœ°å›¾åˆå§‹åŒ–æˆåŠŸ`);
      return map;
    } catch (error) {
      console.error(`âŒ ${provider} åœ°å›¾åˆå§‹åŒ–å¤±è´¥:`, error.message);
      throw error;
    }
  }
  
  // åˆ‡æ¢åœ°å›¾æä¾›å•†
  switchProvider(newProvider) {
    if (!this.maps.has(newProvider)) {
      throw new Error(`åœ°å›¾æä¾›å•† ${newProvider} å°šæœªåˆå§‹åŒ–`);
    }
    
    const oldProvider = this.currentProvider;
    this.currentProvider = newProvider;
    
    console.log(`ğŸ”„ ä» ${oldProvider} åˆ‡æ¢åˆ° ${newProvider}`);
    return this.getCurrentMap();
  }
  
  // è·å–å½“å‰åœ°å›¾
  getCurrentMap() {
    if (!this.currentProvider || !this.maps.has(this.currentProvider)) {
      throw new Error('æ²¡æœ‰å¯ç”¨çš„åœ°å›¾å®ä¾‹');
    }
    
    return this.maps.get(this.currentProvider);
  }
  
  // åœ¨æ‰€æœ‰åœ°å›¾ä¸Šæ·»åŠ æ ‡è®°
  addMarkerToAll(lat, lng, title, icon) {
    const results = [];
    
    for (const [provider, map] of this.maps) {
      try {
        const marker = map.addMarker(lat, lng, title, icon);
        results.push({ provider, marker, success: true });
      } catch (error) {
        results.push({ provider, error: error.message, success: false });
      }
    }
    
    return results;
  }
  
  // è·å–æ‰€æœ‰åœ°å›¾ä¿¡æ¯
  getAllMapInfo() {
    const info = {};
    
    for (const [provider, map] of this.maps) {
      info[provider] = map.getMapInfo();
    }
    
    return info;
  }
}

// ä½¿ç”¨ç¤ºä¾‹
async function mapDemo() {
  const mapManager = new MapManager();
  
  console.log('=== æ”¯æŒçš„åœ°å›¾æä¾›å•† ===');
  console.log(MapFactory.getSupportedProviders());
  
  console.log('\n=== åˆå§‹åŒ–ä¸åŒçš„åœ°å›¾ ===');
  const lat = 39.9042, lng = 116.4074, zoom = 10; // åŒ—äº¬åæ ‡
  
  await mapManager.initializeMap('baidu', 'baidu-container', lat, lng, zoom);
  await mapManager.initializeMap('amap', 'amap-container', lat, lng, zoom);
  await mapManager.initializeMap('google', 'google-container', lat, lng, zoom);
  
  console.log('\n=== åœ¨å½“å‰åœ°å›¾æ·»åŠ æ ‡è®° ===');
  const currentMap = mapManager.getCurrentMap();
  currentMap.addMarker(lat, lng, 'åŒ—äº¬', 'beijing-icon.png');
  
  console.log('\n=== åˆ‡æ¢åœ°å›¾æä¾›å•† ===');
  mapManager.switchProvider('amap');
  mapManager.getCurrentMap().setCenter(31.2304, 121.4737); // ä¸Šæµ·åæ ‡
  
  console.log('\n=== åœ¨æ‰€æœ‰åœ°å›¾æ·»åŠ æ ‡è®° ===');
  const results = mapManager.addMarkerToAll(31.2304, 121.4737, 'ä¸Šæµ·', 'shanghai-icon.png');
  results.forEach(result => {
    if (result.success) {
      console.log(`âœ… ${result.provider}: æ ‡è®°æ·»åŠ æˆåŠŸ`);
    } else {
      console.log(`âŒ ${result.provider}: ${result.error}`);
    }
  });
  
  console.log('\n=== è·å–æ‰€æœ‰åœ°å›¾ä¿¡æ¯ ===');
  const allMapInfo = mapManager.getAllMapInfo();
  console.log(JSON.stringify(allMapInfo, null, 2));
}

mapDemo();
```

### 1.3 æ•°æ®æ ¼å¼é€‚é…å™¨

åœ¨å®é™…å¼€å‘ä¸­ï¼Œæˆ‘ä»¬ç»å¸¸éœ€è¦å¤„ç†ä¸åŒæ ¼å¼çš„æ•°æ®ï¼š

```javascript
// ä¸åŒçš„æ•°æ®æºæ ¼å¼
class RestAPIDataSource {
  async fetchUsers() {
    // æ¨¡æ‹Ÿ REST API è¿”å›çš„æ•°æ®æ ¼å¼
    return {
      status: 'success',
      data: {
        users: [
          { id: 1, name: 'John Doe', email: 'john@example.com', age: 30 },
          { id: 2, name: 'Jane Smith', email: 'jane@example.com', age: 25 }
        ],
        total: 2,
        page: 1,
        pageSize: 10
      }
    };
  }
  
  async fetchUserById(id) {
    return {
      status: 'success',
      data: {
        user: { id, name: 'John Doe', email: 'john@example.com', age: 30 }
      }
    };
  }
}

class GraphQLDataSource {
  async query(query, variables = {}) {
    // æ¨¡æ‹Ÿ GraphQL è¿”å›çš„æ•°æ®æ ¼å¼
    if (query.includes('users')) {
      return {
        data: {
          users: {
            nodes: [
              { userId: 1, fullName: 'John Doe', emailAddress: 'john@example.com', userAge: 30 },
              { userId: 2, fullName: 'Jane Smith', emailAddress: 'jane@example.com', userAge: 25 }
            ],
            totalCount: 2,
            pageInfo: {
              hasNextPage: false,
              hasPreviousPage: false
            }
          }
        }
      };
    }
    
    if (query.includes('user') && variables.id) {
      return {
        data: {
          user: {
            userId: variables.id,
            fullName: 'John Doe',
            emailAddress: 'john@example.com',
            userAge: 30
          }
        }
      };
    }
  }
}

class WebSocketDataSource {
  constructor() {
    this.listeners = new Map();
    this.connected = false;
  }
  
  connect() {
    this.connected = true;
    console.log('WebSocket è¿æ¥å·²å»ºç«‹');
    
    // æ¨¡æ‹Ÿæ¥æ”¶å®æ—¶æ•°æ®
    setTimeout(() => {
      this.emit('userUpdate', {
        type: 'USER_UPDATED',
        payload: {
          user_id: 1,
          user_name: 'John Doe Updated',
          user_email: 'john.updated@example.com',
          user_age: 31,
          timestamp: Date.now()
        }
      });
    }, 2000);
  }
  
  subscribe(event, callback) {
    if (!this.listeners.has(event)) {
      this.listeners.set(event, []);
    }
    this.listeners.get(event).push(callback);
  }
  
  emit(event, data) {
    if (this.listeners.has(event)) {
      this.listeners.get(event).forEach(callback => callback(data));
    }
  }
}

// ç»Ÿä¸€çš„æ•°æ®æ¥å£
class UnifiedDataInterface {
  async getUsers(options = {}) {
    throw new Error('getUsers æ–¹æ³•å¿…é¡»è¢«å®ç°');
  }
  
  async getUserById(id) {
    throw new Error('getUserById æ–¹æ³•å¿…é¡»è¢«å®ç°');
  }
  
  subscribeToUpdates(callback) {
    throw new Error('subscribeToUpdates æ–¹æ³•å¿…é¡»è¢«å®ç°');
  }
}

// REST API é€‚é…å™¨
class RestAPIAdapter extends UnifiedDataInterface {
  constructor() {
    super();
    this.dataSource = new RestAPIDataSource();
  }
  
  async getUsers(options = {}) {
    const response = await this.dataSource.fetchUsers();
    
    // è½¬æ¢ä¸ºç»Ÿä¸€æ ¼å¼
    return {
      users: response.data.users.map(user => ({
        id: user.id,
        name: user.name,
        email: user.email,
        age: user.age
      })),
      total: response.data.total,
      pagination: {
        page: response.data.page,
        pageSize: response.data.pageSize,
        hasNext: response.data.total > response.data.page * response.data.pageSize
      }
    };
  }
  
  async getUserById(id) {
    const response = await this.dataSource.fetchUserById(id);
    
    return {
      id: response.data.user.id,
      name: response.data.user.name,
      email: response.data.user.email,
      age: response.data.user.age
    };
  }
  
  subscribeToUpdates(callback) {
    console.log('REST API ä¸æ”¯æŒå®æ—¶æ›´æ–°è®¢é˜…');
    return () => {}; // è¿”å›ç©ºçš„å–æ¶ˆè®¢é˜…å‡½æ•°
  }
}

// GraphQL é€‚é…å™¨
class GraphQLAdapter extends UnifiedDataInterface {
  constructor() {
    super();
    this.dataSource = new GraphQLDataSource();
  }
  
  async getUsers(options = {}) {
    const query = `
      query GetUsers {
        users {
          nodes {
            userId
            fullName
            emailAddress
            userAge
          }
          totalCount
          pageInfo {
            hasNextPage
            hasPreviousPage
          }
        }
      }
    `;
    
    const response = await this.dataSource.query(query);
    
    // è½¬æ¢ä¸ºç»Ÿä¸€æ ¼å¼
    return {
      users: response.data.users.nodes.map(user => ({
        id: user.userId,
        name: user.fullName,
        email: user.emailAddress,
        age: user.userAge
      })),
      total: response.data.users.totalCount,
      pagination: {
        hasNext: response.data.users.pageInfo.hasNextPage,
        hasPrevious: response.data.users.pageInfo.hasPreviousPage
      }
    };
  }
  
  async getUserById(id) {
    const query = `
      query GetUser($id: ID!) {
        user(id: $id) {
          userId
          fullName
          emailAddress
          userAge
        }
      }
    `;
    
    const response = await this.dataSource.query(query, { id });
    
    return {
      id: response.data.user.userId,
      name: response.data.user.fullName,
      email: response.data.user.emailAddress,
      age: response.data.user.userAge
    };
  }
  
  subscribeToUpdates(callback) {
    console.log('GraphQL è®¢é˜…åŠŸèƒ½éœ€è¦é¢å¤–å®ç°');
    return () => {};
  }
}

// WebSocket é€‚é…å™¨
class WebSocketAdapter extends UnifiedDataInterface {
  constructor() {
    super();
    this.dataSource = new WebSocketDataSource();
    this.cache = new Map();
  }
  
  async getUsers(options = {}) {
    // WebSocket é€šå¸¸ä¸ç”¨äºè·å–åˆ—è¡¨æ•°æ®ï¼Œè¿™é‡Œè¿”å›ç¼“å­˜çš„æ•°æ®
    if (this.cache.has('users')) {
      return this.cache.get('users');
    }
    
    // å¦‚æœæ²¡æœ‰ç¼“å­˜ï¼Œè¿”å›ç©ºæ•°æ®
    return {
      users: [],
      total: 0,
      pagination: { hasNext: false }
    };
  }
  
  async getUserById(id) {
    // ä»ç¼“å­˜ä¸­è·å–ç”¨æˆ·æ•°æ®
    const cacheKey = `user:${id}`;
    if (this.cache.has(cacheKey)) {
      return this.cache.get(cacheKey);
    }
    
    throw new Error(`ç”¨æˆ· ${id} ä¸åœ¨ç¼“å­˜ä¸­`);
  }
  
  subscribeToUpdates(callback) {
    if (!this.dataSource.connected) {
      this.dataSource.connect();
    }
    
    this.dataSource.subscribe('userUpdate', (data) => {
      // è½¬æ¢ WebSocket æ•°æ®æ ¼å¼ä¸ºç»Ÿä¸€æ ¼å¼
      const user = {
        id: data.payload.user_id,
        name: data.payload.user_name,
        email: data.payload.user_email,
        age: data.payload.user_age
      };
      
      // æ›´æ–°ç¼“å­˜
      this.cache.set(`user:${user.id}`, user);
      
      // è°ƒç”¨å›è°ƒå‡½æ•°
      callback({
        type: 'USER_UPDATED',
        user,
        timestamp: data.payload.timestamp
      });
    });
    
    return () => {
      console.log('å–æ¶ˆ WebSocket è®¢é˜…');
    };
  }
}

// æ•°æ®æºç®¡ç†å™¨
class DataSourceManager {
  constructor() {
    this.adapters = new Map();
    this.currentAdapter = null;
  }
  
  registerAdapter(name, adapter) {
    this.adapters.set(name, adapter);
    console.log(`âœ… æ³¨å†Œæ•°æ®é€‚é…å™¨: ${name}`);
  }
  
  setCurrentAdapter(name) {
    if (!this.adapters.has(name)) {
      throw new Error(`æ•°æ®é€‚é…å™¨ ${name} ä¸å­˜åœ¨`);
    }
    
    this.currentAdapter = name;
    console.log(`ğŸ”„ åˆ‡æ¢åˆ°æ•°æ®é€‚é…å™¨: ${name}`);
  }
  
  getCurrentAdapter() {
    if (!this.currentAdapter || !this.adapters.has(this.currentAdapter)) {
      throw new Error('æ²¡æœ‰å¯ç”¨çš„æ•°æ®é€‚é…å™¨');
    }
    
    return this.adapters.get(this.currentAdapter);
  }
  
  async getUsers(options) {
    const adapter = this.getCurrentAdapter();
    return await adapter.getUsers(options);
  }
  
  async getUserById(id) {
    const adapter = this.getCurrentAdapter();
    return await adapter.getUserById(id);
  }
  
  subscribeToUpdates(callback) {
    const adapter = this.getCurrentAdapter();
    return adapter.subscribeToUpdates(callback);
  }
  
  // èšåˆå¤šä¸ªæ•°æ®æºçš„æ•°æ®
  async aggregateUsers() {
    const results = {};
    
    for (const [name, adapter] of this.adapters) {
      try {
        const data = await adapter.getUsers();
        results[name] = {
          success: true,
          data,
          userCount: data.users.length
        };
      } catch (error) {
        results[name] = {
          success: false,
          error: error.message
        };
      }
    }
    
    return results;
  }
}

// ä½¿ç”¨ç¤ºä¾‹
async function dataAdapterDemo() {
  const dataManager = new DataSourceManager();
  
  // æ³¨å†Œä¸åŒçš„æ•°æ®é€‚é…å™¨
  dataManager.registerAdapter('rest', new RestAPIAdapter());
  dataManager.registerAdapter('graphql', new GraphQLAdapter());
  dataManager.registerAdapter('websocket', new WebSocketAdapter());
  
  console.log('\n=== ä½¿ç”¨ REST API è·å–æ•°æ® ===');
  dataManager.setCurrentAdapter('rest');
  const restUsers = await dataManager.getUsers();
  console.log('REST ç”¨æˆ·æ•°æ®:', JSON.stringify(restUsers, null, 2));
  
  const restUser = await dataManager.getUserById(1);
  console.log('REST å•ä¸ªç”¨æˆ·:', JSON.stringify(restUser, null, 2));
  
  console.log('\n=== ä½¿ç”¨ GraphQL è·å–æ•°æ® ===');
  dataManager.setCurrentAdapter('graphql');
  const graphqlUsers = await dataManager.getUsers();
  console.log('GraphQL ç”¨æˆ·æ•°æ®:', JSON.stringify(graphqlUsers, null, 2));
  
  console.log('\n=== è®¢é˜… WebSocket å®æ—¶æ›´æ–° ===');
  dataManager.setCurrentAdapter('websocket');
  const unsubscribe = dataManager.subscribeToUpdates((update) => {
    console.log('ğŸ“¡ æ”¶åˆ°å®æ—¶æ›´æ–°:', JSON.stringify(update, null, 2));
  });
  
  console.log('\n=== èšåˆæ‰€æœ‰æ•°æ®æº ===');
  const aggregatedData = await dataManager.aggregateUsers();
  console.log('èšåˆæ•°æ®:', JSON.stringify(aggregatedData, null, 2));
  
  // 3ç§’åå–æ¶ˆè®¢é˜…
  setTimeout(() => {
    unsubscribe();
    console.log('\nğŸ“´ å·²å–æ¶ˆ WebSocket è®¢é˜…');
  }, 3000);
}

dataAdapterDemo();
```

## äºŒã€è£…é¥°å™¨æ¨¡å¼ï¼šåŠ¨æ€å¢å¼ºå¯¹è±¡åŠŸèƒ½

### 2.1 ä»€ä¹ˆæ˜¯è£…é¥°å™¨æ¨¡å¼ï¼Ÿ

è£…é¥°å™¨æ¨¡å¼å…è®¸å‘ä¸€ä¸ªç°æœ‰çš„å¯¹è±¡æ·»åŠ æ–°çš„åŠŸèƒ½ï¼ŒåŒæ—¶åˆä¸æ”¹å˜å…¶ç»“æ„ã€‚è¿™ç§æ¨¡å¼åˆ›å»ºäº†ä¸€ä¸ªè£…é¥°ç±»ï¼Œç”¨æ¥åŒ…è£…åŸæœ‰çš„ç±»ï¼Œå¹¶åœ¨ä¿æŒç±»æ–¹æ³•ç­¾åå®Œæ•´æ€§çš„å‰æä¸‹ï¼Œæä¾›äº†é¢å¤–çš„åŠŸèƒ½ã€‚

### 2.2 å‡½æ•°è£…é¥°å™¨å®æˆ˜

```javascript
// åŸºç¡€çš„æ—¥å¿—è£…é¥°å™¨
function logDecorator(target, propertyKey, descriptor) {
  const originalMethod = descriptor.value;
  
  descriptor.value = function(...args) {
    console.log(`ğŸš€ è°ƒç”¨æ–¹æ³•: ${propertyKey}`);
    console.log(`ğŸ“¥ å‚æ•°:`, args);
    
    const startTime = performance.now();
    const result = originalMethod.apply(this, args);
    const endTime = performance.now();
    
    console.log(`ğŸ“¤ è¿”å›å€¼:`, result);
    console.log(`â±ï¸ æ‰§è¡Œæ—¶é—´: ${(endTime - startTime).toFixed(2)}ms`);
    
    return result;
  };
  
  return descriptor;
}

// ç¼“å­˜è£…é¥°å™¨
function cacheDecorator(ttl = 60000) { // é»˜è®¤ç¼“å­˜1åˆ†é’Ÿ
  const cache = new Map();
  
  return function(target, propertyKey, descriptor) {
    const originalMethod = descriptor.value;
    
    descriptor.value = function(...args) {
      const cacheKey = `${propertyKey}:${JSON.stringify(args)}`;
      const cached = cache.get(cacheKey);
      
      if (cached && Date.now() - cached.timestamp < ttl) {
        console.log(`ğŸ’¾ ç¼“å­˜å‘½ä¸­: ${propertyKey}`);
        return cached.value;
      }
      
      const result = originalMethod.apply(this, args);
      cache.set(cacheKey, {
        value: result,
        timestamp: Date.now()
      });
      
      console.log(`ğŸ’¿ ç¼“å­˜å­˜å‚¨: ${propertyKey}`);
      return result;
    };
    
    return descriptor;
  };
}

// é‡è¯•è£…é¥°å™¨
function retryDecorator(maxRetries = 3, delay = 1000) {
  return function(target, propertyKey, descriptor) {
    const originalMethod = descriptor.value;
    
    descriptor.value = async function(...args) {
      let lastError;
      
      for (let attempt = 1; attempt <= maxRetries; attempt++) {
        try {
          console.log(`ğŸ”„ å°è¯• ${attempt}/${maxRetries}: ${propertyKey}`);
          return await originalMethod.apply(this, args);
        } catch (error) {
          lastError = error;
          console.log(`âŒ å°è¯• ${attempt} å¤±è´¥:`, error.message);
          
          if (attempt < maxRetries) {
            console.log(`â³ ç­‰å¾… ${delay}ms åé‡è¯•...`);
            await new Promise(resolve => setTimeout(resolve, delay));
          }
        }
      }
      
      console.log(`ğŸ’¥ æ‰€æœ‰é‡è¯•éƒ½å¤±è´¥äº†`);
      throw lastError;
    };
    
    return descriptor;
  };
}

// æƒé™æ£€æŸ¥è£…é¥°å™¨
function requirePermission(permission) {
  return function(target, propertyKey, descriptor) {
    const originalMethod = descriptor.value;
    
    descriptor.value = function(...args) {
      // æ¨¡æ‹Ÿæƒé™æ£€æŸ¥
      const userPermissions = this.currentUser?.permissions || [];
      
      if (!userPermissions.includes(permission)) {
        throw new Error(`æƒé™ä¸è¶³: éœ€è¦ ${permission} æƒé™`);
      }
      
      console.log(`âœ… æƒé™æ£€æŸ¥é€šè¿‡: ${permission}`);
      return originalMethod.apply(this, args);
    };
    
    return descriptor;
  };
}

// æ€§èƒ½ç›‘æ§è£…é¥°å™¨
function performanceMonitor(target, propertyKey, descriptor) {
  const originalMethod = descriptor.value;
  const metrics = {
    callCount: 0,
    totalTime: 0,
    averageTime: 0,
    minTime: Infinity,
    maxTime: 0
  };
  
  descriptor.value = function(...args) {
    const startTime = performance.now();
    const result = originalMethod.apply(this, args);
    const endTime = performance.now();
    const executionTime = endTime - startTime;
    
    // æ›´æ–°æ€§èƒ½æŒ‡æ ‡
    metrics.callCount++;
    metrics.totalTime += executionTime;
    metrics.averageTime = metrics.totalTime / metrics.callCount;
    metrics.minTime = Math.min(metrics.minTime, executionTime);
    metrics.maxTime = Math.max(metrics.maxTime, executionTime);
    
    // å­˜å‚¨åˆ°å…¨å±€æ€§èƒ½ç›‘æ§å™¨
    if (!window.performanceMetrics) {
      window.performanceMetrics = {};
    }
    window.performanceMetrics[`${target.constructor.name}.${propertyKey}`] = metrics;
    
    return result;
  };
  
  return descriptor;
}

// ä½¿ç”¨è£…é¥°å™¨çš„æœåŠ¡ç±»
class UserService {
  constructor() {
    this.currentUser = null;
    this.users = [
      { id: 1, name: 'John', permissions: ['read', 'write'] },
      { id: 2, name: 'Jane', permissions: ['read'] },
      { id: 3, name: 'Admin', permissions: ['read', 'write', 'delete'] }
    ];
  }
  
  setCurrentUser(user) {
    this.currentUser = user;
    console.log(`ğŸ‘¤ å½“å‰ç”¨æˆ·: ${user.name}`);
  }
  
  @logDecorator
  @performanceMonitor
  @cacheDecorator(30000) // ç¼“å­˜30ç§’
  getUserById(id) {
    console.log(`ğŸ” ä»æ•°æ®åº“æŸ¥è¯¢ç”¨æˆ· ${id}`);
    // æ¨¡æ‹Ÿæ•°æ®åº“æŸ¥è¯¢å»¶è¿Ÿ
    const start = Date.now();
    while (Date.now() - start < 100) {} // æ¨¡æ‹Ÿ100mså»¶è¿Ÿ
    
    const user = this.users.find(u => u.id === id);
    if (!user) {
      throw new Error(`ç”¨æˆ· ${id} ä¸å­˜åœ¨`);
    }
    
    return user;
  }
  
  @logDecorator
  @requirePermission('write')
  updateUser(id, updates) {
    const user = this.getUserById(id);
    Object.assign(user, updates);
    console.log(`âœï¸ ç”¨æˆ· ${id} å·²æ›´æ–°`);
    return user;
  }
  
  @logDecorator
  @requirePermission('delete')
  deleteUser(id) {
    const index = this.users.findIndex(u => u.id === id);
    if (index === -1) {
      throw new Error(`ç”¨æˆ· ${id} ä¸å­˜åœ¨`);
    }
    
    const deletedUser = this.users.splice(index, 1)[0];
    console.log(`ğŸ—‘ï¸ ç”¨æˆ· ${id} å·²åˆ é™¤`);
    return deletedUser;
  }
  
  @retryDecorator(3, 500)
  async fetchUserFromAPI(id) {
    console.log(`ğŸŒ ä» API è·å–ç”¨æˆ· ${id}`);
    
    // æ¨¡æ‹Ÿç½‘ç»œè¯·æ±‚ï¼Œ70% çš„æ¦‚ç‡å¤±è´¥
    if (Math.random() < 0.7) {
      throw new Error('ç½‘ç»œè¯·æ±‚å¤±è´¥');
    }
    
    return {
      id,
      name: `API User ${id}`,
      source: 'api'
    };
  }
}

// å‡½æ•°å¼è£…é¥°å™¨ï¼ˆä¸ä½¿ç”¨ ES6 è£…é¥°å™¨è¯­æ³•ï¼‰
function createDecoratedFunction(originalFn, decorators) {
  return decorators.reduce((fn, decorator) => decorator(fn), originalFn);
}

// åˆ›å»ºè£…é¥°å™¨å‡½æ•°
function createLogDecorator() {
  return function(fn) {
    return function(...args) {
      console.log(`ğŸš€ è°ƒç”¨å‡½æ•°: ${fn.name}`);
      console.log(`ğŸ“¥ å‚æ•°:`, args);
      
      const result = fn.apply(this, args);
      
      console.log(`ğŸ“¤ è¿”å›å€¼:`, result);
      return result;
    };
  };
}

function createCacheDecorator(ttl = 60000) {
  const cache = new Map();
  
  return function(fn) {
    return function(...args) {
      const cacheKey = `${fn.name}:${JSON.stringify(args)}`;
      const cached = cache.get(cacheKey);
      
      if (cached && Date.now() - cached.timestamp < ttl) {
        console.log(`ğŸ’¾ ç¼“å­˜å‘½ä¸­: ${fn.name}`);
        return cached.value;
      }
      
      const result = fn.apply(this, args);
      cache.set(cacheKey, {
        value: result,
        timestamp: Date.now()
      });
      
      console.log(`ğŸ’¿ ç¼“å­˜å­˜å‚¨: ${fn.name}`);
      return result;
    };
  };
}

// ä½¿ç”¨å‡½æ•°å¼è£…é¥°å™¨
function calculateFibonacci(n) {
  if (n <= 1) return n;
  return calculateFibonacci(n - 1) + calculateFibonacci(n - 2);
}

// è£…é¥°æ–æ³¢é‚£å¥‘å‡½æ•°
const decoratedFibonacci = createDecoratedFunction(
  calculateFibonacci,
  [
    createLogDecorator(),
    createCacheDecorator(60000)
  ]
);

// ä½¿ç”¨ç¤ºä¾‹
async function decoratorDemo() {
  const userService = new UserService();
  
  console.log('=== è®¾ç½®å½“å‰ç”¨æˆ· ===');
  userService.setCurrentUser({ name: 'John', permissions: ['read', 'write'] });
  
  console.log('\n=== æµ‹è¯•ç¼“å­˜è£…é¥°å™¨ ===');
  console.log('ç¬¬ä¸€æ¬¡æŸ¥è¯¢:');
  userService.getUserById(1);
  
  console.log('\nç¬¬äºŒæ¬¡æŸ¥è¯¢ï¼ˆåº”è¯¥å‘½ä¸­ç¼“å­˜ï¼‰:');
  userService.getUserById(1);
  
  console.log('\n=== æµ‹è¯•æƒé™è£…é¥°å™¨ ===');
  try {
    userService.updateUser(1, { name: 'John Updated' });
  } catch (error) {
    console.log('âŒ æƒé™é”™è¯¯:', error.message);
  }
  
  console.log('\n=== æµ‹è¯•æƒé™ä¸è¶³ ===');
  userService.setCurrentUser({ name: 'Jane', permissions: ['read'] });
  try {
    userService.deleteUser(1);
  } catch (error) {
    console.log('âŒ æƒé™é”™è¯¯:', error.message);
  }
  
  console.log('\n=== æµ‹è¯•é‡è¯•è£…é¥°å™¨ ===');
  try {
    const apiUser = await userService.fetchUserFromAPI(999);
    console.log('âœ… API ç”¨æˆ·:', apiUser);
  } catch (error) {
    console.log('âŒ æœ€ç»ˆå¤±è´¥:', error.message);
  }
  
  console.log('\n=== æµ‹è¯•å‡½æ•°å¼è£…é¥°å™¨ ===');
  console.log('è®¡ç®—æ–æ³¢é‚£å¥‘æ•°åˆ—:');
  decoratedFibonacci(10);
  decoratedFibonacci(10); // ç¬¬äºŒæ¬¡åº”è¯¥å‘½ä¸­ç¼“å­˜
  
  console.log('\n=== æ€§èƒ½ç›‘æ§ç»“æœ ===');
  console.log(window.performanceMetrics);
}

decoratorDemo();
```

### 2.3 React é«˜é˜¶ç»„ä»¶ï¼ˆHOCï¼‰è£…é¥°å™¨

```javascript
// React ç»„ä»¶è£…é¥°å™¨ç¤ºä¾‹
import React, { useState, useEffect, useRef } from 'react';

// åŠ è½½çŠ¶æ€è£…é¥°å™¨
function withLoading(WrappedComponent) {
  return function LoadingComponent(props) {
    const [isLoading, setIsLoading] = useState(false);
    
    const enhancedProps = {
      ...props,
      isLoading,
      setLoading: setIsLoading
    };
    
    if (isLoading) {
      return (
        <div className="loading-container">
          <div className="spinner">â³ åŠ è½½ä¸­...</div>
        </div>
      );
    }
    
    return <WrappedComponent {...enhancedProps} />;
  };
}

// é”™è¯¯è¾¹ç•Œè£…é¥°å™¨
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false, error: null };
  }
  
  static getDerivedStateFromError(error) {
    return { hasError: true, error };
  }
  
  componentDidCatch(error, errorInfo) {
    console.error('ç»„ä»¶é”™è¯¯:', error, errorInfo);
  }
  
  render() {
    if (this.state.hasError) {
      return (
        <div className="error-container">
          <h3>âŒ å‡ºé”™äº†</h3>
          <p>{this.state.error?.message}</p>
          <button onClick={() => this.setState({ hasError: false, error: null })}>
            é‡è¯•
          </button>
        </div>
      );
    }
    
    return this.props.children;
  }
}

function withErrorBoundary(WrappedComponent) {
  return function ErrorBoundaryComponent(props) {
    return (
      <ErrorBoundary>
        <WrappedComponent {...props} />
      </ErrorBoundary>
    );
  };
}

// æƒé™æ§åˆ¶è£…é¥°å™¨
function withPermission(requiredPermissions) {
  return function(WrappedComponent) {
    return function PermissionComponent(props) {
      const userPermissions = props.userPermissions || [];
      
      const hasPermission = requiredPermissions.every(permission => 
        userPermissions.includes(permission)
      );
      
      if (!hasPermission) {
        return (
          <div className="permission-denied">
            <h3>ğŸ”’ æƒé™ä¸è¶³</h3>
            <p>éœ€è¦æƒé™: {requiredPermissions.join(', ')}</p>
          </div>
        );
      }
      
      return <WrappedComponent {...props} />;
    };
  };
}

// æ€§èƒ½ç›‘æ§è£…é¥°å™¨
function withPerformanceMonitor(WrappedComponent) {
  return function PerformanceComponent(props) {
    const renderCount = useRef(0);
    const mountTime = useRef(Date.now());
    
    useEffect(() => {
      renderCount.current++;
      console.log(`ğŸ“Š ${WrappedComponent.name} æ¸²æŸ“æ¬¡æ•°: ${renderCount.current}`);
    });
    
    useEffect(() => {
      const componentMountTime = Date.now() - mountTime.current;
      console.log(`â±ï¸ ${WrappedComponent.name} æŒ‚è½½æ—¶é—´: ${componentMountTime}ms`);
      
      return () => {
        const componentLifetime = Date.now() - mountTime.current;
        console.log(`ğŸ”„ ${WrappedComponent.name} ç”Ÿå‘½å‘¨æœŸ: ${componentLifetime}ms`);
      };
    }, []);
    
    return <WrappedComponent {...props} />;
  };
}

// æ•°æ®è·å–è£…é¥°å™¨
function withDataFetching(fetchFunction, dependencies = []) {
  return function(WrappedComponent) {
    return function DataFetchingComponent(props) {
      const [data, setData] = useState(null);
      const [loading, setLoading] = useState(true);
      const [error, setError] = useState(null);
      
      useEffect(() => {
        let cancelled = false;
        
        async function fetchData() {
          try {
            setLoading(true);
            setError(null);
            
            const result = await fetchFunction(props);
            
            if (!cancelled) {
              setData(result);
            }
          } catch (err) {
            if (!cancelled) {
              setError(err);
            }
          } finally {
            if (!cancelled) {
              setLoading(false);
            }
          }
        }
        
        fetchData();
        
        return () => {
          cancelled = true;
        };
      }, dependencies.map(dep => props[dep]));
      
      const enhancedProps = {
        ...props,
        data,
        loading,
        error,
        refetch: () => {
          setData(null);
          setLoading(true);
          setError(null);
        }
      };
      
      return <WrappedComponent {...enhancedProps} />;
    };
  };
}

// åŸºç¡€ç»„ä»¶
function UserList({ users, loading, error, userPermissions, setLoading }) {
  const handleRefresh = async () => {
    setLoading(true);
    // æ¨¡æ‹Ÿæ•°æ®åˆ·æ–°
    await new Promise(resolve => setTimeout(resolve, 1000));
    setLoading(false);
  };
  
  if (error) {
    return <div>âŒ é”™è¯¯: {error.message}</div>;
  }
  
  return (
    <div>
      <h2>ğŸ‘¥ ç”¨æˆ·åˆ—è¡¨</h2>
      <button onClick={handleRefresh}>ğŸ”„ åˆ·æ–°</button>
      
      {users && users.length > 0 ? (
        <ul>
          {users.map(user => (
            <li key={user.id}>
              {user.name} - {user.email}
            </li>
          ))}
        </ul>
      ) : (
        <p>æš‚æ— ç”¨æˆ·æ•°æ®</p>
      )}
    </div>
  );
}

function AdminPanel({ data, loading, error }) {
  if (loading) return <div>â³ åŠ è½½ç®¡ç†é¢æ¿...</div>;
  if (error) return <div>âŒ åŠ è½½å¤±è´¥: {error.message}</div>;
  
  return (
    <div>
      <h2>ğŸ› ï¸ ç®¡ç†é¢æ¿</h2>
      <p>ç®¡ç†å‘˜æ•°æ®: {JSON.stringify(data)}</p>
    </div>
  );
}

// åº”ç”¨è£…é¥°å™¨
const EnhancedUserList = withPerformanceMonitor(
  withErrorBoundary(
    withLoading(UserList)
  )
);

const EnhancedAdminPanel = withPerformanceMonitor(
  withErrorBoundary(
    withPermission(['admin'])(
      withDataFetching(
        async () => {
          // æ¨¡æ‹Ÿ API è°ƒç”¨
          await new Promise(resolve => setTimeout(resolve, 1000));
          return { adminData: 'secret admin info' };
        },
        []
      )(AdminPanel)
    )
  )
);

// ä½¿ç”¨ç¤ºä¾‹ç»„ä»¶
function App() {
  const [users] = useState([
    { id: 1, name: 'John', email: 'john@example.com' },
    { id: 2, name: 'Jane', email: 'jane@example.com' }
  ]);
  
  const [userPermissions] = useState(['read', 'admin']);
  
  return (
    <div>
      <h1>ğŸ¨ è£…é¥°å™¨æ¨¡å¼ç¤ºä¾‹</h1>
      
      <EnhancedUserList 
        users={users}
        userPermissions={userPermissions}
      />
      
      <EnhancedAdminPanel 
        userPermissions={userPermissions}
      />
    </div>
  );
}

export default App;
```

## ä¸‰ã€ä»£ç†æ¨¡å¼ï¼šæ™ºèƒ½çš„"ä¸­é—´äºº"

### 3.1 ä»€ä¹ˆæ˜¯ä»£ç†æ¨¡å¼ï¼Ÿ

ä»£ç†æ¨¡å¼ä¸ºå…¶ä»–å¯¹è±¡æä¾›ä¸€ç§ä»£ç†ä»¥æ§åˆ¶å¯¹è¿™ä¸ªå¯¹è±¡çš„è®¿é—®ã€‚ä»£ç†å¯¹è±¡åœ¨å®¢æˆ·ç«¯å’Œç›®æ ‡å¯¹è±¡ä¹‹é—´èµ·åˆ°ä¸­ä»‹çš„ä½œç”¨ã€‚

### 3.2 è™šæ‹Ÿä»£ç†ï¼šæ‡’åŠ è½½å’Œç¼“å­˜

```javascript
// å›¾ç‰‡æ‡’åŠ è½½ä»£ç†
class ImageProxy {
  constructor(src) {
    this.src = src;
    this.image = null;
    this.loaded = false;
    this.loading = false;
    this.observers = [];
  }
  
  // æ·»åŠ è§‚å¯Ÿè€…
  addObserver(observer) {
    this.observers.push(observer);
  }
  
  // é€šçŸ¥è§‚å¯Ÿè€…
  notifyObservers(event, data) {
    this.observers.forEach(observer => {
      if (typeof observer[event] === 'function') {
        observer[event](data);
      }
    });
  }
  
  // æ‡’åŠ è½½å›¾ç‰‡
  async load() {
    if (this.loaded || this.loading) {
      return this.image;
    }
    
    this.loading = true;
    this.notifyObservers('onLoadStart', { src: this.src });
    
    try {
      this.image = await this.loadImage();
      this.loaded = true;
      this.loading = false;
      
      this.notifyObservers('onLoadSuccess', { 
        src: this.src, 
        image: this.image 
      });
      
      return this.image;
    } catch (error) {
      this.loading = false;
      this.notifyObservers('onLoadError', { 
        src: this.src, 
        error 
      });
      throw error;
    }
  }
  
  // å®é™…åŠ è½½å›¾ç‰‡çš„æ–¹æ³•
  loadImage() {
    return new Promise((resolve, reject) => {
      const img = new Image();
      
      img.onload = () => {
        resolve({
          element: img,
          width: img.naturalWidth,
          height: img.naturalHeight,
          src: this.src
        });
      };
      
      img.onerror = () => {
        reject(new Error(`å›¾ç‰‡åŠ è½½å¤±è´¥: ${this.src}`));
      };
      
      // æ¨¡æ‹Ÿç½‘ç»œå»¶è¿Ÿ
      setTimeout(() => {
        img.src = this.src;
      }, Math.random() * 1000 + 500);
    });
  }
  
  // è·å–å›¾ç‰‡ä¿¡æ¯ï¼ˆä¸è§¦å‘åŠ è½½ï¼‰
  getInfo() {
    return {
      src: this.src,
      loaded: this.loaded,
      loading: this.loading
    };
  }
}

// å›¾ç‰‡ç®¡ç†å™¨
class ImageManager {
  constructor() {
    this.images = new Map();
    this.cache = new Map();
    this.loadingQueue = [];
    this.maxConcurrent = 3;
    this.currentLoading = 0;
  }
  
  // åˆ›å»ºå›¾ç‰‡ä»£ç†
  createImage(src) {
    if (this.images.has(src)) {
      return this.images.get(src);
    }
    
    const imageProxy = new ImageProxy(src);
    this.images.set(src, imageProxy);
    
    // æ·»åŠ ç¼“å­˜è§‚å¯Ÿè€…
    imageProxy.addObserver({
      onLoadSuccess: (data) => {
        this.cache.set(src, data.image);
        console.log(`ğŸ“¦ å›¾ç‰‡å·²ç¼“å­˜: ${src}`);
      },
      
      onLoadError: (data) => {
        console.error(`âŒ å›¾ç‰‡åŠ è½½å¤±è´¥: ${src}`, data.error);
      }
    });
    
    return imageProxy;
  }
  
  // æ‰¹é‡é¢„åŠ è½½
  async preloadImages(srcList) {
    console.log(`ğŸš€ å¼€å§‹é¢„åŠ è½½ ${srcList.length} å¼ å›¾ç‰‡`);
    
    const promises = srcList.map(src => {
      const imageProxy = this.createImage(src);
      return this.queueLoad(imageProxy);
    });
    
    try {
      const results = await Promise.allSettled(promises);
      const successful = results.filter(r => r.status === 'fulfilled').length;
      const failed = results.filter(r => r.status === 'rejected').length;
      
      console.log(`âœ… é¢„åŠ è½½å®Œæˆ: æˆåŠŸ ${successful}, å¤±è´¥ ${failed}`);
      return results;
    } catch (error) {
      console.error('âŒ é¢„åŠ è½½å¤±è´¥:', error);
      throw error;
    }
  }
  
  // é˜Ÿåˆ—åŠ è½½ï¼ˆæ§åˆ¶å¹¶å‘ï¼‰
  async queueLoad(imageProxy) {
    return new Promise((resolve, reject) => {
      this.loadingQueue.push({ imageProxy, resolve, reject });
      this.processQueue();
    });
  }
  
  // å¤„ç†åŠ è½½é˜Ÿåˆ—
  async processQueue() {
    if (this.currentLoading >= this.maxConcurrent || this.loadingQueue.length === 0) {
      return;
    }
    
    const { imageProxy, resolve, reject } = this.loadingQueue.shift();
    this.currentLoading++;
    
    try {
      const result = await imageProxy.load();
      resolve(result);
    } catch (error) {
      reject(error);
    } finally {
      this.currentLoading--;
      this.processQueue(); // å¤„ç†ä¸‹ä¸€ä¸ª
    }
  }
  
  // è·å–ç¼“å­˜çš„å›¾ç‰‡
  getCachedImage(src) {
    return this.cache.get(src);
  }
  
  // æ¸…ç†ç¼“å­˜
  clearCache() {
    this.cache.clear();
    console.log('ğŸ§¹ å›¾ç‰‡ç¼“å­˜å·²æ¸…ç†');
  }
  
  // è·å–ç»Ÿè®¡ä¿¡æ¯
  getStats() {
    return {
      totalImages: this.images.size,
      cachedImages: this.cache.size,
      loadingQueue: this.loadingQueue.length,
      currentLoading: this.currentLoading
    };
  }
}

// API ä»£ç†ï¼šç¼“å­˜å’Œé‡è¯•
class APIProxy {
  constructor(baseURL, options = {}) {
    this.baseURL = baseURL;
    this.cache = new Map();
    this.options = {
      timeout: 10000,
      retries: 3,
      retryDelay: 1000,
      cacheTimeout: 300000, // 5åˆ†é’Ÿ
      ...options
    };
  }
  
  // å‘èµ·è¯·æ±‚
  async request(endpoint, options = {}) {
    const url = `${this.baseURL}${endpoint}`;
    const cacheKey = this.generateCacheKey(url, options);
    
    // æ£€æŸ¥ç¼“å­˜
    if (this.shouldUseCache(options) && this.cache.has(cacheKey)) {
      const cached = this.cache.get(cacheKey);
      if (Date.now() - cached.timestamp < this.options.cacheTimeout) {
        console.log(`ğŸ’¾ API ç¼“å­˜å‘½ä¸­: ${endpoint}`);
        return cached.data;
      } else {
        this.cache.delete(cacheKey);
      }
    }
    
    // å‘èµ·è¯·æ±‚ï¼ˆå¸¦é‡è¯•ï¼‰
    const data = await this.requestWithRetry(url, options);
    
    // ç¼“å­˜å“åº”
    if (this.shouldUseCache(options)) {
      this.cache.set(cacheKey, {
        data,
        timestamp: Date.now()
      });
      console.log(`ğŸ’¿ API å“åº”å·²ç¼“å­˜: ${endpoint}`);
    }
    
    return data;
  }
  
  // å¸¦é‡è¯•çš„è¯·æ±‚
  async requestWithRetry(url, options) {
    let lastError;
    
    for (let attempt = 1; attempt <= this.options.retries; attempt++) {
      try {
        console.log(`ğŸŒ API è¯·æ±‚ (å°è¯• ${attempt}): ${url}`);
        
        const controller = new AbortController();
        const timeoutId = setTimeout(() => {
          controller.abort();
        }, this.options.timeout);
        
        const response = await fetch(url, {
          ...options,
          signal: controller.signal
        });
        
        clearTimeout(timeoutId);
        
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const data = await response.json();
        console.log(`âœ… API è¯·æ±‚æˆåŠŸ: ${url}`);
        return data;
        
      } catch (error) {
        lastError = error;
        console.log(`âŒ API è¯·æ±‚å¤±è´¥ (å°è¯• ${attempt}): ${error.message}`);
        
        if (attempt < this.options.retries) {
          const delay = this.options.retryDelay * Math.pow(2, attempt - 1); // æŒ‡æ•°é€€é¿
          console.log(`â³ ç­‰å¾… ${delay}ms åé‡è¯•...`);
          await new Promise(resolve => setTimeout(resolve, delay));
        }
      }
    }
    
    console.log(`ğŸ’¥ æ‰€æœ‰é‡è¯•éƒ½å¤±è´¥äº†: ${url}`);
    throw lastError;
  }
  
  // ç”Ÿæˆç¼“å­˜é”®
  generateCacheKey(url, options) {
    const key = {
      url,
      method: options.method || 'GET',
      body: options.body,
      headers: options.headers
    };
    return JSON.stringify(key);
  }
  
  // æ˜¯å¦åº”è¯¥ä½¿ç”¨ç¼“å­˜
  shouldUseCache(options) {
    return options.method !== 'POST' && 
           options.method !== 'PUT' && 
           options.method !== 'DELETE' &&
           options.cache !== false;
  }
  
  // æ¸…ç†è¿‡æœŸç¼“å­˜
  cleanupCache() {
    const now = Date.now();
    let cleaned = 0;
    
    for (const [key, value] of this.cache) {
      if (now - value.timestamp > this.options.cacheTimeout) {
        this.cache.delete(key);
        cleaned++;
      }
    }
    
    console.log(`ğŸ§¹ æ¸…ç†äº† ${cleaned} ä¸ªè¿‡æœŸç¼“å­˜`);
  }
  
  // è·å–ç¼“å­˜ç»Ÿè®¡
  getCacheStats() {
    return {
      size: this.cache.size,
      entries: Array.from(this.cache.entries()).map(([key, value]) => ({
        key: JSON.parse(key).url,
        age: Date.now() - value.timestamp
      }))
    };
  }
}

// ä½¿ç”¨ç¤ºä¾‹
async function proxyDemo() {
  console.log('=== å›¾ç‰‡ä»£ç†ç¤ºä¾‹ ===');
  const imageManager = new ImageManager();
  
  // æ¨¡æ‹Ÿå›¾ç‰‡ URL
  const imageUrls = [
    'https://picsum.photos/200/300?random=1',
    'https://picsum.photos/200/300?random=2',
    'https://picsum.photos/200/300?random=3',
    'https://picsum.photos/200/300?random=4',
    'https://picsum.photos/200/300?random=5'
  ];
  
  // åˆ›å»ºå›¾ç‰‡ä»£ç†
  const imageProxies = imageUrls.map(url => imageManager.createImage(url));
  
  console.log('ğŸ“Š åˆå§‹ç»Ÿè®¡:', imageManager.getStats());
  
  // é¢„åŠ è½½å›¾ç‰‡
  await imageManager.preloadImages(imageUrls.slice(0, 3));
  
  console.log('ğŸ“Š é¢„åŠ è½½åç»Ÿè®¡:', imageManager.getStats());
  
  console.log('\n=== API ä»£ç†ç¤ºä¾‹ ===');
  const apiProxy = new APIProxy('https://jsonplaceholder.typicode.com', {
    retries: 2,
    retryDelay: 500,
    cacheTimeout: 10000 // 10ç§’ç¼“å­˜
  });
  
  try {
    // ç¬¬ä¸€æ¬¡è¯·æ±‚
    console.log('ç¬¬ä¸€æ¬¡è¯·æ±‚ç”¨æˆ·æ•°æ®:');
    const users1 = await apiProxy.request('/users');
    console.log(`è·å–åˆ° ${users1.length} ä¸ªç”¨æˆ·`);
    
    // ç¬¬äºŒæ¬¡è¯·æ±‚ï¼ˆåº”è¯¥å‘½ä¸­ç¼“å­˜ï¼‰
    console.log('\nç¬¬äºŒæ¬¡è¯·æ±‚ç”¨æˆ·æ•°æ®:');
    const users2 = await apiProxy.request('/users');
    console.log(`è·å–åˆ° ${users2.length} ä¸ªç”¨æˆ·`);
    
    console.log('\nğŸ“Š API ç¼“å­˜ç»Ÿè®¡:', apiProxy.getCacheStats());
    
  } catch (error) {
    console.error('API è¯·æ±‚å¤±è´¥:', error.message);
  }
}

proxyDemo();
```

## å››ã€å¤–è§‚æ¨¡å¼ï¼šç®€åŒ–å¤æ‚æ¥å£

### 4.1 ä»€ä¹ˆæ˜¯å¤–è§‚æ¨¡å¼ï¼Ÿ

å¤–è§‚æ¨¡å¼ä¸ºå­ç³»ç»Ÿä¸­çš„ä¸€ç»„æ¥å£æä¾›ä¸€ä¸ªä¸€è‡´çš„ç•Œé¢ï¼Œå®šä¹‰ä¸€ä¸ªé«˜å±‚æ¥å£ï¼Œè¿™ä¸ªæ¥å£ä½¿å¾—è¿™ä¸€å­ç³»ç»Ÿæ›´åŠ å®¹æ˜“ä½¿ç”¨ã€‚

### 4.2 æµè§ˆå™¨å…¼å®¹æ€§å¤–è§‚

```javascript
// æµè§ˆå™¨å…¼å®¹æ€§å¤–è§‚
class BrowserFacade {
  // äº‹ä»¶ç›‘å¬å™¨å¤–è§‚
  static addEventListener(element, event, handler, options = false) {
    if (element.addEventListener) {
      element.addEventListener(event, handler, options);
    } else if (element.attachEvent) {
      // IE8 åŠä»¥ä¸‹ç‰ˆæœ¬
      element.attachEvent(`on${event}`, handler);
    } else {
      // æœ€å¤è€çš„æ–¹å¼
      element[`on${event}`] = handler;
    }
  }
  
  static removeEventListener(element, event, handler, options = false) {
    if (element.removeEventListener) {
      element.removeEventListener(event, handler, options);
    } else if (element.detachEvent) {
      element.detachEvent(`on${event}`, handler);
    } else {
      element[`on${event}`] = null;
    }
  }
  
  // AJAX è¯·æ±‚å¤–è§‚
  static async request(options) {
    const {
      url,
      method = 'GET',
      data = null,
      headers = {},
      timeout = 10000
    } = options;
    
    // ç°ä»£æµè§ˆå™¨ä½¿ç”¨ fetch
    if (typeof fetch !== 'undefined') {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), timeout);
      
      try {
        const response = await fetch(url, {
          method,
          headers,
          body: data ? JSON.stringify(data) : null,
          signal: controller.signal
        });
        
        clearTimeout(timeoutId);
        
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        return await response.json();
      } catch (error) {
        clearTimeout(timeoutId);
        throw error;
      }
    }
    
    // é™çº§åˆ° XMLHttpRequest
    return new Promise((resolve, reject) => {
      const xhr = new XMLHttpRequest();
      
      xhr.open(method, url, true);
      xhr.timeout = timeout;
      
      // è®¾ç½®è¯·æ±‚å¤´
      Object.keys(headers).forEach(key => {
        xhr.setRequestHeader(key, headers[key]);
      });
      
      xhr.onreadystatechange = function() {
        if (xhr.readyState === 4) {
          if (xhr.status >= 200 && xhr.status < 300) {
            try {
              resolve(JSON.parse(xhr.responseText));
            } catch (error) {
              resolve(xhr.responseText);
            }
          } else {
            reject(new Error(`HTTP ${xhr.status}: ${xhr.statusText}`));
          }
        }
      };
      
      xhr.onerror = () => reject(new Error('ç½‘ç»œé”™è¯¯'));
      xhr.ontimeout = () => reject(new Error('è¯·æ±‚è¶…æ—¶'));
      
      xhr.send(data ? JSON.stringify(data) : null);
    });
  }
  
  // æœ¬åœ°å­˜å‚¨å¤–è§‚
  static setStorage(key, value, type = 'localStorage') {
    try {
      const storage = type === 'sessionStorage' ? sessionStorage : localStorage;
      
      if (storage) {
        storage.setItem(key, JSON.stringify(value));
        return true;
      }
    } catch (error) {
      console.warn('å­˜å‚¨å¤±è´¥ï¼Œé™çº§åˆ° cookie:', error);
    }
    
    // é™çº§åˆ° cookie
    this.setCookie(key, JSON.stringify(value));
    return true;
  }
  
  static getStorage(key, type = 'localStorage') {
    try {
      const storage = type === 'sessionStorage' ? sessionStorage : localStorage;
      
      if (storage) {
        const value = storage.getItem(key);
        return value ? JSON.parse(value) : null;
      }
    } catch (error) {
      console.warn('è¯»å–å­˜å‚¨å¤±è´¥ï¼Œé™çº§åˆ° cookie:', error);
    }
    
    // é™çº§åˆ° cookie
    const cookieValue = this.getCookie(key);
    return cookieValue ? JSON.parse(cookieValue) : null;
  }
  
  static removeStorage(key, type = 'localStorage') {
    try {
      const storage = type === 'sessionStorage' ? sessionStorage : localStorage;
      
      if (storage) {
        storage.removeItem(key);
        return;
      }
    } catch (error) {
      console.warn('åˆ é™¤å­˜å‚¨å¤±è´¥ï¼Œé™çº§åˆ° cookie:', error);
    }
    
    // é™çº§åˆ° cookie
    this.setCookie(key, '', -1);
  }
  
  // Cookie æ“ä½œè¾…åŠ©æ–¹æ³•
  static setCookie(name, value, days = 30) {
    const expires = new Date();
    expires.setTime(expires.getTime() + (days * 24 * 60 * 60 * 1000));
    document.cookie = `${name}=${value};expires=${expires.toUTCString()};path=/`;
  }
  
  static getCookie(name) {
    const nameEQ = name + '=';
    const ca = document.cookie.split(';');
    
    for (let i = 0; i < ca.length; i++) {
      let c = ca[i];
      while (c.charAt(0) === ' ') c = c.substring(1, c.length);
      if (c.indexOf(nameEQ) === 0) return c.substring(nameEQ.length, c.length);
    }
    
    return null;
  }
  
  // åŠ¨ç”»å¤–è§‚
  static animate(element, properties, duration = 300, easing = 'ease') {
    // ç°ä»£æµè§ˆå™¨ä½¿ç”¨ Web Animations API
    if (element.animate) {
      return element.animate(properties, {
        duration,
        easing,
        fill: 'forwards'
      });
    }
    
    // é™çº§åˆ° CSS Transitions
    return new Promise((resolve) => {
      const originalTransition = element.style.transition;
      element.style.transition = `all ${duration}ms ${easing}`;
      
      // åº”ç”¨æ ·å¼
      Object.keys(properties[1] || properties).forEach(prop => {
        element.style[prop] = properties[1] ? properties[1][prop] : properties[prop];
      });
      
      setTimeout(() => {
        element.style.transition = originalTransition;
        resolve();
      }, duration);
    });
  }
  
  // å…¨å± API å¤–è§‚
  static requestFullscreen(element = document.documentElement) {
    if (element.requestFullscreen) {
      return element.requestFullscreen();
    } else if (element.mozRequestFullScreen) {
      return element.mozRequestFullScreen();
    } else if (element.webkitRequestFullscreen) {
      return element.webkitRequestFullscreen();
    } else if (element.msRequestFullscreen) {
      return element.msRequestFullscreen();
    }
    
    throw new Error('æµè§ˆå™¨ä¸æ”¯æŒå…¨å± API');
  }
  
  static exitFullscreen() {
    if (document.exitFullscreen) {
      return document.exitFullscreen();
    } else if (document.mozCancelFullScreen) {
      return document.mozCancelFullScreen();
    } else if (document.webkitExitFullscreen) {
      return document.webkitExitFullscreen();
    } else if (document.msExitFullscreen) {
      return document.msExitFullscreen();
    }
    
    throw new Error('æµè§ˆå™¨ä¸æ”¯æŒé€€å‡ºå…¨å± API');
  }
  
  static isFullscreen() {
    return !!(document.fullscreenElement ||
             document.mozFullScreenElement ||
             document.webkitFullscreenElement ||
             document.msFullscreenElement);
  }
}

// å¤æ‚è¡¨å•å¤„ç†å¤–è§‚
class FormFacade {
  constructor(formElement) {
    this.form = formElement;
    this.validators = new Map();
    this.formatters = new Map();
    this.errors = new Map();
    this.setupEventListeners();
  }
  
  // è®¾ç½®äº‹ä»¶ç›‘å¬
  setupEventListeners() {
    BrowserFacade.addEventListener(this.form, 'submit', (e) => {
      e.preventDefault();
      this.handleSubmit();
    });
    
    // å®æ—¶éªŒè¯
    const inputs = this.form.querySelectorAll('input, select, textarea');
    inputs.forEach(input => {
      BrowserFacade.addEventListener(input, 'blur', () => {
        this.validateField(input.name);
      });
      
      BrowserFacade.addEventListener(input, 'input', () => {
        this.formatField(input.name);
        this.clearError(input.name);
      });
    });
  }
  
  // æ·»åŠ éªŒè¯å™¨
  addValidator(fieldName, validator) {
    if (!this.validators.has(fieldName)) {
      this.validators.set(fieldName, []);
    }
    this.validators.get(fieldName).push(validator);
    return this;
  }
  
  // æ·»åŠ æ ¼å¼åŒ–å™¨
  addFormatter(fieldName, formatter) {
    this.formatters.set(fieldName, formatter);
    return this;
  }
  
  // éªŒè¯å•ä¸ªå­—æ®µ
  validateField(fieldName) {
    const field = this.form.querySelector(`[name="${fieldName}"]`);
    if (!field) return true;
    
    const validators = this.validators.get(fieldName) || [];
    
    for (const validator of validators) {
      const result = validator(field.value, this.getFormData());
      if (result !== true) {
        this.setError(fieldName, result);
        return false;
      }
    }
    
    this.clearError(fieldName);
    return true;
  }
  
  // æ ¼å¼åŒ–å­—æ®µ
  formatField(fieldName) {
    const field = this.form.querySelector(`[name="${fieldName}"]`);
    const formatter = this.formatters.get(fieldName);
    
    if (field && formatter) {
      const cursorPosition = field.selectionStart;
      const oldValue = field.value;
      const newValue = formatter(field.value);
      
      if (oldValue !== newValue) {
        field.value = newValue;
        // å°è¯•ä¿æŒå…‰æ ‡ä½ç½®
        const offset = newValue.length - oldValue.length;
        field.setSelectionRange(cursorPosition + offset, cursorPosition + offset);
      }
    }
  }
  
  // è®¾ç½®é”™è¯¯
  setError(fieldName, message) {
    this.errors.set(fieldName, message);
    
    const field = this.form.querySelector(`[name="${fieldName}"]`);
    const errorElement = this.form.querySelector(`[data-error="${fieldName}"]`);
    
    if (field) {
      field.classList.add('error');
    }
    
    if (errorElement) {
      errorElement.textContent = message;
      errorElement.style.display = 'block';
    }
  }
  
  // æ¸…é™¤é”™è¯¯
  clearError(fieldName) {
    this.errors.delete(fieldName);
    
    const field = this.form.querySelector(`[name="${fieldName}"]`);
    const errorElement = this.form.querySelector(`[data-error="${fieldName}"]`);
    
    if (field) {
      field.classList.remove('error');
    }
    
    if (errorElement) {
      errorElement.textContent = '';
      errorElement.style.display = 'none';
    }
  }
  
  // éªŒè¯æ•´ä¸ªè¡¨å•
  validate() {
    let isValid = true;
    const fields = this.form.querySelectorAll('[name]');
    
    fields.forEach(field => {
      if (!this.validateField(field.name)) {
        isValid = false;
      }
    });
    
    return isValid;
  }
  
  // è·å–è¡¨å•æ•°æ®
  getFormData() {
    const formData = new FormData(this.form);
    const data = {};
    
    for (const [key, value] of formData.entries()) {
      if (data[key]) {
        // å¤„ç†å¤šé€‰
        if (Array.isArray(data[key])) {
          data[key].push(value);
        } else {
          data[key] = [data[key], value];
        }
      } else {
        data[key] = value;
      }
    }
    
    return data;
  }
  
  // è®¾ç½®è¡¨å•æ•°æ®
  setFormData(data) {
    Object.keys(data).forEach(key => {
      const field = this.form.querySelector(`[name="${key}"]`);
      if (field) {
        if (field.type === 'checkbox' || field.type === 'radio') {
          field.checked = field.value === data[key] || 
                         (Array.isArray(data[key]) && data[key].includes(field.value));
        } else {
          field.value = data[key];
        }
      }
    });
  }
  
  // å¤„ç†è¡¨å•æäº¤
  async handleSubmit() {
    if (!this.validate()) {
      console.log('âŒ è¡¨å•éªŒè¯å¤±è´¥');
      return;
    }
    
    const formData = this.getFormData();
    console.log('âœ… è¡¨å•éªŒè¯é€šè¿‡ï¼Œæäº¤æ•°æ®:', formData);
    
    try {
      // è¿™é‡Œå¯ä»¥è°ƒç”¨ API
      await this.submitForm(formData);
      this.showSuccess('è¡¨å•æäº¤æˆåŠŸï¼');
    } catch (error) {
      this.showError(`æäº¤å¤±è´¥: ${error.message}`);
    }
  }
  
  // æäº¤è¡¨å•ï¼ˆå¯ä»¥è¢«é‡å†™ï¼‰
  async submitForm(data) {
    // æ¨¡æ‹Ÿ API è°ƒç”¨
    await new Promise(resolve => setTimeout(resolve, 1000));
    console.log('ğŸ“¤ è¡¨å•å·²æäº¤:', data);
  }
  
  // æ˜¾ç¤ºæˆåŠŸæ¶ˆæ¯
  showSuccess(message) {
    console.log('âœ…', message);
    // è¿™é‡Œå¯ä»¥æ˜¾ç¤ºæˆåŠŸæç¤º
  }
  
  // æ˜¾ç¤ºé”™è¯¯æ¶ˆæ¯
  showError(message) {
    console.error('âŒ', message);
    // è¿™é‡Œå¯ä»¥æ˜¾ç¤ºé”™è¯¯æç¤º
  }
}

// å¸¸ç”¨éªŒè¯å™¨
const Validators = {
  required: (value) => {
    return value.trim() !== '' || 'æ­¤å­—æ®µä¸ºå¿…å¡«é¡¹';
  },
  
  email: (value) => {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex.test(value) || 'è¯·è¾“å…¥æœ‰æ•ˆçš„é‚®ç®±åœ°å€';
  },
  
  minLength: (min) => (value) => {
    return value.length >= min || `æœ€å°‘éœ€è¦ ${min} ä¸ªå­—ç¬¦`;
  },
  
  maxLength: (max) => (value) => {
    return value.length <= max || `æœ€å¤šå…è®¸ ${max} ä¸ªå­—ç¬¦`;
  },
  
  phone: (value) => {
    const phoneRegex = /^1[3-9]\d{9}$/;
    return phoneRegex.test(value) || 'è¯·è¾“å…¥æœ‰æ•ˆçš„æ‰‹æœºå·ç ';
  },
  
  password: (value) => {
    const hasUpper = /[A-Z]/.test(value);
    const hasLower = /[a-z]/.test(value);
    const hasNumber = /\d/.test(value);
    const hasSpecial = /[!@#$%^&*(),.?":{}|<>]/.test(value);
    
    if (value.length < 8) {
      return 'å¯†ç è‡³å°‘éœ€è¦8ä¸ªå­—ç¬¦';
    }
    
    if (!(hasUpper && hasLower && hasNumber)) {
      return 'å¯†ç å¿…é¡»åŒ…å«å¤§å†™å­—æ¯ã€å°å†™å­—æ¯å’Œæ•°å­—';
    }
    
    return true;
  },
  
  confirmPassword: (passwordFieldName) => (value, formData) => {
    return value === formData[passwordFieldName] || 'ä¸¤æ¬¡è¾“å…¥çš„å¯†ç ä¸ä¸€è‡´';
  }
};

// å¸¸ç”¨æ ¼å¼åŒ–å™¨
const Formatters = {
  phone: (value) => {
    // æ ¼å¼åŒ–ä¸º xxx-xxxx-xxxx
    const numbers = value.replace(/\D/g, '');
    if (numbers.length <= 3) return numbers;
    if (numbers.length <= 7) return `${numbers.slice(0, 3)}-${numbers.slice(3)}`;
    return `${numbers.slice(0, 3)}-${numbers.slice(3, 7)}-${numbers.slice(7, 11)}`;
  },
  
  currency: (value) => {
    // æ ¼å¼åŒ–ä¸ºè´§å¸æ ¼å¼
    const numbers = value.replace(/[^\d.]/g, '');
    const parts = numbers.split('.');
    parts[0] = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, ',');
    return parts.length > 1 ? `${parts[0]}.${parts[1].slice(0, 2)}` : parts[0];
  },
  
  uppercase: (value) => value.toUpperCase(),
  
  lowercase: (value) => value.toLowerCase(),
  
  removeSpaces: (value) => value.replace(/\s/g, '')
};

// ä½¿ç”¨ç¤ºä¾‹
function facadeDemo() {
  console.log('=== æµè§ˆå™¨å…¼å®¹æ€§å¤–è§‚ç¤ºä¾‹ ===');
  
  // å­˜å‚¨ç¤ºä¾‹
  BrowserFacade.setStorage('user', { name: 'John', age: 30 });
  const user = BrowserFacade.getStorage('user');
  console.log('å­˜å‚¨çš„ç”¨æˆ·æ•°æ®:', user);
  
  // åŠ¨ç”»ç¤ºä¾‹
  const testElement = document.createElement('div');
  testElement.style.width = '100px';
  testElement.style.height = '100px';
  testElement.style.backgroundColor = 'red';
  document.body.appendChild(testElement);
  
  BrowserFacade.animate(testElement, {
    transform: 'translateX(200px)',
    backgroundColor: 'blue'
  }, 1000);
  
  console.log('\n=== è¡¨å•å¤–è§‚ç¤ºä¾‹ ===');
  
  // åˆ›å»ºç¤ºä¾‹è¡¨å•
  const form = document.createElement('form');
  form.innerHTML = `
    <input name="email" type="email" placeholder="é‚®ç®±" />
    <div data-error="email"></div>
    
    <input name="phone" type="tel" placeholder="æ‰‹æœºå·" />
    <div data-error="phone"></div>
    
    <input name="password" type="password" placeholder="å¯†ç " />
    <div data-error="password"></div>
    
    <input name="confirmPassword" type="password" placeholder="ç¡®è®¤å¯†ç " />
    <div data-error="confirmPassword"></div>
    
    <button type="submit">æäº¤</button>
  `;
  
  document.body.appendChild(form);
  
  // åˆ›å»ºè¡¨å•å¤–è§‚
  const formFacade = new FormFacade(form)
    .addValidator('email', Validators.required)
    .addValidator('email', Validators.email)
    .addValidator('phone', Validators.required)
    .addValidator('phone', Validators.phone)
    .addValidator('password', Validators.required)
    .addValidator('password', Validators.password)
    .addValidator('confirmPassword', Validators.required)
    .addValidator('confirmPassword', Validators.confirmPassword('password'))
    .addFormatter('phone', Formatters.phone);
  
  console.log('âœ… è¡¨å•å¤–è§‚å·²è®¾ç½®å®Œæˆ');
}

// å¦‚æœåœ¨æµè§ˆå™¨ç¯å¢ƒä¸­è¿è¡Œ
if (typeof document !== 'undefined') {
  facadeDemo();
}
```

## äº”ã€ç»„åˆæ¨¡å¼ï¼šæ ‘å½¢ç»“æ„çš„ç»Ÿä¸€å¤„ç†

### 5.1 ä»€ä¹ˆæ˜¯ç»„åˆæ¨¡å¼ï¼Ÿ

ç»„åˆæ¨¡å¼å°†å¯¹è±¡ç»„åˆæˆæ ‘å½¢ç»“æ„ä»¥è¡¨ç¤º"éƒ¨åˆ†-æ•´ä½“"çš„å±‚æ¬¡ç»“æ„ï¼Œä½¿å¾—ç”¨æˆ·å¯¹å•ä¸ªå¯¹è±¡å’Œç»„åˆå¯¹è±¡çš„ä½¿ç”¨å…·æœ‰ä¸€è‡´æ€§ã€‚

### 5.2 æ–‡ä»¶ç³»ç»Ÿç»„åˆ

```javascript
// æ–‡ä»¶ç³»ç»Ÿç»„åˆæ¨¡å¼
class FileSystemComponent {
  constructor(name) {
    this.name = name;
    this.parent = null;
  }
  
  // æŠ½è±¡æ–¹æ³•ï¼Œå­ç±»å¿…é¡»å®ç°
  getSize() {
    throw new Error('getSize() æ–¹æ³•å¿…é¡»è¢«å®ç°');
  }
  
  getPath() {
    if (this.parent) {
      return `${this.parent.getPath()}/${this.name}`;
    }
    return this.name;
  }
  
  // é»˜è®¤å®ç°ï¼Œå¶å­èŠ‚ç‚¹ä¸æ”¯æŒè¿™äº›æ“ä½œ
  add(component) {
    throw new Error('ä¸æ”¯æŒæ·»åŠ æ“ä½œ');
  }
  
  remove(component) {
    throw new Error('ä¸æ”¯æŒåˆ é™¤æ“ä½œ');
  }
  
  getChild(index) {
    throw new Error('ä¸æ”¯æŒè·å–å­èŠ‚ç‚¹æ“ä½œ');
  }
  
  getChildren() {
    throw new Error('ä¸æ”¯æŒè·å–å­èŠ‚ç‚¹åˆ—è¡¨æ“ä½œ');
  }
  
  isComposite() {
    return false;
  }
}

// æ–‡ä»¶ï¼ˆå¶å­èŠ‚ç‚¹ï¼‰
class File extends FileSystemComponent {
  constructor(name, size, content = '') {
    super(name);
    this.size = size;
    this.content = content;
    this.type = 'file';
    this.createdAt = new Date();
    this.modifiedAt = new Date();
  }
  
  getSize() {
    return this.size;
  }
  
  getContent() {
    return this.content;
  }
  
  setContent(content) {
    this.content = content;
    this.size = new Blob([content]).size;
    this.modifiedAt = new Date();
  }
  
  getInfo() {
    return {
      name: this.name,
      type: this.type,
      size: this.size,
      path: this.getPath(),
      createdAt: this.createdAt,
      modifiedAt: this.modifiedAt
    };
  }
  
  copy() {
    const newFile = new File(this.name, this.size, this.content);
    newFile.createdAt = this.createdAt;
    newFile.modifiedAt = this.modifiedAt;
    return newFile;
  }
}

// ç›®å½•ï¼ˆç»„åˆèŠ‚ç‚¹ï¼‰
class Directory extends FileSystemComponent {
  constructor(name) {
    super(name);
    this.children = new Map();
    this.type = 'directory';
    this.createdAt = new Date();
    this.modifiedAt = new Date();
  }
  
  add(component) {
    if (this.children.has(component.name)) {
      throw new Error(`æ–‡ä»¶æˆ–ç›®å½• "${component.name}" å·²å­˜åœ¨`);
    }
    
    this.children.set(component.name, component);
    component.parent = this;
    this.modifiedAt = new Date();
    return this;
  }
  
  remove(componentName) {
    const component = this.children.get(componentName);
    if (component) {
      this.children.delete(componentName);
      component.parent = null;
      this.modifiedAt = new Date();
      return component;
    }
    throw new Error(`æ–‡ä»¶æˆ–ç›®å½• "${componentName}" ä¸å­˜åœ¨`);
  }
  
  getChild(name) {
    return this.children.get(name) || null;
  }
  
  getChildren() {
    return Array.from(this.children.values());
  }
  
  getSize() {
    let totalSize = 0;
    for (const child of this.children.values()) {
      totalSize += child.getSize();
    }
    return totalSize;
  }
  
  isComposite() {
    return true;
  }
  
  // æŸ¥æ‰¾æ–‡ä»¶æˆ–ç›®å½•
  find(name, recursive = false) {
    // ç›´æ¥å­èŠ‚ç‚¹æŸ¥æ‰¾
    if (this.children.has(name)) {
      return this.children.get(name);
    }
    
    // é€’å½’æŸ¥æ‰¾
    if (recursive) {
      for (const child of this.children.values()) {
        if (child.isComposite()) {
          const found = child.find(name, true);
          if (found) return found;
        }
      }
    }
    
    return null;
  }
  
  // åˆ—å‡ºæ‰€æœ‰æ–‡ä»¶
  listFiles(recursive = false) {
    const files = [];
    
    for (const child of this.children.values()) {
      if (child.type === 'file') {
        files.push(child);
      } else if (recursive && child.isComposite()) {
        files.push(...child.listFiles(true));
      }
    }
    
    return files;
  }
  
  // è·å–ç›®å½•æ ‘ç»“æ„
  getTree(depth = 0, maxDepth = 10) {
    if (depth > maxDepth) {
      return `${'  '.repeat(depth)}[ç›®å½•å±‚çº§è¿‡æ·±ï¼Œå·²æˆªæ–­]`;
    }
    
    let tree = `${'  '.repeat(depth)}ğŸ“ ${this.name}/\n`;
    
    const children = Array.from(this.children.values())
      .sort((a, b) => {
        // ç›®å½•ä¼˜å…ˆï¼Œç„¶åæŒ‰åç§°æ’åº
        if (a.type !== b.type) {
          return a.type === 'directory' ? -1 : 1;
        }
        return a.name.localeCompare(b.name);
      });
    
    for (const child of children) {
      if (child.type === 'directory') {
        tree += child.getTree(depth + 1, maxDepth);
      } else {
        tree += `${'  '.repeat(depth + 1)}ğŸ“„ ${child.name} (${this.formatSize(child.getSize())})\n`;
      }
    }
    
    return tree;
  }
  
  // æ ¼å¼åŒ–æ–‡ä»¶å¤§å°
  formatSize(bytes) {
    const units = ['B', 'KB', 'MB', 'GB', 'TB'];
    let size = bytes;
    let unitIndex = 0;
    
    while (size >= 1024 && unitIndex < units.length - 1) {
      size /= 1024;
      unitIndex++;
    }
    
    return `${size.toFixed(1)} ${units[unitIndex]}`;
  }
  
  // è·å–ç›®å½•ä¿¡æ¯
  getInfo() {
    const children = this.getChildren();
    const files = children.filter(child => child.type === 'file');
    const directories = children.filter(child => child.type === 'directory');
    
    return {
      name: this.name,
      type: this.type,
      path: this.getPath(),
      size: this.getSize(),
      formattedSize: this.formatSize(this.getSize()),
      childCount: children.length,
      fileCount: files.length,
      directoryCount: directories.length,
      createdAt: this.createdAt,
      modifiedAt: this.modifiedAt
    };
  }
  
  // å¤åˆ¶ç›®å½•
  copy() {
    const newDir = new Directory(this.name);
    newDir.createdAt = this.createdAt;
    newDir.modifiedAt = this.modifiedAt;
    
    for (const child of this.children.values()) {
      newDir.add(child.copy());
    }
    
    return newDir;
  }
  
  // ç§»åŠ¨æ–‡ä»¶æˆ–ç›®å½•
  move(componentName, targetDirectory) {
    const component = this.remove(componentName);
    targetDirectory.add(component);
    return component;
  }
  
  // é‡å‘½å
  rename(oldName, newName) {
    const component = this.children.get(oldName);
    if (!component) {
      throw new Error(`æ–‡ä»¶æˆ–ç›®å½• "${oldName}" ä¸å­˜åœ¨`);
    }
    
    if (this.children.has(newName)) {
      throw new Error(`æ–‡ä»¶æˆ–ç›®å½• "${newName}" å·²å­˜åœ¨`);
    }
    
    this.children.delete(oldName);
    component.name = newName;
    this.children.set(newName, component);
    this.modifiedAt = new Date();
    
    return component;
  }
}

// æ–‡ä»¶ç³»ç»Ÿç®¡ç†å™¨
class FileSystemManager {
  constructor() {
    this.root = new Directory('root');
    this.currentDirectory = this.root;
    this.history = [];
  }
  
  // åˆ›å»ºæ–‡ä»¶
  createFile(name, content = '', directory = this.currentDirectory) {
    const size = new Blob([content]).size;
    const file = new File(name, size, content);
    directory.add(file);
    return file;
  }
  
  // åˆ›å»ºç›®å½•
  createDirectory(name, directory = this.currentDirectory) {
    const dir = new Directory(name);
    directory.add(dir);
    return dir;
  }
  
  // åˆ‡æ¢ç›®å½•
  changeDirectory(path) {
    this.history.push(this.currentDirectory);
    
    if (path === '/') {
      this.currentDirectory = this.root;
      return this.currentDirectory;
    }
    
    if (path === '..') {
      if (this.currentDirectory.parent) {
        this.currentDirectory = this.currentDirectory.parent;
      }
      return this.currentDirectory;
    }
    
    if (path.startsWith('/')) {
      // ç»å¯¹è·¯å¾„
      const parts = path.split('/').filter(part => part);
      let current = this.root;
      
      for (const part of parts) {
        const child = current.getChild(part);
        if (!child || child.type !== 'directory') {
          throw new Error(`ç›®å½• "${path}" ä¸å­˜åœ¨`);
        }
        current = child;
      }
      
      this.currentDirectory = current;
    } else {
      // ç›¸å¯¹è·¯å¾„
      const child = this.currentDirectory.getChild(path);
      if (!child || child.type !== 'directory') {
        throw new Error(`ç›®å½• "${path}" ä¸å­˜åœ¨`);
      }
      this.currentDirectory = child;
    }
    
    return this.currentDirectory;
  }
  
  // è¿”å›ä¸Šä¸€ä¸ªç›®å½•
  back() {
    if (this.history.length > 0) {
      this.currentDirectory = this.history.pop();
    }
    return this.currentDirectory;
  }
  
  // è·å–å½“å‰è·¯å¾„
  getCurrentPath() {
    return this.currentDirectory.getPath();
  }
  
  // åˆ—å‡ºå½“å‰ç›®å½•å†…å®¹
  list() {
    return this.currentDirectory.getChildren();
  }
  
  // æœç´¢æ–‡ä»¶
  search(pattern, directory = this.root) {
    const results = [];
    const regex = new RegExp(pattern, 'i');
    
    function searchRecursive(dir) {
      for (const child of dir.getChildren()) {
        if (regex.test(child.name)) {
          results.push(child);
        }
        
        if (child.isComposite()) {
          searchRecursive(child);
        }
      }
    }
    
    searchRecursive(directory);
    return results;
  }
  
  // è·å–ç³»ç»Ÿç»Ÿè®¡ä¿¡æ¯
  getStats() {
    const allFiles = this.root.listFiles(true);
    const totalSize = this.root.getSize();
    
    const fileTypes = {};
    allFiles.forEach(file => {
      const ext = file.name.split('.').pop().toLowerCase();
      fileTypes[ext] = (fileTypes[ext] || 0) + 1;
    });
    
    return {
      totalFiles: allFiles.length,
      totalSize: totalSize,
      formattedSize: this.root.formatSize(totalSize),
      fileTypes,
      largestFile: allFiles.reduce((largest, file) => 
        file.getSize() > largest.getSize() ? file : largest, allFiles[0]),
      oldestFile: allFiles.reduce((oldest, file) => 
        file.createdAt < oldest.createdAt ? file : oldest, allFiles[0])
    };
  }
}

// ä½¿ç”¨ç¤ºä¾‹
function compositeDemo() {
  console.log('=== æ–‡ä»¶ç³»ç»Ÿç»„åˆæ¨¡å¼ç¤ºä¾‹ ===');
  
  const fs = new FileSystemManager();
  
  // åˆ›å»ºç›®å½•ç»“æ„
  const projectDir = fs.createDirectory('my-project');
  fs.changeDirectory('my-project');
  
  // åˆ›å»ºæºç ç›®å½•
  const srcDir = fs.createDirectory('src');
  fs.changeDirectory('src');
  
  // åˆ›å»ºæ–‡ä»¶
  fs.createFile('index.js', `
    console.log('Hello, World!');
    export default function main() {
      return 'Hello from main!';
    }
  `);
  
  fs.createFile('utils.js', `
    export function formatDate(date) {
      return date.toISOString().split('T')[0];
    }
    
    export function debounce(func, wait) {
      let timeout;
      return function executedFunction(...args) {
        const later = () => {
          clearTimeout(timeout);
          func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
      };
    }
  `);
  
  // åˆ›å»ºç»„ä»¶ç›®å½•
  const componentsDir = fs.createDirectory('components');
  fs.changeDirectory('components');
  
  fs.createFile('Button.js', `
    export default function Button({ children, onClick }) {
      return (
        <button onClick={onClick}>
          {children}
        </button>
      );
    }
  `);
  
  fs.createFile('Modal.js', `
    export default function Modal({ isOpen, onClose, children }) {
      if (!isOpen) return null;
      
      return (
        <div className="modal-overlay" onClick={onClose}>
          <div className="modal-content">
            {children}
          </div>
        </div>
      );
    }
  `);
  
  // å›åˆ°é¡¹ç›®æ ¹ç›®å½•
  fs.changeDirectory('/');
  fs.changeDirectory('my-project');
  
  // åˆ›å»ºé…ç½®æ–‡ä»¶
  fs.createFile('package.json', JSON.stringify({
    name: 'my-project',
    version: '1.0.0',
    main: 'src/index.js',
    scripts: {
      start: 'node src/index.js',
      build: 'webpack --mode production'
    },
    dependencies: {
      react: '^18.0.0',
      'react-dom': '^18.0.0'
    }
  }, null, 2));
  
  fs.createFile('README.md', `
    # My Project
    
    è¿™æ˜¯ä¸€ä¸ªç¤ºä¾‹é¡¹ç›®ï¼Œå±•ç¤ºäº†ç»„åˆæ¨¡å¼åœ¨æ–‡ä»¶ç³»ç»Ÿä¸­çš„åº”ç”¨ã€‚
    
    ## å®‰è£…
    
    \`\`\`bash
    npm install
    \`\`\`
    
    ## è¿è¡Œ
    
    \`\`\`bash
    npm start
    \`\`\`
  `);
  
  // æ˜¾ç¤ºç›®å½•æ ‘
  console.log('ğŸ“ é¡¹ç›®ç›®å½•ç»“æ„:');
  console.log(projectDir.getTree());
  
  // æ˜¾ç¤ºç»Ÿè®¡ä¿¡æ¯
  console.log('ğŸ“Š æ–‡ä»¶ç³»ç»Ÿç»Ÿè®¡:');
  const stats = fs.getStats();
  console.log(`æ€»æ–‡ä»¶æ•°: ${stats.totalFiles}`);
  console.log(`æ€»å¤§å°: ${stats.formattedSize}`);
  console.log('æ–‡ä»¶ç±»å‹åˆ†å¸ƒ:', stats.fileTypes);
  
  if (stats.largestFile) {
    console.log(`æœ€å¤§æ–‡ä»¶: ${stats.largestFile.name} (${projectDir.formatSize(stats.largestFile.getSize())})`);
  }
  
  // æœç´¢æ–‡ä»¶
  console.log('\nğŸ” æœç´¢ ".js" æ–‡ä»¶:');
  const jsFiles = fs.search('\\.js$');
  jsFiles.forEach(file => {
    console.log(`  ${file.getPath()} (${projectDir.formatSize(file.getSize())})`);
  });
  
  // æ–‡ä»¶æ“ä½œç¤ºä¾‹
  console.log('\nğŸ“ æ–‡ä»¶æ“ä½œç¤ºä¾‹:');
  
  // å¤åˆ¶ç›®å½•
  const backupDir = projectDir.copy();
  backupDir.name = 'my-project-backup';
  fs.root.add(backupDir);
  console.log('âœ… é¡¹ç›®å·²å¤‡ä»½');
  
  // ç§»åŠ¨æ–‡ä»¶
  const readmeFile = projectDir.remove('README.md');
  const docsDir = fs.createDirectory('docs', projectDir);
  docsDir.add(readmeFile);
  console.log('âœ… README.md å·²ç§»åŠ¨åˆ° docs ç›®å½•');
  
  // é‡å‘½åæ–‡ä»¶
  docsDir.rename('README.md', 'PROJECT_README.md');
  console.log('âœ… README.md å·²é‡å‘½åä¸º PROJECT_README.md');
  
  // æ˜¾ç¤ºæœ€ç»ˆç›®å½•ç»“æ„
  console.log('\nğŸ“ æœ€ç»ˆç›®å½•ç»“æ„:');
  console.log(fs.root.getTree());
}

compositeDemo();
```

## å…­ã€æ¡¥æ¥æ¨¡å¼ï¼šåˆ†ç¦»æŠ½è±¡ä¸å®ç°

### 6.1 ä»€ä¹ˆæ˜¯æ¡¥æ¥æ¨¡å¼ï¼Ÿ

æ¡¥æ¥æ¨¡å¼å°†æŠ½è±¡éƒ¨åˆ†ä¸å®ƒçš„å®ç°éƒ¨åˆ†åˆ†ç¦»ï¼Œä½¿å®ƒä»¬éƒ½å¯ä»¥ç‹¬ç«‹åœ°å˜åŒ–ã€‚è¿™ç§æ¨¡å¼é€šè¿‡ç»„åˆè€Œä¸æ˜¯ç»§æ‰¿æ¥å®ç°åŠŸèƒ½æ‰©å±•ã€‚

### 6.2 è·¨å¹³å°é€šçŸ¥ç³»ç»Ÿ

```javascript
// é€šçŸ¥å®ç°æ¥å£
class NotificationImplementation {
  send(title, message, options = {}) {
    throw new Error('send() æ–¹æ³•å¿…é¡»è¢«å®ç°');
  }
  
  isSupported() {
    throw new Error('isSupported() æ–¹æ³•å¿…é¡»è¢«å®ç°');
  }
  
  getCapabilities() {
    throw new Error('getCapabilities() æ–¹æ³•å¿…é¡»è¢«å®ç°');
  }
}

// æµè§ˆå™¨é€šçŸ¥å®ç°
class BrowserNotificationImpl extends NotificationImplementation {
  constructor() {
    super();
    this.permission = Notification.permission;
  }
  
  async send(title, message, options = {}) {
    if (!this.isSupported()) {
      throw new Error('æµè§ˆå™¨ä¸æ”¯æŒé€šçŸ¥ API');
    }
    
    if (this.permission !== 'granted') {
      const permission = await Notification.requestPermission();
      if (permission !== 'granted') {
        throw new Error('ç”¨æˆ·æ‹’ç»äº†é€šçŸ¥æƒé™');
      }
      this.permission = permission;
    }
    
    const notification = new Notification(title, {
      body: message,
      icon: options.icon || '/favicon.ico',
      badge: options.badge,
      image: options.image,
      tag: options.tag || 'default',
      requireInteraction: options.persistent || false,
      silent: options.silent || false,
      vibrate: options.vibrate,
      data: options.data
    });
    
    // è®¾ç½®äº‹ä»¶ç›‘å¬å™¨
    if (options.onClick) {
      notification.onclick = options.onClick;
    }
    
    if (options.onClose) {
      notification.onclose = options.onClose;
    }
    
    if (options.onError) {
      notification.onerror = options.onError;
    }
    
    // è‡ªåŠ¨å…³é—­
    if (options.autoClose && options.autoClose > 0) {
      setTimeout(() => {
        notification.close();
      }, options.autoClose);
    }
    
    return notification;
  }
  
  isSupported() {
    return 'Notification' in window;
  }
  
  getCapabilities() {
    return {
      persistent: true,
      actions: false,
      badge: true,
      image: true,
      icon: true,
      silent: true,
      vibrate: 'vibrate' in navigator,
      maxActions: 0
    };
  }
}

// ç§»åŠ¨ç«¯æ¨é€é€šçŸ¥å®ç°
class MobilePushImpl extends NotificationImplementation {
  constructor(serviceWorkerPath = '/sw.js') {
    super();
    this.serviceWorkerPath = serviceWorkerPath;
    this.registration = null;
    this.subscription = null;
  }
  
  async initialize() {
    if (!this.isSupported()) {
      throw new Error('æµè§ˆå™¨ä¸æ”¯æŒ Service Worker æˆ–æ¨é€é€šçŸ¥');
    }
    
    // æ³¨å†Œ Service Worker
    this.registration = await navigator.serviceWorker.register(this.serviceWorkerPath);
    
    // ç­‰å¾… Service Worker æ¿€æ´»
    await navigator.serviceWorker.ready;
    
    console.log('âœ… Service Worker å·²æ³¨å†Œå¹¶æ¿€æ´»');
  }
  
  async send(title, message, options = {}) {
    if (!this.registration) {
      await this.initialize();
    }
    
    // é€šè¿‡ Service Worker å‘é€é€šçŸ¥
    const notificationData = {
      title,
      body: message,
      icon: options.icon || '/icon-192x192.png',
      badge: options.badge || '/badge-72x72.png',
      image: options.image,
      tag: options.tag || 'default',
      requireInteraction: options.persistent || false,
      silent: options.silent || false,
      vibrate: options.vibrate || [200, 100, 200],
      data: {
        ...options.data,
        timestamp: Date.now(),
        url: options.url || window.location.href
      },
      actions: options.actions || []
    };
    
    return this.registration.showNotification(title, notificationData);
  }
  
  isSupported() {
    return 'serviceWorker' in navigator && 'PushManager' in window;
  }
  
  getCapabilities() {
    return {
      persistent: true,
      actions: true,
      badge: true,
      image: true,
      icon: true,
      silent: true,
      vibrate: true,
      maxActions: 2
    };
  }
  
  // è®¢é˜…æ¨é€æœåŠ¡
  async subscribeToPush(vapidPublicKey) {
    if (!this.registration) {
      await this.initialize();
    }
    
    this.subscription = await this.registration.pushManager.subscribe({
      userVisibleOnly: true,
      applicationServerKey: this.urlBase64ToUint8Array(vapidPublicKey)
    });
    
    return this.subscription;
  }
  
  // å·¥å…·æ–¹æ³•ï¼šè½¬æ¢ VAPID å¯†é’¥æ ¼å¼
  urlBase64ToUint8Array(base64String) {
    const padding = '='.repeat((4 - base64String.length % 4) % 4);
    const base64 = (base64String + padding)
      .replace(/-/g, '+')
      .replace(/_/g, '/');
    
    const rawData = window.atob(base64);
    const outputArray = new Uint8Array(rawData.length);
    
    for (let i = 0; i < rawData.length; ++i) {
      outputArray[i] = rawData.charCodeAt(i);
    }
    
    return outputArray;
  }
}

// é‚®ä»¶é€šçŸ¥å®ç°
class EmailNotificationImpl extends NotificationImplementation {
  constructor(apiEndpoint, apiKey) {
    super();
    this.apiEndpoint = apiEndpoint;
    this.apiKey = apiKey;
  }
  
  async send(title, message, options = {}) {
    const emailData = {
      to: options.email || options.recipient,
      subject: title,
      html: this.generateEmailHTML(title, message, options),
      text: message,
      from: options.from || 'noreply@example.com'
    };
    
    const response = await fetch(this.apiEndpoint, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${this.apiKey}`
      },
      body: JSON.stringify(emailData)
    });
    
    if (!response.ok) {
      throw new Error(`é‚®ä»¶å‘é€å¤±è´¥: ${response.statusText}`);
    }
    
    return await response.json();
  }
  
  generateEmailHTML(title, message, options) {
    return `
      <!DOCTYPE html>
      <html>
      <head>
        <meta charset="utf-8">
        <title>${title}</title>
        <style>
          body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; }
          .container { max-width: 600px; margin: 0 auto; padding: 20px; }
          .header { background: #007bff; color: white; padding: 20px; text-align: center; }
          .content { padding: 20px; background: #f8f9fa; }
          .footer { padding: 10px; text-align: center; font-size: 12px; color: #666; }
          .button { display: inline-block; padding: 10px 20px; background: #007bff; color: white; text-decoration: none; border-radius: 5px; }
        </style>
      </head>
      <body>
        <div class="container">
          <div class="header">
            <h1>${title}</h1>
          </div>
          <div class="content">
            <p>${message.replace(/\n/g, '<br>')}</p>
            ${options.actionUrl ? `<p><a href="${options.actionUrl}" class="button">${options.actionText || 'æŸ¥çœ‹è¯¦æƒ…'}</a></p>` : ''}
          </div>
          <div class="footer">
            <p>æ­¤é‚®ä»¶ç”±ç³»ç»Ÿè‡ªåŠ¨å‘é€ï¼Œè¯·å‹¿å›å¤ã€‚</p>
          </div>
        </div>
      </body>
      </html>
    `;
  }
  
  isSupported() {
    return !!this.apiEndpoint && !!this.apiKey;
  }
  
  getCapabilities() {
    return {
      persistent: true,
      actions: true,
      badge: false,
      image: true,
      icon: false,
      silent: false,
      vibrate: false,
      maxActions: 1,
      html: true,
      attachments: true
    };
  }
}

// æ§åˆ¶å°é€šçŸ¥å®ç°ï¼ˆç”¨äºå¼€å‘å’Œæµ‹è¯•ï¼‰
class ConsoleNotificationImpl extends NotificationImplementation {
  constructor() {
    super();
    this.notifications = [];
  }
  
  send(title, message, options = {}) {
    const notification = {
      id: Date.now() + Math.random(),
      title,
      message,
      options,
      timestamp: new Date(),
      read: false
    };
    
    this.notifications.push(notification);
    
    // æ§åˆ¶å°è¾“å‡º
    console.group(`ğŸ“¢ é€šçŸ¥: ${title}`);
    console.log(`æ¶ˆæ¯: ${message}`);
    console.log('é€‰é¡¹:', options);
    console.log('æ—¶é—´:', notification.timestamp.toLocaleString());
    console.groupEnd();
    
    // æ¨¡æ‹Ÿç‚¹å‡»äº‹ä»¶
    if (options.onClick) {
      console.log('ğŸ–±ï¸ ç‚¹å‡»é€šçŸ¥å¯è§¦å‘å›è°ƒ');
    }
    
    return Promise.resolve(notification);
  }
  
  isSupported() {
    return true; // æ§åˆ¶å°æ€»æ˜¯å¯ç”¨çš„
  }
  
  getCapabilities() {
    return {
      persistent: true,
      actions: true,
      badge: false,
      image: false,
      icon: false,
      silent: false,
      vibrate: false,
      maxActions: 10,
      history: true
    };
  }
  
  getHistory() {
    return this.notifications;
  }
  
  markAsRead(notificationId) {
    const notification = this.notifications.find(n => n.id === notificationId);
    if (notification) {
      notification.read = true;
    }
  }
  
  clear() {
    this.notifications = [];
    console.log('ğŸ§¹ é€šçŸ¥å†å²å·²æ¸…ç©º');
  }
}

// é€šçŸ¥æŠ½è±¡ç±»
class Notification {
  constructor(implementation) {
    this.implementation = implementation;
    this.queue = [];
    this.isProcessing = false;
    this.retryAttempts = 3;
    this.retryDelay = 1000;
  }
  
  async send(title, message, options = {}) {
    return this.implementation.send(title, message, options);
  }
  
  isSupported() {
    return this.implementation.isSupported();
  }
  
  getCapabilities() {
    return this.implementation.getCapabilities();
  }
  
  // é˜Ÿåˆ—å‘é€
  async queueSend(title, message, options = {}) {
    return new Promise((resolve, reject) => {
      this.queue.push({ title, message, options, resolve, reject });
      this.processQueue();
    });
  }
  
  async processQueue() {
    if (this.isProcessing || this.queue.length === 0) {
      return;
    }
    
    this.isProcessing = true;
    
    while (this.queue.length > 0) {
      const { title, message, options, resolve, reject } = this.queue.shift();
      
      try {
        const result = await this.sendWithRetry(title, message, options);
        resolve(result);
      } catch (error) {
        reject(error);
      }
      
      // é¿å…å‘é€è¿‡äºé¢‘ç¹
      await new Promise(resolve => setTimeout(resolve, 100));
    }
    
    this.isProcessing = false;
  }
  
  async sendWithRetry(title, message, options = {}) {
    let lastError;
    
    for (let attempt = 1; attempt <= this.retryAttempts; attempt++) {
      try {
        return await this.send(title, message, options);
      } catch (error) {
        lastError = error;
        console.warn(`é€šçŸ¥å‘é€å¤±è´¥ (å°è¯• ${attempt}/${this.retryAttempts}):`, error.message);
        
        if (attempt < this.retryAttempts) {
          await new Promise(resolve => setTimeout(resolve, this.retryDelay * attempt));
        }
      }
    }
    
    throw lastError;
  }
}

// å…·ä½“é€šçŸ¥ç±»å‹
class BrowserNotification extends Notification {
  constructor() {
    super(new BrowserNotificationImpl());
  }
}

class MobilePushNotification extends Notification {
  constructor(serviceWorkerPath) {
    super(new MobilePushImpl(serviceWorkerPath));
  }
  
  async subscribeToPush(vapidPublicKey) {
    return this.implementation.subscribeToPush(vapidPublicKey);
  }
}

class EmailNotification extends Notification {
  constructor(apiEndpoint, apiKey) {
    super(new EmailNotificationImpl(apiEndpoint, apiKey));
  }
}

class ConsoleNotification extends Notification {
  constructor() {
    super(new ConsoleNotificationImpl());
  }
  
  getHistory() {
    return this.implementation.getHistory();
  }
  
  markAsRead(notificationId) {
    return this.implementation.markAsRead(notificationId);
  }
  
  clear() {
    return this.implementation.clear();
  }
}

// é€šçŸ¥ç®¡ç†å™¨
class NotificationManager {
  constructor() {
    this.providers = new Map();
    this.defaultProvider = null;
    this.fallbackChain = [];
  }
  
  // æ³¨å†Œé€šçŸ¥æä¾›è€…
  registerProvider(name, notification) {
    this.providers.set(name, notification);
    
    if (!this.defaultProvider) {
      this.defaultProvider = name;
    }
    
    return this;
  }
  
  // è®¾ç½®é»˜è®¤æä¾›è€…
  setDefaultProvider(name) {
    if (!this.providers.has(name)) {
      throw new Error(`é€šçŸ¥æä¾›è€… "${name}" ä¸å­˜åœ¨`);
    }
    this.defaultProvider = name;
    return this;
  }
  
  // è®¾ç½®é™çº§é“¾
  setFallbackChain(providers) {
    this.fallbackChain = providers.filter(name => this.providers.has(name));
    return this;
  }
  
  // å‘é€é€šçŸ¥
  async send(title, message, options = {}) {
    const providerName = options.provider || this.defaultProvider;
    
    if (!providerName) {
      throw new Error('æ²¡æœ‰å¯ç”¨çš„é€šçŸ¥æä¾›è€…');
    }
    
    // å°è¯•æŒ‡å®šçš„æä¾›è€…
    try {
      const provider = this.providers.get(providerName);
      if (provider && provider.isSupported()) {
        return await provider.send(title, message, options);
      }
    } catch (error) {
      console.warn(`é€šçŸ¥æä¾›è€… "${providerName}" å‘é€å¤±è´¥:`, error.message);
    }
    
    // å°è¯•é™çº§é“¾
    for (const fallbackName of this.fallbackChain) {
      try {
        const provider = this.providers.get(fallbackName);
        if (provider && provider.isSupported()) {
          console.log(`é™çº§åˆ°é€šçŸ¥æä¾›è€…: ${fallbackName}`);
          return await provider.send(title, message, options);
        }
      } catch (error) {
        console.warn(`é™çº§é€šçŸ¥æä¾›è€… "${fallbackName}" å‘é€å¤±è´¥:`, error.message);
      }
    }
    
    throw new Error('æ‰€æœ‰é€šçŸ¥æä¾›è€…éƒ½ä¸å¯ç”¨');
  }
  
  // æ‰¹é‡å‘é€
  async sendBatch(notifications) {
    const results = [];
    
    for (const notification of notifications) {
      try {
        const result = await this.send(
          notification.title,
          notification.message,
          notification.options
        );
        results.push({ success: true, result });
      } catch (error) {
        results.push({ success: false, error: error.message });
      }
    }
    
    return results;
  }
  
  // è·å–æ‰€æœ‰æä¾›è€…çš„èƒ½åŠ›
  getCapabilities() {
    const capabilities = {};
    
    for (const [name, provider] of this.providers) {
      capabilities[name] = {
        supported: provider.isSupported(),
        capabilities: provider.getCapabilities()
      };
    }
    
    return capabilities;
  }
}

// ä½¿ç”¨ç¤ºä¾‹
async function bridgeDemo() {
  console.log('=== æ¡¥æ¥æ¨¡å¼é€šçŸ¥ç³»ç»Ÿç¤ºä¾‹ ===');
  
  // åˆ›å»ºé€šçŸ¥ç®¡ç†å™¨
  const notificationManager = new NotificationManager();
  
  // æ³¨å†Œä¸åŒçš„é€šçŸ¥æä¾›è€…
  notificationManager
    .registerProvider('browser', new BrowserNotification())
    .registerProvider('console', new ConsoleNotification())
    .registerProvider('email', new EmailNotification('https://api.emailservice.com/send', 'your-api-key'))
    .setDefaultProvider('console')
    .setFallbackChain(['browser', 'console']);
  
  // æ˜¾ç¤ºæ‰€æœ‰æä¾›è€…çš„èƒ½åŠ›
  console.log('ğŸ“‹ é€šçŸ¥æä¾›è€…èƒ½åŠ›:');
  const capabilities = notificationManager.getCapabilities();
  Object.entries(capabilities).forEach(([name, info]) => {
    console.log(`${name}: æ”¯æŒ=${info.supported}`, info.capabilities);
  });
  
  // å‘é€ç®€å•é€šçŸ¥
  console.log('\nğŸ“¢ å‘é€ç®€å•é€šçŸ¥:');
  try {
    await notificationManager.send(
      'æ¬¢è¿ä½¿ç”¨ç³»ç»Ÿ',
      'æ‚¨å·²æˆåŠŸç™»å½•åˆ°æˆ‘ä»¬çš„å¹³å°ï¼',
      {
        icon: '/welcome-icon.png',
        autoClose: 5000,
        onClick: () => console.log('ç”¨æˆ·ç‚¹å‡»äº†æ¬¢è¿é€šçŸ¥')
      }
    );
  } catch (error) {
    console.error('å‘é€é€šçŸ¥å¤±è´¥:', error.message);
  }
  
  // å‘é€ä¸åŒç±»å‹çš„é€šçŸ¥
  const notifications = [
    {
      title: 'ç³»ç»Ÿæ›´æ–°',
      message: 'ç³»ç»Ÿå°†åœ¨ä»Šæ™š 2:00 è¿›è¡Œç»´æŠ¤æ›´æ–°ï¼Œé¢„è®¡æŒç»­ 30 åˆ†é’Ÿã€‚',
      options: {
        persistent: true,
        vibrate: [200, 100, 200],
        actions: [
          { action: 'details', title: 'æŸ¥çœ‹è¯¦æƒ…' },
          { action: 'remind', title: 'ç¨åæé†’' }
        ]
      }
    },
    {
      title: 'æ–°æ¶ˆæ¯',
      message: 'æ‚¨æœ‰ 3 æ¡æœªè¯»æ¶ˆæ¯',
      options: {
        badge: '/message-badge.png',
        tag: 'messages',
        data: { messageCount: 3, type: 'inbox' }
      }
    },
    {
      title: 'ä»»åŠ¡æé†’',
      message: 'æ‚¨çš„ä»»åŠ¡ "å®Œæˆé¡¹ç›®æŠ¥å‘Š" å³å°†åˆ°æœŸ',
      options: {
        provider: 'browser', // æŒ‡å®šä½¿ç”¨æµè§ˆå™¨é€šçŸ¥
        requireInteraction: true,
        actions: [
          { action: 'complete', title: 'æ ‡è®°å®Œæˆ' },
          { action: 'snooze', title: 'å»¶æœŸ' }
        ]
      }
    }
  ];
  
  console.log('\nğŸ“¬ æ‰¹é‡å‘é€é€šçŸ¥:');
  const results = await notificationManager.sendBatch(notifications);
  results.forEach((result, index) => {
    if (result.success) {
      console.log(`âœ… é€šçŸ¥ ${index + 1} å‘é€æˆåŠŸ`);
    } else {
      console.log(`âŒ é€šçŸ¥ ${index + 1} å‘é€å¤±è´¥: ${result.error}`);
    }
  });
  
  // æ˜¾ç¤ºæ§åˆ¶å°é€šçŸ¥å†å²
  const consoleProvider = notificationManager.providers.get('console');
  if (consoleProvider) {
    console.log('\nğŸ“œ é€šçŸ¥å†å²:');
    const history = consoleProvider.getHistory();
    history.forEach((notification, index) => {
      console.log(`${index + 1}. ${notification.title} - ${notification.timestamp.toLocaleTimeString()}`);
    });
  }
}

bridgeDemo();
```

## æ€»ç»“

ç»“æ„å‹æ¨¡å¼ä¸ºæˆ‘ä»¬æä¾›äº†ç»„ç»‡å’Œç»„åˆå¯¹è±¡çš„å¼ºå¤§å·¥å…·ã€‚é€šè¿‡æœ¬æ–‡çš„å­¦ä¹ ï¼Œæˆ‘ä»¬äº†è§£äº†ï¼š

### ğŸ¯ æ ¸å¿ƒä»·å€¼

1. **é€‚é…å™¨æ¨¡å¼**ï¼šè®©ä¸å…¼å®¹çš„æ¥å£èƒ½å¤ŸååŒå·¥ä½œ
2. **è£…é¥°å™¨æ¨¡å¼**ï¼šåŠ¨æ€åœ°ç»™å¯¹è±¡æ·»åŠ æ–°åŠŸèƒ½
3. **ä»£ç†æ¨¡å¼**ï¼šæ§åˆ¶å¯¹è±¡çš„è®¿é—®ï¼Œæä¾›é¢å¤–çš„åŠŸèƒ½å±‚
4. **å¤–è§‚æ¨¡å¼**ï¼šç®€åŒ–å¤æ‚å­ç³»ç»Ÿçš„ä½¿ç”¨
5. **ç»„åˆæ¨¡å¼**ï¼šç»Ÿä¸€å¤„ç†å•ä¸ªå¯¹è±¡å’Œå¯¹è±¡é›†åˆ
6. **æ¡¥æ¥æ¨¡å¼**ï¼šåˆ†ç¦»æŠ½è±¡ä¸å®ç°ï¼Œæé«˜ç³»ç»Ÿçš„çµæ´»æ€§

### ğŸš€ å®é™…åº”ç”¨

è¿™äº›æ¨¡å¼åœ¨ç°ä»£å‰ç«¯å¼€å‘ä¸­éšå¤„å¯è§ï¼š

- **React HOC** å°±æ˜¯è£…é¥°å™¨æ¨¡å¼çš„å…¸å‹åº”ç”¨
- **Vue çš„å“åº”å¼ç³»ç»Ÿ** å¤§é‡ä½¿ç”¨äº†ä»£ç†æ¨¡å¼
- **ç»„ä»¶åº“çš„ API è®¾è®¡** ç»å¸¸é‡‡ç”¨å¤–è§‚æ¨¡å¼
- **è™šæ‹Ÿ DOM** å¯ä»¥çœ‹ä½œæ˜¯ç»„åˆæ¨¡å¼çš„å®ç°
- **è·¨å¹³å°æ¡†æ¶** æ™®éä½¿ç”¨æ¡¥æ¥æ¨¡å¼

### ğŸ’¡ é€‰æ‹©å»ºè®®

é€‰æ‹©åˆé€‚çš„ç»“æ„å‹æ¨¡å¼æ—¶ï¼Œè€ƒè™‘ä»¥ä¸‹å› ç´ ï¼š

```mermaid
graph TD
    A[éœ€è¦è§£å†³çš„é—®é¢˜] --> B{æ¥å£ä¸å…¼å®¹?}
    B -->|æ˜¯| C[é€‚é…å™¨æ¨¡å¼]
    B -->|å¦| D{éœ€è¦åŠ¨æ€æ·»åŠ åŠŸèƒ½?}
    D -->|æ˜¯| E[è£…é¥°å™¨æ¨¡å¼]
    D -->|å¦| F{éœ€è¦æ§åˆ¶è®¿é—®?}
    F -->|æ˜¯| G[ä»£ç†æ¨¡å¼]
    F -->|å¦| H{ç³»ç»Ÿè¿‡äºå¤æ‚?}
    H -->|æ˜¯| I[å¤–è§‚æ¨¡å¼]
    H -->|å¦| J{æ ‘å½¢ç»“æ„?}
    J -->|æ˜¯| K[ç»„åˆæ¨¡å¼]
    J -->|å¦| L{æŠ½è±¡ä¸å®ç°åˆ†ç¦»?}
    L -->|æ˜¯| M[æ¡¥æ¥æ¨¡å¼]
    L -->|å¦| N[é‡æ–°åˆ†æéœ€æ±‚]
```

æŒæ¡è¿™äº›ç»“æ„å‹æ¨¡å¼ï¼Œèƒ½è®©æˆ‘ä»¬å†™å‡ºæ›´åŠ çµæ´»ã€å¯ç»´æŠ¤çš„ä»£ç ã€‚åœ¨ä¸‹ä¸€ç¯‡æ–‡ç« ä¸­ï¼Œæˆ‘ä»¬å°†æ¢è®¨è¡Œä¸ºå‹æ¨¡å¼ï¼Œçœ‹çœ‹å¦‚ä½•ä¼˜é›…åœ°å¤„ç†å¯¹è±¡é—´çš„äº¤äº’å’ŒèŒè´£åˆ†é…ã€‚

è®°ä½ï¼Œè®¾è®¡æ¨¡å¼ä¸æ˜¯é“¶å¼¹ï¼Œå…³é”®æ˜¯è¦ç†è§£å…¶æœ¬è´¨ï¼Œåœ¨åˆé€‚çš„åœºæ™¯ä¸‹çµæ´»è¿ç”¨ã€‚è®©æˆ‘ä»¬ç»§ç»­åœ¨ä»£ç çš„ä¸–ç•Œé‡Œæ¢ç´¢æ›´å¤šçš„å¯èƒ½æ€§ï¼ ğŸ‰