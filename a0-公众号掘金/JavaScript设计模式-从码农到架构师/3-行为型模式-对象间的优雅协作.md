# è¡Œä¸ºå‹æ¨¡å¼ï¼šå¯¹è±¡é—´çš„ä¼˜é›…åä½œ

> å¦‚æœè¯´åˆ›å»ºå‹æ¨¡å¼æ˜¯"ç”Ÿå­©å­"ï¼Œç»“æ„å‹æ¨¡å¼æ˜¯"æ­ç§¯æœ¨"ï¼Œé‚£ä¹ˆè¡Œä¸ºå‹æ¨¡å¼å°±æ˜¯"è°ˆæ‹çˆ±" â€”â€” å®ƒå…³æ³¨çš„æ˜¯å¯¹è±¡ä¹‹é—´å¦‚ä½•ä¼˜é›…åœ°äº¤æµã€åä½œå’Œåˆ†å·¥ã€‚

åœ¨å‰é¢ä¸¤ç¯‡æ–‡ç« ä¸­ï¼Œæˆ‘ä»¬å­¦ä¹ äº†å¦‚ä½•åˆ›å»ºå¯¹è±¡å’Œç»„ç»‡å¯¹è±¡ã€‚ä»Šå¤©ï¼Œæˆ‘ä»¬è¦æ·±å…¥æ¢è®¨å¯¹è±¡é—´çš„äº¤äº’è‰ºæœ¯ â€”â€” è¡Œä¸ºå‹æ¨¡å¼ã€‚è¿™äº›æ¨¡å¼å°±åƒæ˜¯ç»™å¯¹è±¡ä»¬åˆ¶å®šäº†ä¸€å¥—"ç¤¾äº¤ç¤¼ä»ª"ï¼Œè®©å®ƒä»¬èƒ½å¤Ÿå’Œè°å…±å¤„ï¼Œå„å¸å…¶èŒã€‚

## ä¸€ã€è§‚å¯Ÿè€…æ¨¡å¼ï¼šæ¶ˆæ¯ä¼ é€’çš„è‰ºæœ¯

### 1.1 ä»€ä¹ˆæ˜¯è§‚å¯Ÿè€…æ¨¡å¼ï¼Ÿ

è§‚å¯Ÿè€…æ¨¡å¼å®šä¹‰äº†å¯¹è±¡é—´çš„ä¸€å¯¹å¤šä¾èµ–å…³ç³»ï¼Œå½“ä¸€ä¸ªå¯¹è±¡çš„çŠ¶æ€å‘ç”Ÿæ”¹å˜æ—¶ï¼Œæ‰€æœ‰ä¾èµ–äºå®ƒçš„å¯¹è±¡éƒ½ä¼šå¾—åˆ°é€šçŸ¥å¹¶è‡ªåŠ¨æ›´æ–°ã€‚è¿™å°±åƒæ˜¯å¾®ä¿¡ç¾¤èŠï¼Œç¾¤ä¸»å‘æ¶ˆæ¯ï¼Œæ‰€æœ‰ç¾¤æˆå‘˜éƒ½èƒ½æ”¶åˆ°ã€‚

### 1.2 äº‹ä»¶ç³»ç»Ÿçš„å®ç°

```javascript
// è§‚å¯Ÿè€…æ¥å£
class Observer {
  update(data) {
    throw new Error('update() æ–¹æ³•å¿…é¡»è¢«å®ç°');
  }
}

// è¢«è§‚å¯Ÿè€…ï¼ˆä¸»é¢˜ï¼‰
class Subject {
  constructor() {
    this.observers = new Set();
    this.state = null;
  }
  
  // æ·»åŠ è§‚å¯Ÿè€…
  attach(observer) {
    if (!(observer instanceof Observer)) {
      throw new Error('è§‚å¯Ÿè€…å¿…é¡»å®ç° Observer æ¥å£');
    }
    this.observers.add(observer);
    return this;
  }
  
  // ç§»é™¤è§‚å¯Ÿè€…
  detach(observer) {
    this.observers.delete(observer);
    return this;
  }
  
  // é€šçŸ¥æ‰€æœ‰è§‚å¯Ÿè€…
  notify(data) {
    for (const observer of this.observers) {
      try {
        observer.update(data);
      } catch (error) {
        console.error('è§‚å¯Ÿè€…æ›´æ–°å¤±è´¥:', error);
      }
    }
  }
  
  // è®¾ç½®çŠ¶æ€å¹¶é€šçŸ¥
  setState(newState) {
    const oldState = this.state;
    this.state = newState;
    this.notify({ oldState, newState, timestamp: Date.now() });
  }
  
  getState() {
    return this.state;
  }
  
  getObserverCount() {
    return this.observers.size;
  }
}

// å…·ä½“è§‚å¯Ÿè€…å®ç°
class Logger extends Observer {
  constructor(name) {
    super();
    this.name = name;
    this.logs = [];
  }
  
  update(data) {
    const logEntry = {
      timestamp: new Date().toISOString(),
      observer: this.name,
      data: JSON.stringify(data)
    };
    
    this.logs.push(logEntry);
    console.log(`[${this.name}] çŠ¶æ€å˜æ›´:`, data);
  }
  
  getLogs() {
    return this.logs;
  }
  
  clearLogs() {
    this.logs = [];
  }
}

class EmailNotifier extends Observer {
  constructor(emailService) {
    super();
    this.emailService = emailService;
    this.subscribers = new Set();
  }
  
  addSubscriber(email) {
    this.subscribers.add(email);
  }
  
  removeSubscriber(email) {
    this.subscribers.delete(email);
  }
  
  update(data) {
    const subject = 'ç³»ç»ŸçŠ¶æ€å˜æ›´é€šçŸ¥';
    const message = `
      ç³»ç»ŸçŠ¶æ€å·²ä» "${data.oldState}" å˜æ›´ä¸º "${data.newState}"
      å˜æ›´æ—¶é—´: ${new Date(data.timestamp).toLocaleString()}
    `;
    
    for (const email of this.subscribers) {
      this.emailService.send(email, subject, message)
        .then(() => console.log(`âœ… é‚®ä»¶å·²å‘é€åˆ° ${email}`))
        .catch(error => console.error(`âŒ é‚®ä»¶å‘é€å¤±è´¥ ${email}:`, error));
    }
  }
}

class MetricsCollector extends Observer {
  constructor() {
    super();
    this.metrics = {
      stateChanges: 0,
      lastChangeTime: null,
      stateHistory: [],
      averageChangeInterval: 0
    };
  }
  
  update(data) {
    this.metrics.stateChanges++;
    
    const now = data.timestamp;
    if (this.metrics.lastChangeTime) {
      const interval = now - this.metrics.lastChangeTime;
      this.metrics.averageChangeInterval = 
        (this.metrics.averageChangeInterval * (this.metrics.stateChanges - 1) + interval) / this.metrics.stateChanges;
    }
    
    this.metrics.lastChangeTime = now;
    this.metrics.stateHistory.push({
      state: data.newState,
      timestamp: now
    });
    
    // åªä¿ç•™æœ€è¿‘100æ¡è®°å½•
    if (this.metrics.stateHistory.length > 100) {
      this.metrics.stateHistory.shift();
    }
    
    console.log('ğŸ“Š æŒ‡æ ‡æ›´æ–°:', this.getMetrics());
  }
  
  getMetrics() {
    return {
      ...this.metrics,
      averageChangeInterval: Math.round(this.metrics.averageChangeInterval)
    };
  }
  
  reset() {
    this.metrics = {
      stateChanges: 0,
      lastChangeTime: null,
      stateHistory: [],
      averageChangeInterval: 0
    };
  }
}

// é«˜çº§äº‹ä»¶ç³»ç»Ÿ
class EventEmitter extends Subject {
  constructor() {
    super();
    this.events = new Map();
    this.maxListeners = 10;
    this.onceListeners = new Map();
  }
  
  // ç›‘å¬äº‹ä»¶
  on(eventName, listener) {
    if (!this.events.has(eventName)) {
      this.events.set(eventName, new Set());
    }
    
    const listeners = this.events.get(eventName);
    if (listeners.size >= this.maxListeners) {
      console.warn(`è­¦å‘Š: äº‹ä»¶ "${eventName}" çš„ç›‘å¬å™¨æ•°é‡å·²è¾¾åˆ°æœ€å¤§å€¼ ${this.maxListeners}`);
    }
    
    listeners.add(listener);
    return this;
  }
  
  // ç›‘å¬ä¸€æ¬¡
  once(eventName, listener) {
    if (!this.onceListeners.has(eventName)) {
      this.onceListeners.set(eventName, new Set());
    }
    
    this.onceListeners.get(eventName).add(listener);
    return this;
  }
  
  // ç§»é™¤ç›‘å¬å™¨
  off(eventName, listener) {
    if (this.events.has(eventName)) {
      this.events.get(eventName).delete(listener);
    }
    
    if (this.onceListeners.has(eventName)) {
      this.onceListeners.get(eventName).delete(listener);
    }
    
    return this;
  }
  
  // è§¦å‘äº‹ä»¶
  emit(eventName, ...args) {
    const timestamp = Date.now();
    
    // è§¦å‘æ™®é€šç›‘å¬å™¨
    if (this.events.has(eventName)) {
      for (const listener of this.events.get(eventName)) {
        try {
          listener.call(this, ...args, { eventName, timestamp });
        } catch (error) {
          console.error(`äº‹ä»¶ç›‘å¬å™¨æ‰§è¡Œå¤±è´¥ (${eventName}):`, error);
        }
      }
    }
    
    // è§¦å‘ä¸€æ¬¡æ€§ç›‘å¬å™¨
    if (this.onceListeners.has(eventName)) {
      const onceListeners = this.onceListeners.get(eventName);
      for (const listener of onceListeners) {
        try {
          listener.call(this, ...args, { eventName, timestamp });
        } catch (error) {
          console.error(`ä¸€æ¬¡æ€§äº‹ä»¶ç›‘å¬å™¨æ‰§è¡Œå¤±è´¥ (${eventName}):`, error);
        }
      }
      // æ¸…é™¤ä¸€æ¬¡æ€§ç›‘å¬å™¨
      onceListeners.clear();
    }
    
    return this;
  }
  
  // ç§»é™¤æ‰€æœ‰ç›‘å¬å™¨
  removeAllListeners(eventName) {
    if (eventName) {
      this.events.delete(eventName);
      this.onceListeners.delete(eventName);
    } else {
      this.events.clear();
      this.onceListeners.clear();
    }
    return this;
  }
  
  // è·å–ç›‘å¬å™¨æ•°é‡
  listenerCount(eventName) {
    const regularCount = this.events.has(eventName) ? this.events.get(eventName).size : 0;
    const onceCount = this.onceListeners.has(eventName) ? this.onceListeners.get(eventName).size : 0;
    return regularCount + onceCount;
  }
  
  // è®¾ç½®æœ€å¤§ç›‘å¬å™¨æ•°é‡
  setMaxListeners(n) {
    this.maxListeners = n;
    return this;
  }
  
  // è·å–æ‰€æœ‰äº‹ä»¶å
  eventNames() {
    const names = new Set();
    for (const name of this.events.keys()) {
      names.add(name);
    }
    for (const name of this.onceListeners.keys()) {
      names.add(name);
    }
    return Array.from(names);
  }
}

// æ¨¡æ‹Ÿé‚®ä»¶æœåŠ¡
class MockEmailService {
  async send(to, subject, message) {
    // æ¨¡æ‹Ÿç½‘ç»œå»¶è¿Ÿ
    await new Promise(resolve => setTimeout(resolve, Math.random() * 1000));
    
    // æ¨¡æ‹Ÿå¶å°”çš„å‘é€å¤±è´¥
    if (Math.random() < 0.1) {
      throw new Error('ç½‘ç»œé”™è¯¯');
    }
    
    return {
      messageId: `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      to,
      subject,
      sentAt: new Date().toISOString()
    };
  }
}

// ä½¿ç”¨ç¤ºä¾‹
function observerDemo() {
  console.log('=== è§‚å¯Ÿè€…æ¨¡å¼ç¤ºä¾‹ ===');
  
  // åˆ›å»ºä¸»é¢˜
  const systemStatus = new Subject();
  
  // åˆ›å»ºè§‚å¯Ÿè€…
  const logger = new Logger('SystemLogger');
  const emailService = new MockEmailService();
  const emailNotifier = new EmailNotifier(emailService);
  const metricsCollector = new MetricsCollector();
  
  // æ·»åŠ é‚®ä»¶è®¢é˜…è€…
  emailNotifier.addSubscriber('admin@example.com');
  emailNotifier.addSubscriber('ops@example.com');
  
  // æ³¨å†Œè§‚å¯Ÿè€…
  systemStatus
    .attach(logger)
    .attach(emailNotifier)
    .attach(metricsCollector);
  
  console.log(`è§‚å¯Ÿè€…æ•°é‡: ${systemStatus.getObserverCount()}`);
  
  // æ¨¡æ‹ŸçŠ¶æ€å˜åŒ–
  console.log('\nğŸ”„ æ¨¡æ‹Ÿç³»ç»ŸçŠ¶æ€å˜åŒ–:');
  
  systemStatus.setState('å¯åŠ¨ä¸­');
  setTimeout(() => systemStatus.setState('è¿è¡Œä¸­'), 1000);
  setTimeout(() => systemStatus.setState('ç»´æŠ¤ä¸­'), 2000);
  setTimeout(() => systemStatus.setState('è¿è¡Œä¸­'), 3000);
  
  // æ˜¾ç¤ºæ—¥å¿—å’ŒæŒ‡æ ‡
  setTimeout(() => {
    console.log('\nğŸ“‹ ç³»ç»Ÿæ—¥å¿—:');
    logger.getLogs().forEach(log => {
      console.log(`${log.timestamp} [${log.observer}]: ${log.data}`);
    });
    
    console.log('\nğŸ“Š ç³»ç»ŸæŒ‡æ ‡:');
    console.log(metricsCollector.getMetrics());
  }, 4000);
}

// äº‹ä»¶ç³»ç»Ÿç¤ºä¾‹
function eventEmitterDemo() {
  console.log('\n=== äº‹ä»¶ç³»ç»Ÿç¤ºä¾‹ ===');
  
  const eventBus = new EventEmitter();
  
  // ç”¨æˆ·ç™»å½•äº‹ä»¶ç›‘å¬
  eventBus.on('user:login', (user, meta) => {
    console.log(`ğŸ‘¤ ç”¨æˆ·ç™»å½•: ${user.name} (${user.email})`);
    console.log(`ç™»å½•æ—¶é—´: ${new Date(meta.timestamp).toLocaleString()}`);
  });
  
  // ç”¨æˆ·ç™»å½•ç»Ÿè®¡
  let loginCount = 0;
  eventBus.on('user:login', () => {
    loginCount++;
    console.log(`ğŸ“ˆ æ€»ç™»å½•æ¬¡æ•°: ${loginCount}`);
  });
  
  // ä¸€æ¬¡æ€§æ¬¢è¿æ¶ˆæ¯
  eventBus.once('user:login', (user) => {
    console.log(`ğŸ‰ æ¬¢è¿æ–°ç”¨æˆ·: ${user.name}!`);
  });
  
  // ç”¨æˆ·æ³¨é”€äº‹ä»¶
  eventBus.on('user:logout', (user, meta) => {
    console.log(`ğŸ‘‹ ç”¨æˆ·æ³¨é”€: ${user.name}`);
  });
  
  // ç³»ç»Ÿé”™è¯¯äº‹ä»¶
  eventBus.on('system:error', (error, meta) => {
    console.error(`ğŸš¨ ç³»ç»Ÿé”™è¯¯: ${error.message}`);
    console.error(`é”™è¯¯æ—¶é—´: ${new Date(meta.timestamp).toLocaleString()}`);
  });
  
  // æ¨¡æ‹Ÿäº‹ä»¶è§¦å‘
  console.log('\nğŸ­ æ¨¡æ‹Ÿäº‹ä»¶è§¦å‘:');
  
  eventBus.emit('user:login', { name: 'Alice', email: 'alice@example.com' });
  eventBus.emit('user:login', { name: 'Bob', email: 'bob@example.com' });
  eventBus.emit('user:logout', { name: 'Alice', email: 'alice@example.com' });
  eventBus.emit('system:error', new Error('æ•°æ®åº“è¿æ¥å¤±è´¥'));
  
  // æ˜¾ç¤ºäº‹ä»¶ç»Ÿè®¡
  console.log('\nğŸ“Š äº‹ä»¶ç»Ÿè®¡:');
  console.log('äº‹ä»¶åç§°:', eventBus.eventNames());
  console.log('user:login ç›‘å¬å™¨æ•°é‡:', eventBus.listenerCount('user:login'));
  console.log('user:logout ç›‘å¬å™¨æ•°é‡:', eventBus.listenerCount('user:logout'));
}

observerDemo();
setTimeout(eventEmitterDemo, 5000);
```

## äºŒã€ç­–ç•¥æ¨¡å¼ï¼šç®—æ³•çš„å¯æ’æ‹”è®¾è®¡

### 2.1 ä»€ä¹ˆæ˜¯ç­–ç•¥æ¨¡å¼ï¼Ÿ

ç­–ç•¥æ¨¡å¼å®šä¹‰äº†ä¸€ç³»åˆ—ç®—æ³•ï¼ŒæŠŠå®ƒä»¬ä¸€ä¸ªä¸ªå°è£…èµ·æ¥ï¼Œå¹¶ä¸”ä½¿å®ƒä»¬å¯ä»¥ç›¸äº’æ›¿æ¢ã€‚è¿™ä¸ªæ¨¡å¼è®©ç®—æ³•ç‹¬ç«‹äºä½¿ç”¨å®ƒçš„å®¢æˆ·è€Œå˜åŒ–ã€‚å°±åƒæ˜¯é€‰æ‹©ä¸åŒçš„å‡ºè¡Œæ–¹å¼ï¼šèµ°è·¯ã€éª‘è½¦ã€å¼€è½¦ã€ååœ°é“ï¼Œç›®æ ‡éƒ½æ˜¯åˆ°è¾¾ç›®çš„åœ°ï¼Œä½†ç­–ç•¥ä¸åŒã€‚

### 2.2 æ”¯ä»˜ç³»ç»Ÿçš„ç­–ç•¥å®ç°

```javascript
// ç­–ç•¥æ¥å£
class PaymentStrategy {
  async pay(amount, options = {}) {
    throw new Error('pay() æ–¹æ³•å¿…é¡»è¢«å®ç°');
  }
  
  validate(amount, options = {}) {
    throw new Error('validate() æ–¹æ³•å¿…é¡»è¢«å®ç°');
  }
  
  getInfo() {
    throw new Error('getInfo() æ–¹æ³•å¿…é¡»è¢«å®ç°');
  }
}

// æ”¯ä»˜å®ç­–ç•¥
class AlipayStrategy extends PaymentStrategy {
  constructor(appId, privateKey) {
    super();
    this.appId = appId;
    this.privateKey = privateKey;
    this.name = 'Alipay';
  }
  
  validate(amount, options = {}) {
    if (amount <= 0) {
      throw new Error('æ”¯ä»˜é‡‘é¢å¿…é¡»å¤§äº0');
    }
    
    if (amount > 50000) {
      throw new Error('æ”¯ä»˜å®å•ç¬”æ”¯ä»˜é‡‘é¢ä¸èƒ½è¶…è¿‡5ä¸‡å…ƒ');
    }
    
    if (!options.userId) {
      throw new Error('æ”¯ä»˜å®æ”¯ä»˜éœ€è¦ç”¨æˆ·ID');
    }
    
    return true;
  }
  
  async pay(amount, options = {}) {
    this.validate(amount, options);
    
    console.log(`ğŸ’° ä½¿ç”¨æ”¯ä»˜å®æ”¯ä»˜ Â¥${amount}`);
    
    // æ¨¡æ‹Ÿæ”¯ä»˜å®APIè°ƒç”¨
    const paymentData = {
      app_id: this.appId,
      method: 'alipay.trade.app.pay',
      charset: 'utf-8',
      sign_type: 'RSA2',
      timestamp: new Date().toISOString(),
      version: '1.0',
      biz_content: JSON.stringify({
        out_trade_no: `alipay_${Date.now()}`,
        total_amount: amount,
        subject: options.subject || 'å•†å“æ”¯ä»˜',
        product_code: 'QUICK_MSECURITY_PAY'
      })
    };
    
    // æ¨¡æ‹Ÿç½‘ç»œè¯·æ±‚
    await this.simulateNetworkRequest(1000, 2000);
    
    // æ¨¡æ‹Ÿæ”¯ä»˜ç»“æœ
    const success = Math.random() > 0.1; // 90% æˆåŠŸç‡
    
    if (success) {
      return {
        success: true,
        transactionId: `alipay_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        amount,
        method: 'alipay',
        timestamp: Date.now(),
        fee: amount * 0.006, // 0.6% æ‰‹ç»­è´¹
        data: paymentData
      };
    } else {
      throw new Error('æ”¯ä»˜å®æ”¯ä»˜å¤±è´¥ï¼šä½™é¢ä¸è¶³æˆ–ç½‘ç»œå¼‚å¸¸');
    }
  }
  
  getInfo() {
    return {
      name: this.name,
      maxAmount: 50000,
      minAmount: 0.01,
      feeRate: 0.006,
      supportedCurrencies: ['CNY'],
      features: ['æ‰«ç æ”¯ä»˜', 'å…å¯†æ”¯ä»˜', 'èŠ±å‘—åˆ†æœŸ']
    };
  }
  
  async simulateNetworkRequest(minDelay, maxDelay) {
    const delay = Math.random() * (maxDelay - minDelay) + minDelay;
    await new Promise(resolve => setTimeout(resolve, delay));
  }
}

// å¾®ä¿¡æ”¯ä»˜ç­–ç•¥
class WechatPayStrategy extends PaymentStrategy {
  constructor(appId, mchId, apiKey) {
    super();
    this.appId = appId;
    this.mchId = mchId;
    this.apiKey = apiKey;
    this.name = 'WechatPay';
  }
  
  validate(amount, options = {}) {
    if (amount <= 0) {
      throw new Error('æ”¯ä»˜é‡‘é¢å¿…é¡»å¤§äº0');
    }
    
    if (amount > 100000) {
      throw new Error('å¾®ä¿¡æ”¯ä»˜å•ç¬”æ”¯ä»˜é‡‘é¢ä¸èƒ½è¶…è¿‡10ä¸‡å…ƒ');
    }
    
    if (!options.openId) {
      throw new Error('å¾®ä¿¡æ”¯ä»˜éœ€è¦ç”¨æˆ·openId');
    }
    
    return true;
  }
  
  async pay(amount, options = {}) {
    this.validate(amount, options);
    
    console.log(`ğŸ’š ä½¿ç”¨å¾®ä¿¡æ”¯ä»˜ Â¥${amount}`);
    
    // æ¨¡æ‹Ÿå¾®ä¿¡æ”¯ä»˜APIè°ƒç”¨
    const paymentData = {
      appid: this.appId,
      mch_id: this.mchId,
      nonce_str: Math.random().toString(36).substr(2, 15),
      body: options.subject || 'å•†å“æ”¯ä»˜',
      out_trade_no: `wxpay_${Date.now()}`,
      total_fee: Math.round(amount * 100), // å¾®ä¿¡æ”¯ä»˜é‡‘é¢å•ä½ä¸ºåˆ†
      spbill_create_ip: '127.0.0.1',
      notify_url: options.notifyUrl || 'https://example.com/notify',
      trade_type: 'JSAPI',
      openid: options.openId
    };
    
    // æ¨¡æ‹Ÿç½‘ç»œè¯·æ±‚
    await this.simulateNetworkRequest(800, 1500);
    
    // æ¨¡æ‹Ÿæ”¯ä»˜ç»“æœ
    const success = Math.random() > 0.05; // 95% æˆåŠŸç‡
    
    if (success) {
      return {
        success: true,
        transactionId: `wxpay_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        amount,
        method: 'wechatpay',
        timestamp: Date.now(),
        fee: amount * 0.006, // 0.6% æ‰‹ç»­è´¹
        data: paymentData
      };
    } else {
      throw new Error('å¾®ä¿¡æ”¯ä»˜å¤±è´¥ï¼šæ”¯ä»˜å¯†ç é”™è¯¯æˆ–ç½‘ç»œå¼‚å¸¸');
    }
  }
  
  getInfo() {
    return {
      name: this.name,
      maxAmount: 100000,
      minAmount: 0.01,
      feeRate: 0.006,
      supportedCurrencies: ['CNY'],
      features: ['æ‰«ç æ”¯ä»˜', 'å…å¯†æ”¯ä»˜', 'çº¢åŒ…', 'è½¬è´¦']
    };
  }
  
  async simulateNetworkRequest(minDelay, maxDelay) {
    const delay = Math.random() * (maxDelay - minDelay) + minDelay;
    await new Promise(resolve => setTimeout(resolve, delay));
  }
}

// é“¶è¡Œå¡æ”¯ä»˜ç­–ç•¥
class BankCardStrategy extends PaymentStrategy {
  constructor(bankCode) {
    super();
    this.bankCode = bankCode;
    this.name = 'BankCard';
  }
  
  validate(amount, options = {}) {
    if (amount <= 0) {
      throw new Error('æ”¯ä»˜é‡‘é¢å¿…é¡»å¤§äº0');
    }
    
    if (amount > 500000) {
      throw new Error('é“¶è¡Œå¡å•ç¬”æ”¯ä»˜é‡‘é¢ä¸èƒ½è¶…è¿‡50ä¸‡å…ƒ');
    }
    
    if (!options.cardNumber || !options.cvv || !options.expiryDate) {
      throw new Error('é“¶è¡Œå¡æ”¯ä»˜éœ€è¦å¡å·ã€CVVå’Œæœ‰æ•ˆæœŸ');
    }
    
    // ç®€å•çš„å¡å·éªŒè¯ï¼ˆLuhnç®—æ³•ï¼‰
    if (!this.validateCardNumber(options.cardNumber)) {
      throw new Error('é“¶è¡Œå¡å·æ ¼å¼ä¸æ­£ç¡®');
    }
    
    return true;
  }
  
  validateCardNumber(cardNumber) {
    const digits = cardNumber.replace(/\D/g, '');
    let sum = 0;
    let isEven = false;
    
    for (let i = digits.length - 1; i >= 0; i--) {
      let digit = parseInt(digits[i]);
      
      if (isEven) {
        digit *= 2;
        if (digit > 9) {
          digit -= 9;
        }
      }
      
      sum += digit;
      isEven = !isEven;
    }
    
    return sum % 10 === 0;
  }
  
  async pay(amount, options = {}) {
    this.validate(amount, options);
    
    console.log(`ğŸ’³ ä½¿ç”¨é“¶è¡Œå¡æ”¯ä»˜ Â¥${amount}`);
    
    // æ¨¡æ‹Ÿé“¶è¡Œæ”¯ä»˜APIè°ƒç”¨
    const paymentData = {
      bank_code: this.bankCode,
      card_number: this.maskCardNumber(options.cardNumber),
      amount: amount,
      currency: 'CNY',
      order_no: `bank_${Date.now()}`,
      timestamp: Date.now()
    };
    
    // æ¨¡æ‹Ÿç½‘ç»œè¯·æ±‚ï¼ˆé“¶è¡Œæ”¯ä»˜é€šå¸¸è¾ƒæ…¢ï¼‰
    await this.simulateNetworkRequest(2000, 5000);
    
    // æ¨¡æ‹Ÿæ”¯ä»˜ç»“æœ
    const success = Math.random() > 0.15; // 85% æˆåŠŸç‡
    
    if (success) {
      return {
        success: true,
        transactionId: `bank_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        amount,
        method: 'bankcard',
        timestamp: Date.now(),
        fee: amount * 0.005, // 0.5% æ‰‹ç»­è´¹
        data: paymentData
      };
    } else {
      throw new Error('é“¶è¡Œå¡æ”¯ä»˜å¤±è´¥ï¼šå¡å†…ä½™é¢ä¸è¶³æˆ–é“¶è¡Œç³»ç»Ÿç»´æŠ¤');
    }
  }
  
  maskCardNumber(cardNumber) {
    const digits = cardNumber.replace(/\D/g, '');
    return digits.replace(/.(?=.{4})/g, '*');
  }
  
  getInfo() {
    return {
      name: this.name,
      maxAmount: 500000,
      minAmount: 0.01,
      feeRate: 0.005,
      supportedCurrencies: ['CNY', 'USD', 'EUR'],
      features: ['åˆ†æœŸä»˜æ¬¾', 'ç§¯åˆ†å…‘æ¢', 'è·¨å¢ƒæ”¯ä»˜']
    };
  }
  
  async simulateNetworkRequest(minDelay, maxDelay) {
    const delay = Math.random() * (maxDelay - minDelay) + minDelay;
    await new Promise(resolve => setTimeout(resolve, delay));
  }
}

// æ”¯ä»˜ä¸Šä¸‹æ–‡
class PaymentContext {
  constructor() {
    this.strategy = null;
    this.history = [];
    this.retryAttempts = 3;
    this.retryDelay = 1000;
  }
  
  setStrategy(strategy) {
    if (!(strategy instanceof PaymentStrategy)) {
      throw new Error('ç­–ç•¥å¿…é¡»å®ç° PaymentStrategy æ¥å£');
    }
    this.strategy = strategy;
    return this;
  }
  
  async pay(amount, options = {}) {
    if (!this.strategy) {
      throw new Error('è¯·å…ˆè®¾ç½®æ”¯ä»˜ç­–ç•¥');
    }
    
    const startTime = Date.now();
    let lastError;
    
    for (let attempt = 1; attempt <= this.retryAttempts; attempt++) {
      try {
        console.log(`ğŸ”„ æ”¯ä»˜å°è¯• ${attempt}/${this.retryAttempts}`);
        
        const result = await this.strategy.pay(amount, options);
        
        // è®°å½•æ”¯ä»˜å†å²
        const paymentRecord = {
          ...result,
          attempt,
          duration: Date.now() - startTime,
          strategy: this.strategy.name
        };
        
        this.history.push(paymentRecord);
        
        console.log(`âœ… æ”¯ä»˜æˆåŠŸ! äº¤æ˜“ID: ${result.transactionId}`);
        console.log(`ğŸ’° æ”¯ä»˜é‡‘é¢: Â¥${result.amount}`);
        console.log(`ğŸ’¸ æ‰‹ç»­è´¹: Â¥${result.fee.toFixed(2)}`);
        console.log(`â±ï¸ è€—æ—¶: ${paymentRecord.duration}ms`);
        
        return result;
        
      } catch (error) {
        lastError = error;
        console.warn(`âŒ æ”¯ä»˜å¤±è´¥ (å°è¯• ${attempt}/${this.retryAttempts}): ${error.message}`);
        
        if (attempt < this.retryAttempts) {
          console.log(`â³ ${this.retryDelay}ms åé‡è¯•...`);
          await new Promise(resolve => setTimeout(resolve, this.retryDelay));
          this.retryDelay *= 1.5; // æŒ‡æ•°é€€é¿
        }
      }
    }
    
    // è®°å½•å¤±è´¥çš„æ”¯ä»˜å°è¯•
    this.history.push({
      success: false,
      amount,
      error: lastError.message,
      attempts: this.retryAttempts,
      duration: Date.now() - startTime,
      strategy: this.strategy.name,
      timestamp: Date.now()
    });
    
    throw new Error(`æ”¯ä»˜å¤±è´¥: ${lastError.message}`);
  }
  
  getStrategyInfo() {
    return this.strategy ? this.strategy.getInfo() : null;
  }
  
  getPaymentHistory() {
    return this.history;
  }
  
  clearHistory() {
    this.history = [];
  }
  
  getSuccessRate() {
    if (this.history.length === 0) return 0;
    
    const successCount = this.history.filter(record => record.success).length;
    return (successCount / this.history.length * 100).toFixed(2);
  }
  
  getTotalAmount() {
    return this.history
      .filter(record => record.success)
      .reduce((total, record) => total + record.amount, 0);
  }
  
  getTotalFees() {
    return this.history
      .filter(record => record.success)
      .reduce((total, record) => total + record.fee, 0);
  }
}

// æ”¯ä»˜ç­–ç•¥å·¥å‚
class PaymentStrategyFactory {
  static strategies = new Map();
  
  static register(name, strategyClass) {
    this.strategies.set(name, strategyClass);
  }
  
  static create(name, ...args) {
    const StrategyClass = this.strategies.get(name);
    if (!StrategyClass) {
      throw new Error(`æœªçŸ¥çš„æ”¯ä»˜ç­–ç•¥: ${name}`);
    }
    return new StrategyClass(...args);
  }
  
  static getAvailableStrategies() {
    return Array.from(this.strategies.keys());
  }
}

// æ³¨å†Œç­–ç•¥
PaymentStrategyFactory.register('alipay', AlipayStrategy);
PaymentStrategyFactory.register('wechatpay', WechatPayStrategy);
PaymentStrategyFactory.register('bankcard', BankCardStrategy);

// ä½¿ç”¨ç¤ºä¾‹
async function strategyDemo() {
  console.log('=== ç­–ç•¥æ¨¡å¼æ”¯ä»˜ç³»ç»Ÿç¤ºä¾‹ ===');
  
  const paymentContext = new PaymentContext();
  
  // æµ‹è¯•æ”¯ä»˜å®æ”¯ä»˜
  console.log('\nğŸ’° æµ‹è¯•æ”¯ä»˜å®æ”¯ä»˜:');
  const alipayStrategy = PaymentStrategyFactory.create('alipay', 'app123', 'private_key');
  console.log('æ”¯ä»˜å®ç­–ç•¥ä¿¡æ¯:', alipayStrategy.getInfo());
  
  paymentContext.setStrategy(alipayStrategy);
  
  try {
    await paymentContext.pay(299.99, {
      userId: 'user123',
      subject: 'è´­ä¹°ä¼šå‘˜å¥—é¤'
    });
  } catch (error) {
    console.error('æ”¯ä»˜å®æ”¯ä»˜å¤±è´¥:', error.message);
  }
  
  // æµ‹è¯•å¾®ä¿¡æ”¯ä»˜
  console.log('\nğŸ’š æµ‹è¯•å¾®ä¿¡æ”¯ä»˜:');
  const wechatStrategy = PaymentStrategyFactory.create('wechatpay', 'wx123', 'mch123', 'key123');
  console.log('å¾®ä¿¡æ”¯ä»˜ç­–ç•¥ä¿¡æ¯:', wechatStrategy.getInfo());
  
  paymentContext.setStrategy(wechatStrategy);
  
  try {
    await paymentContext.pay(199.50, {
      openId: 'openid123',
      subject: 'è´­ä¹°å•†å“',
      notifyUrl: 'https://example.com/wechat/notify'
    });
  } catch (error) {
    console.error('å¾®ä¿¡æ”¯ä»˜å¤±è´¥:', error.message);
  }
  
  // æµ‹è¯•é“¶è¡Œå¡æ”¯ä»˜
  console.log('\nğŸ’³ æµ‹è¯•é“¶è¡Œå¡æ”¯ä»˜:');
  const bankStrategy = PaymentStrategyFactory.create('bankcard', 'ICBC');
  console.log('é“¶è¡Œå¡ç­–ç•¥ä¿¡æ¯:', bankStrategy.getInfo());
  
  paymentContext.setStrategy(bankStrategy);
  
  try {
    await paymentContext.pay(1299.00, {
      cardNumber: '4111111111111111', // æµ‹è¯•å¡å·
      cvv: '123',
      expiryDate: '12/25'
    });
  } catch (error) {
    console.error('é“¶è¡Œå¡æ”¯ä»˜å¤±è´¥:', error.message);
  }
  
  // æ˜¾ç¤ºæ”¯ä»˜ç»Ÿè®¡
  console.log('\nğŸ“Š æ”¯ä»˜ç»Ÿè®¡:');
  console.log(`æˆåŠŸç‡: ${paymentContext.getSuccessRate()}%`);
  console.log(`æ€»æ”¯ä»˜é‡‘é¢: Â¥${paymentContext.getTotalAmount().toFixed(2)}`);
  console.log(`æ€»æ‰‹ç»­è´¹: Â¥${paymentContext.getTotalFees().toFixed(2)}`);
  
  console.log('\nğŸ“‹ æ”¯ä»˜å†å²:');
  paymentContext.getPaymentHistory().forEach((record, index) => {
    if (record.success) {
      console.log(`${index + 1}. âœ… ${record.strategy} - Â¥${record.amount} (${record.duration}ms)`);
    } else {
      console.log(`${index + 1}. âŒ ${record.strategy} - Â¥${record.amount} (${record.error})`);
    }
  });
}

strategyDemo();
```

## ä¸‰ã€å‘½ä»¤æ¨¡å¼ï¼šè¯·æ±‚çš„å°è£…ä¸é˜Ÿåˆ—

### 3.1 ä»€ä¹ˆæ˜¯å‘½ä»¤æ¨¡å¼ï¼Ÿ

å‘½ä»¤æ¨¡å¼å°†è¯·æ±‚å°è£…æˆå¯¹è±¡ï¼Œä»è€Œä½¿ä½ å¯ä»¥ç”¨ä¸åŒçš„è¯·æ±‚å¯¹å®¢æˆ·è¿›è¡Œå‚æ•°åŒ–ï¼Œå¯¹è¯·æ±‚æ’é˜Ÿæˆ–è®°å½•è¯·æ±‚æ—¥å¿—ï¼Œä»¥åŠæ”¯æŒå¯æ’¤é”€çš„æ“ä½œã€‚å°±åƒæ˜¯é¤å…çš„ç‚¹é¤ç³»ç»Ÿï¼ŒæœåŠ¡å‘˜æŠŠé¡¾å®¢çš„è®¢å•å†™åœ¨çº¸ä¸Šï¼Œå¨å¸ˆæŒ‰ç…§è®¢å•åšèœï¼Œé¡¾å®¢è¿˜å¯ä»¥å–æ¶ˆè®¢å•ã€‚

### 3.2 æ–‡æœ¬ç¼–è¾‘å™¨çš„å‘½ä»¤ç³»ç»Ÿ

```javascript
// å‘½ä»¤æ¥å£
class Command {
  execute() {
    throw new Error('execute() æ–¹æ³•å¿…é¡»è¢«å®ç°');
  }
  
  undo() {
    throw new Error('undo() æ–¹æ³•å¿…é¡»è¢«å®ç°');
  }
  
  getDescription() {
    throw new Error('getDescription() æ–¹æ³•å¿…é¡»è¢«å®ç°');
  }
}

// æ–‡æœ¬ç¼–è¾‘å™¨ï¼ˆæ¥æ”¶è€…ï¼‰
class TextEditor {
  constructor() {
    this.content = '';
    this.cursor = 0;
    this.selection = { start: 0, end: 0 };
    this.history = [];
    this.redoStack = [];
  }
  
  // æ’å…¥æ–‡æœ¬
  insertText(text, position = this.cursor) {
    const before = this.content.substring(0, position);
    const after = this.content.substring(position);
    this.content = before + text + after;
    this.cursor = position + text.length;
    this.updateHistory();
  }
  
  // åˆ é™¤æ–‡æœ¬
  deleteText(start, end) {
    const deletedText = this.content.substring(start, end);
    this.content = this.content.substring(0, start) + this.content.substring(end);
    this.cursor = start;
    this.updateHistory();
    return deletedText;
  }
  
  // æ›¿æ¢æ–‡æœ¬
  replaceText(start, end, newText) {
    const oldText = this.content.substring(start, end);
    this.content = this.content.substring(0, start) + newText + this.content.substring(end);
    this.cursor = start + newText.length;
    this.updateHistory();
    return oldText;
  }
  
  // è®¾ç½®é€‰æ‹©åŒºåŸŸ
  setSelection(start, end) {
    this.selection = { start: Math.max(0, start), end: Math.min(this.content.length, end) };
  }
  
  // è·å–é€‰ä¸­çš„æ–‡æœ¬
  getSelectedText() {
    return this.content.substring(this.selection.start, this.selection.end);
  }
  
  // ç§»åŠ¨å…‰æ ‡
  moveCursor(position) {
    this.cursor = Math.max(0, Math.min(this.content.length, position));
  }
  
  // è·å–å½“å‰çŠ¶æ€
  getState() {
    return {
      content: this.content,
      cursor: this.cursor,
      selection: { ...this.selection },
      length: this.content.length
    };
  }
  
  // æ¢å¤çŠ¶æ€
  setState(state) {
    this.content = state.content;
    this.cursor = state.cursor;
    this.selection = { ...state.selection };
  }
  
  // æ›´æ–°å†å²è®°å½•
  updateHistory() {
    this.history.push(this.getState());
    if (this.history.length > 100) {
      this.history.shift();
    }
  }
  
  // æŸ¥æ‰¾æ–‡æœ¬
  findText(searchText, startFrom = 0) {
    const index = this.content.indexOf(searchText, startFrom);
    if (index !== -1) {
      this.setSelection(index, index + searchText.length);
      this.cursor = index;
      return { found: true, position: index };
    }
    return { found: false, position: -1 };
  }
  
  // è·å–ç»Ÿè®¡ä¿¡æ¯
  getStats() {
    const words = this.content.trim().split(/\s+/).filter(word => word.length > 0);
    const lines = this.content.split('\n');
    
    return {
      characters: this.content.length,
      charactersNoSpaces: this.content.replace(/\s/g, '').length,
      words: words.length,
      lines: lines.length,
      paragraphs: this.content.split(/\n\s*\n/).filter(p => p.trim().length > 0).length
    };
  }
}

// å…·ä½“å‘½ä»¤å®ç°
class InsertTextCommand extends Command {
  constructor(editor, text, position) {
    super();
    this.editor = editor;
    this.text = text;
    this.position = position !== undefined ? position : editor.cursor;
    this.previousState = null;
  }
  
  execute() {
    this.previousState = this.editor.getState();
    this.editor.insertText(this.text, this.position);
  }
  
  undo() {
    if (this.previousState) {
      this.editor.setState(this.previousState);
    }
  }
  
  getDescription() {
    return `æ’å…¥æ–‡æœ¬: "${this.text.substring(0, 20)}${this.text.length > 20 ? '...' : ''}"`;
  }
}

class DeleteTextCommand extends Command {
  constructor(editor, start, end) {
    super();
    this.editor = editor;
    this.start = start;
    this.end = end;
    this.deletedText = '';
    this.previousState = null;
  }
  
  execute() {
    this.previousState = this.editor.getState();
    this.deletedText = this.editor.deleteText(this.start, this.end);
  }
  
  undo() {
    if (this.previousState) {
      this.editor.setState(this.previousState);
    }
  }
  
  getDescription() {
    return `åˆ é™¤æ–‡æœ¬: "${this.deletedText.substring(0, 20)}${this.deletedText.length > 20 ? '...' : ''}"`;
  }
}

class ReplaceTextCommand extends Command {
  constructor(editor, start, end, newText) {
    super();
    this.editor = editor;
    this.start = start;
    this.end = end;
    this.newText = newText;
    this.oldText = '';
    this.previousState = null;
  }
  
  execute() {
    this.previousState = this.editor.getState();
    this.oldText = this.editor.replaceText(this.start, this.end, this.newText);
  }
  
  undo() {
    if (this.previousState) {
      this.editor.setState(this.previousState);
    }
  }
  
  getDescription() {
    return `æ›¿æ¢æ–‡æœ¬: "${this.oldText}" â†’ "${this.newText}"`;
  }
}

class FindReplaceCommand extends Command {
  constructor(editor, searchText, replaceText, replaceAll = false) {
    super();
    this.editor = editor;
    this.searchText = searchText;
    this.replaceText = replaceText;
    this.replaceAll = replaceAll;
    this.replacements = [];
    this.previousState = null;
  }
  
  execute() {
    this.previousState = this.editor.getState();
    this.replacements = [];
    
    if (this.replaceAll) {
      let content = this.editor.content;
      let offset = 0;
      
      while (true) {
        const index = content.indexOf(this.searchText, offset);
        if (index === -1) break;
        
        this.replacements.push({
          position: index,
          oldText: this.searchText,
          newText: this.replaceText
        });
        
        content = content.substring(0, index) + this.replaceText + content.substring(index + this.searchText.length);
        offset = index + this.replaceText.length;
      }
      
      this.editor.content = content;
      this.editor.cursor = 0;
    } else {
      const result = this.editor.findText(this.searchText);
      if (result.found) {
        this.replacements.push({
          position: result.position,
          oldText: this.searchText,
          newText: this.replaceText
        });
        
        this.editor.replaceText(result.position, result.position + this.searchText.length, this.replaceText);
      }
    }
  }
  
  undo() {
    if (this.previousState) {
      this.editor.setState(this.previousState);
    }
  }
  
  getDescription() {
    const action = this.replaceAll ? 'å…¨éƒ¨æ›¿æ¢' : 'æ›¿æ¢';
    return `${action}: "${this.searchText}" â†’ "${this.replaceText}" (${this.replacements.length}å¤„)`;
  }
}

// å®å‘½ä»¤ï¼ˆç»„åˆå‘½ä»¤ï¼‰
class MacroCommand extends Command {
  constructor(commands = []) {
    super();
    this.commands = commands;
    this.executed = false;
  }
  
  addCommand(command) {
    this.commands.push(command);
  }
  
  execute() {
    for (const command of this.commands) {
      command.execute();
    }
    this.executed = true;
  }
  
  undo() {
    if (this.executed) {
      // é€†åºæ’¤é”€
      for (let i = this.commands.length - 1; i >= 0; i--) {
        this.commands[i].undo();
      }
      this.executed = false;
    }
  }
  
  getDescription() {
    return `å®å‘½ä»¤ (${this.commands.length}ä¸ªæ“ä½œ): ${this.commands.map(cmd => cmd.getDescription()).join(', ')}`;
  }
}

// å‘½ä»¤è°ƒç”¨è€…ï¼ˆç¼–è¾‘å™¨æ§åˆ¶å™¨ï¼‰
class EditorController {
  constructor(editor) {
    this.editor = editor;
    this.commandHistory = [];
    this.currentIndex = -1;
    this.maxHistorySize = 100;
  }
  
  // æ‰§è¡Œå‘½ä»¤
  executeCommand(command) {
    // æ¸…é™¤å½“å‰ä½ç½®ä¹‹åçš„å†å²è®°å½•ï¼ˆç”¨äºé‡åšï¼‰
    this.commandHistory = this.commandHistory.slice(0, this.currentIndex + 1);
    
    // æ‰§è¡Œå‘½ä»¤
    command.execute();
    
    // æ·»åŠ åˆ°å†å²è®°å½•
    this.commandHistory.push(command);
    this.currentIndex++;
    
    // é™åˆ¶å†å²è®°å½•å¤§å°
    if (this.commandHistory.length > this.maxHistorySize) {
      this.commandHistory.shift();
      this.currentIndex--;
    }
    
    console.log(`âœ… æ‰§è¡Œ: ${command.getDescription()}`);
  }
  
  // æ’¤é”€
  undo() {
    if (this.canUndo()) {
      const command = this.commandHistory[this.currentIndex];
      command.undo();
      this.currentIndex--;
      console.log(`â†¶ æ’¤é”€: ${command.getDescription()}`);
      return true;
    }
    console.log('âŒ æ— æ³•æ’¤é”€');
    return false;
  }
  
  // é‡åš
  redo() {
    if (this.canRedo()) {
      this.currentIndex++;
      const command = this.commandHistory[this.currentIndex];
      command.execute();
      console.log(`â†· é‡åš: ${command.getDescription()}`);
      return true;
    }
    console.log('âŒ æ— æ³•é‡åš');
    return false;
  }
  
  // æ£€æŸ¥æ˜¯å¦å¯ä»¥æ’¤é”€
  canUndo() {
    return this.currentIndex >= 0;
  }
  
  // æ£€æŸ¥æ˜¯å¦å¯ä»¥é‡åš
  canRedo() {
    return this.currentIndex < this.commandHistory.length - 1;
  }
  
  // è·å–å†å²è®°å½•
  getHistory() {
    return this.commandHistory.map((command, index) => ({
      index,
      description: command.getDescription(),
      executed: index <= this.currentIndex
    }));
  }
  
  // æ¸…é™¤å†å²è®°å½•
  clearHistory() {
    this.commandHistory = [];
    this.currentIndex = -1;
  }
  
  // æ‰¹é‡æ‰§è¡Œå‘½ä»¤
  executeBatch(commands) {
    const macro = new MacroCommand(commands);
    this.executeCommand(macro);
  }
  
  // åˆ›å»ºå¿«ç…§
  createSnapshot() {
    return {
      editorState: this.editor.getState(),
      historyIndex: this.currentIndex,
      timestamp: Date.now()
    };
  }
  
  // æ¢å¤å¿«ç…§
  restoreSnapshot(snapshot) {
    this.editor.setState(snapshot.editorState);
    this.currentIndex = snapshot.historyIndex;
    console.log(`ğŸ“¸ æ¢å¤å¿«ç…§: ${new Date(snapshot.timestamp).toLocaleString()}`);
  }
}

// ä½¿ç”¨ç¤ºä¾‹
function commandDemo() {
  console.log('=== å‘½ä»¤æ¨¡å¼æ–‡æœ¬ç¼–è¾‘å™¨ç¤ºä¾‹ ===');
  
  const editor = new TextEditor();
  const controller = new EditorController(editor);
  
  // æ‰§è¡Œä¸€ç³»åˆ—ç¼–è¾‘æ“ä½œ
  console.log('\nğŸ“ æ‰§è¡Œç¼–è¾‘æ“ä½œ:');
  
  controller.executeCommand(new InsertTextCommand(editor, 'Hello, World!'));
  console.log('å½“å‰å†…å®¹:', `"${editor.content}"`);
  
  controller.executeCommand(new InsertTextCommand(editor, '\nè¿™æ˜¯ç¬¬äºŒè¡Œã€‚'));
  console.log('å½“å‰å†…å®¹:', `"${editor.content}"`);
  
  controller.executeCommand(new InsertTextCommand(editor, '\nè¿™æ˜¯ç¬¬ä¸‰è¡Œï¼ŒåŒ…å«ä¸€äº›é”™è¯¯çš„æ–‡å­—ã€‚'));
  console.log('å½“å‰å†…å®¹:', `"${editor.content}"`);
  
  // æŸ¥æ‰¾å¹¶æ›¿æ¢
  controller.executeCommand(new FindReplaceCommand(editor, 'é”™è¯¯çš„', 'æ­£ç¡®çš„'));
  console.log('æ›¿æ¢åå†…å®¹:', `"${editor.content}"`);
  
  // åˆ é™¤éƒ¨åˆ†æ–‡æœ¬
  editor.setSelection(0, 5); // é€‰ä¸­ "Hello"
  controller.executeCommand(new DeleteTextCommand(editor, editor.selection.start, editor.selection.end));
  console.log('åˆ é™¤åå†…å®¹:', `"${editor.content}"`);
  
  // æµ‹è¯•æ’¤é”€å’Œé‡åš
  console.log('\nâ†¶ æµ‹è¯•æ’¤é”€æ“ä½œ:');
  controller.undo(); // æ’¤é”€åˆ é™¤
  console.log('æ’¤é”€åˆ é™¤å:', `"${editor.content}"`);
  
  controller.undo(); // æ’¤é”€æ›¿æ¢
  console.log('æ’¤é”€æ›¿æ¢å:', `"${editor.content}"`);
  
  controller.undo(); // æ’¤é”€æ’å…¥ç¬¬ä¸‰è¡Œ
  console.log('æ’¤é”€æ’å…¥å:', `"${editor.content}"`);
  
  console.log('\nâ†· æµ‹è¯•é‡åšæ“ä½œ:');
  controller.redo(); // é‡åšæ’å…¥ç¬¬ä¸‰è¡Œ
  console.log('é‡åšæ’å…¥å:', `"${editor.content}"`);
  
  controller.redo(); // é‡åšæ›¿æ¢
  console.log('é‡åšæ›¿æ¢å:', `"${editor.content}"`);
  
  // æ‰¹é‡æ“ä½œï¼ˆå®å‘½ä»¤ï¼‰
  console.log('\nğŸ”„ æµ‹è¯•æ‰¹é‡æ“ä½œ:');
  const batchCommands = [
    new InsertTextCommand(editor, '\n\n--- æ‰¹é‡æ“ä½œå¼€å§‹ ---'),
    new InsertTextCommand(editor, '\nç¬¬ä¸€ä¸ªæ‰¹é‡æ’å…¥'),
    new InsertTextCommand(editor, '\nç¬¬äºŒä¸ªæ‰¹é‡æ’å…¥'),
    new FindReplaceCommand(editor, 'æ‰¹é‡', 'å®å‘½ä»¤', true)
  ];
  
  controller.executeBatch(batchCommands);
  console.log('æ‰¹é‡æ“ä½œå:', `"${editor.content}"`);
  
  // æ’¤é”€æ•´ä¸ªæ‰¹é‡æ“ä½œ
  controller.undo();
  console.log('æ’¤é”€æ‰¹é‡æ“ä½œå:', `"${editor.content}"`);
  
  // æ˜¾ç¤ºç¼–è¾‘å™¨ç»Ÿè®¡ä¿¡æ¯
  console.log('\nğŸ“Š ç¼–è¾‘å™¨ç»Ÿè®¡:');
  const stats = editor.getStats();
  console.log(`å­—ç¬¦æ•°: ${stats.characters}`);
  console.log(`å•è¯æ•°: ${stats.words}`);
  console.log(`è¡Œæ•°: ${stats.lines}`);
  console.log(`æ®µè½æ•°: ${stats.paragraphs}`);
  
  // æ˜¾ç¤ºå‘½ä»¤å†å²
  console.log('\nğŸ“œ å‘½ä»¤å†å²:');
  const history = controller.getHistory();
  history.forEach(item => {
    const status = item.executed ? 'âœ…' : 'â¸ï¸';
    console.log(`${status} ${item.index + 1}. ${item.description}`);
  });
}

commandDemo();
```

## å››ã€çŠ¶æ€æ¨¡å¼ï¼šå¯¹è±¡çŠ¶æ€çš„ä¼˜é›…è½¬æ¢

### 4.1 ä»€ä¹ˆæ˜¯çŠ¶æ€æ¨¡å¼ï¼Ÿ

çŠ¶æ€æ¨¡å¼å…è®¸å¯¹è±¡åœ¨å†…éƒ¨çŠ¶æ€æ”¹å˜æ—¶æ”¹å˜å®ƒçš„è¡Œä¸ºï¼Œå¯¹è±¡çœ‹èµ·æ¥å¥½åƒä¿®æ”¹äº†å®ƒçš„ç±»ã€‚è¿™ä¸ªæ¨¡å¼å°†çŠ¶æ€å°è£…æˆç‹¬ç«‹çš„ç±»ï¼Œå¹¶å°†åŠ¨ä½œå§”æ‰˜åˆ°ä»£è¡¨å½“å‰çŠ¶æ€çš„å¯¹è±¡ã€‚å°±åƒæ˜¯ä¸€ä¸ªäººçš„æƒ…ç»ªçŠ¶æ€ï¼šå¼€å¿ƒæ—¶ä¼šç¬‘ï¼Œéš¾è¿‡æ—¶ä¼šå“­ï¼Œæ„¤æ€’æ—¶ä¼šå‘è„¾æ°”ã€‚

### 4.2 éŸ³ä¹æ’­æ”¾å™¨çš„çŠ¶æ€ç®¡ç†

```javascript
// çŠ¶æ€æ¥å£
class PlayerState {
  constructor(player) {
    this.player = player;
  }
  
  play() {
    throw new Error('play() æ–¹æ³•å¿…é¡»è¢«å®ç°');
  }
  
  pause() {
    throw new Error('pause() æ–¹æ³•å¿…é¡»è¢«å®ç°');
  }
  
  stop() {
    throw new Error('stop() æ–¹æ³•å¿…é¡»è¢«å®ç°');
  }
  
  next() {
    throw new Error('next() æ–¹æ³•å¿…é¡»è¢«å®ç°');
  }
  
  previous() {
    throw new Error('previous() æ–¹æ³•å¿…é¡»è¢«å®ç°');
  }
  
  setVolume(volume) {
    throw new Error('setVolume() æ–¹æ³•å¿…é¡»è¢«å®ç°');
  }
  
  getName() {
    throw new Error('getName() æ–¹æ³•å¿…é¡»è¢«å®ç°');
  }
  
  getAvailableActions() {
    throw new Error('getAvailableActions() æ–¹æ³•å¿…é¡»è¢«å®ç°');
  }
}

// åœæ­¢çŠ¶æ€
class StoppedState extends PlayerState {
  play() {
    console.log('â–¶ï¸ å¼€å§‹æ’­æ”¾éŸ³ä¹');
    this.player.startPlayback();
    this.player.setState(this.player.playingState);
  }
  
  pause() {
    console.log('âš ï¸ æ’­æ”¾å™¨å·²åœæ­¢ï¼Œæ— æ³•æš‚åœ');
  }
  
  stop() {
    console.log('âš ï¸ æ’­æ”¾å™¨å·²ç»æ˜¯åœæ­¢çŠ¶æ€');
  }
  
  next() {
    console.log('â­ï¸ åˆ‡æ¢åˆ°ä¸‹ä¸€é¦–ï¼ˆä»åœæ­¢çŠ¶æ€ï¼‰');
    this.player.nextTrack();
    // åˆ‡æ¢æ­Œæ›²åè‡ªåŠ¨æ’­æ”¾
    this.play();
  }
  
  previous() {
    console.log('â®ï¸ åˆ‡æ¢åˆ°ä¸Šä¸€é¦–ï¼ˆä»åœæ­¢çŠ¶æ€ï¼‰');
    this.player.previousTrack();
    // åˆ‡æ¢æ­Œæ›²åè‡ªåŠ¨æ’­æ”¾
    this.play();
  }
  
  setVolume(volume) {
    console.log(`ğŸ”Š è®¾ç½®éŸ³é‡: ${volume}%`);
    this.player.volume = volume;
  }
  
  getName() {
    return 'Stopped';
  }
  
  getAvailableActions() {
    return ['play', 'next', 'previous', 'setVolume'];
  }
}

// æ’­æ”¾çŠ¶æ€
class PlayingState extends PlayerState {
  play() {
    console.log('âš ï¸ éŸ³ä¹å·²åœ¨æ’­æ”¾ä¸­');
  }
  
  pause() {
    console.log('â¸ï¸ æš‚åœæ’­æ”¾');
    this.player.pausePlayback();
    this.player.setState(this.player.pausedState);
  }
  
  stop() {
    console.log('â¹ï¸ åœæ­¢æ’­æ”¾');
    this.player.stopPlayback();
    this.player.setState(this.player.stoppedState);
  }
  
  next() {
    console.log('â­ï¸ åˆ‡æ¢åˆ°ä¸‹ä¸€é¦–');
    this.player.nextTrack();
    this.player.startPlayback();
    // ä¿æŒæ’­æ”¾çŠ¶æ€
  }
  
  previous() {
    console.log('â®ï¸ åˆ‡æ¢åˆ°ä¸Šä¸€é¦–');
    this.player.previousTrack();
    this.player.startPlayback();
    // ä¿æŒæ’­æ”¾çŠ¶æ€
  }
  
  setVolume(volume) {
    console.log(`ğŸ”Š è°ƒæ•´æ’­æ”¾éŸ³é‡: ${volume}%`);
    this.player.volume = volume;
    this.player.updatePlaybackVolume();
  }
  
  getName() {
    return 'Playing';
  }
  
  getAvailableActions() {
    return ['pause', 'stop', 'next', 'previous', 'setVolume'];
  }
}

// æš‚åœçŠ¶æ€
class PausedState extends PlayerState {
  play() {
    console.log('â–¶ï¸ æ¢å¤æ’­æ”¾');
    this.player.resumePlayback();
    this.player.setState(this.player.playingState);
  }
  
  pause() {
    console.log('âš ï¸ éŸ³ä¹å·²æš‚åœ');
  }
  
  stop() {
    console.log('â¹ï¸ åœæ­¢æ’­æ”¾');
    this.player.stopPlayback();
    this.player.setState(this.player.stoppedState);
  }
  
  next() {
    console.log('â­ï¸ åˆ‡æ¢åˆ°ä¸‹ä¸€é¦–ï¼ˆä»æš‚åœçŠ¶æ€ï¼‰');
    this.player.nextTrack();
    this.player.startPlayback();
    this.player.setState(this.player.playingState);
  }
  
  previous() {
    console.log('â®ï¸ åˆ‡æ¢åˆ°ä¸Šä¸€é¦–ï¼ˆä»æš‚åœçŠ¶æ€ï¼‰');
    this.player.previousTrack();
    this.player.startPlayback();
    this.player.setState(this.player.playingState);
  }
  
  setVolume(volume) {
    console.log(`ğŸ”Š è®¾ç½®éŸ³é‡: ${volume}%`);
    this.player.volume = volume;
  }
  
  getName() {
    return 'Paused';
  }
  
  getAvailableActions() {
    return ['play', 'stop', 'next', 'previous', 'setVolume'];
  }
}

// åŠ è½½çŠ¶æ€
class LoadingState extends PlayerState {
  constructor(player) {
    super(player);
    this.loadingStartTime = Date.now();
  }
  
  play() {
    console.log('âš ï¸ æ­£åœ¨åŠ è½½ä¸­ï¼Œè¯·ç¨å€™...');
  }
  
  pause() {
    console.log('âš ï¸ æ­£åœ¨åŠ è½½ä¸­ï¼Œæ— æ³•æš‚åœ');
  }
  
  stop() {
    console.log('â¹ï¸ å–æ¶ˆåŠ è½½');
    this.player.cancelLoading();
    this.player.setState(this.player.stoppedState);
  }
  
  next() {
    console.log('âš ï¸ æ­£åœ¨åŠ è½½ä¸­ï¼Œè¯·ç¨å€™...');
  }
  
  previous() {
    console.log('âš ï¸ æ­£åœ¨åŠ è½½ä¸­ï¼Œè¯·ç¨å€™...');
  }
  
  setVolume(volume) {
    console.log(`ğŸ”Š è®¾ç½®éŸ³é‡: ${volume}%`);
    this.player.volume = volume;
  }
  
  getName() {
    return 'Loading';
  }
  
  getAvailableActions() {
    return ['stop', 'setVolume'];
  }
  
  getLoadingDuration() {
    return Date.now() - this.loadingStartTime;
  }
}

// é”™è¯¯çŠ¶æ€
class ErrorState extends PlayerState {
  constructor(player, error) {
    super(player);
    this.error = error;
    this.errorTime = Date.now();
  }
  
  play() {
    console.log('ğŸ”„ å°è¯•é‡æ–°æ’­æ”¾...');
    this.player.retry();
  }
  
  pause() {
    console.log('âš ï¸ æ’­æ”¾å™¨å‡ºé”™ï¼Œæ— æ³•æš‚åœ');
  }
  
  stop() {
    console.log('â¹ï¸ åœæ­¢æ’­æ”¾ï¼ˆæ¸…é™¤é”™è¯¯çŠ¶æ€ï¼‰');
    this.player.clearError();
    this.player.setState(this.player.stoppedState);
  }
  
  next() {
    console.log('â­ï¸ å°è¯•æ’­æ”¾ä¸‹ä¸€é¦–');
    this.player.nextTrack();
    this.player.retry();
  }
  
  previous() {
    console.log('â®ï¸ å°è¯•æ’­æ”¾ä¸Šä¸€é¦–');
    this.player.previousTrack();
    this.player.retry();
  }
  
  setVolume(volume) {
    console.log(`ğŸ”Š è®¾ç½®éŸ³é‡: ${volume}%`);
    this.player.volume = volume;
  }
  
  getName() {
    return 'Error';
  }
  
  getAvailableActions() {
    return ['play', 'stop', 'next', 'previous', 'setVolume'];
  }
  
  getError() {
    return this.error;
  }
  
  getErrorDuration() {
    return Date.now() - this.errorTime;
  }
}

// éŸ³ä¹æ’­æ”¾å™¨ä¸Šä¸‹æ–‡
class MusicPlayer {
  constructor() {
    // åˆå§‹åŒ–æ‰€æœ‰çŠ¶æ€
    this.stoppedState = new StoppedState(this);
    this.playingState = new PlayingState(this);
    this.pausedState = new PausedState(this);
    this.loadingState = null; // åŠ¨æ€åˆ›å»º
    this.errorState = null; // åŠ¨æ€åˆ›å»º
    
    // è®¾ç½®åˆå§‹çŠ¶æ€
    this.currentState = this.stoppedState;
    
    // æ’­æ”¾å™¨å±æ€§
    this.playlist = [];
    this.currentTrackIndex = 0;
    this.volume = 50;
    this.position = 0;
    this.duration = 0;
    
    // äº‹ä»¶ç›‘å¬å™¨
    this.listeners = new Map();
    
    // æ’­æ”¾å†å²
    this.playHistory = [];
    this.stateHistory = [];
    
    // æ’­æ”¾ç»Ÿè®¡
    this.stats = {
      totalPlayTime: 0,
      tracksPlayed: 0,
      stateChanges: 0
    };
  }
  
  // è®¾ç½®çŠ¶æ€
  setState(state) {
    const oldState = this.currentState;
    this.currentState = state;
    
    // è®°å½•çŠ¶æ€å˜åŒ–
    this.stateHistory.push({
      from: oldState.getName(),
      to: state.getName(),
      timestamp: Date.now()
    });
    
    this.stats.stateChanges++;
    
    console.log(`ğŸ”„ çŠ¶æ€å˜åŒ–: ${oldState.getName()} â†’ ${state.getName()}`);
    
    // è§¦å‘çŠ¶æ€å˜åŒ–äº‹ä»¶
    this.emit('stateChange', {
      oldState: oldState.getName(),
      newState: state.getName(),
      player: this
    });
  }
  
  // å§”æ‰˜æ–¹æ³•åˆ°å½“å‰çŠ¶æ€
  play() {
    this.currentState.play();
  }
  
  pause() {
    this.currentState.pause();
  }
  
  stop() {
    this.currentState.stop();
  }
  
  next() {
    this.currentState.next();
  }
  
  previous() {
    this.currentState.previous();
  }
  
  setVolume(volume) {
    this.currentState.setVolume(Math.max(0, Math.min(100, volume)));
  }
  
  // æ’­æ”¾å™¨å†…éƒ¨æ–¹æ³•
  startPlayback() {
    if (this.playlist.length === 0) {
      this.handleError(new Error('æ’­æ”¾åˆ—è¡¨ä¸ºç©º'));
      return;
    }
    
    const track = this.getCurrentTrack();
    console.log(`ğŸµ å¼€å§‹æ’­æ”¾: ${track.title} - ${track.artist}`);
    
    // æ¨¡æ‹ŸåŠ è½½è¿‡ç¨‹
    this.loadingState = new LoadingState(this);
    this.setState(this.loadingState);
    
    // æ¨¡æ‹Ÿå¼‚æ­¥åŠ è½½
    setTimeout(() => {
      if (this.currentState === this.loadingState) {
        this.position = 0;
        this.duration = track.duration;
        this.setState(this.playingState);
        
        // è®°å½•æ’­æ”¾å†å²
        this.playHistory.push({
          track: { ...track },
          startTime: Date.now(),
          completed: false
        });
        
        this.stats.tracksPlayed++;
        this.emit('trackStart', track);
      }
    }, Math.random() * 2000 + 500); // 0.5-2.5ç§’åŠ è½½æ—¶é—´
  }
  
  pausePlayback() {
    console.log('â¸ï¸ æ’­æ”¾å·²æš‚åœ');
    this.emit('trackPause', this.getCurrentTrack());
  }
  
  resumePlayback() {
    console.log('â–¶ï¸ æ’­æ”¾å·²æ¢å¤');
    this.emit('trackResume', this.getCurrentTrack());
  }
  
  stopPlayback() {
    console.log('â¹ï¸ æ’­æ”¾å·²åœæ­¢');
    this.position = 0;
    
    // æ›´æ–°æ’­æ”¾å†å²
    if (this.playHistory.length > 0) {
      const lastPlay = this.playHistory[this.playHistory.length - 1];
      if (!lastPlay.completed) {
        lastPlay.endTime = Date.now();
        lastPlay.playDuration = lastPlay.endTime - lastPlay.startTime;
        this.stats.totalPlayTime += lastPlay.playDuration;
      }
    }
    
    this.emit('trackStop', this.getCurrentTrack());
  }
  
  nextTrack() {
    if (this.playlist.length === 0) return;
    
    this.currentTrackIndex = (this.currentTrackIndex + 1) % this.playlist.length;
    const track = this.getCurrentTrack();
    console.log(`â­ï¸ ä¸‹ä¸€é¦–: ${track.title} - ${track.artist}`);
    this.emit('trackChange', track);
  }
  
  previousTrack() {
    if (this.playlist.length === 0) return;
    
    this.currentTrackIndex = this.currentTrackIndex === 0 
      ? this.playlist.length - 1 
      : this.currentTrackIndex - 1;
    
    const track = this.getCurrentTrack();
    console.log(`â®ï¸ ä¸Šä¸€é¦–: ${track.title} - ${track.artist}`);
    this.emit('trackChange', track);
  }
  
  updatePlaybackVolume() {
    console.log(`ğŸ”Š æ’­æ”¾éŸ³é‡å·²è°ƒæ•´ä¸º: ${this.volume}%`);
    this.emit('volumeChange', this.volume);
  }
  
  cancelLoading() {
    console.log('âŒ å–æ¶ˆåŠ è½½');
  }
  
  retry() {
    console.log('ğŸ”„ é‡è¯•æ’­æ”¾...');
    this.startPlayback();
  }
  
  clearError() {
    console.log('âœ… é”™è¯¯å·²æ¸…é™¤');
    this.errorState = null;
  }
  
  handleError(error) {
    console.error(`âŒ æ’­æ”¾å™¨é”™è¯¯: ${error.message}`);
    this.errorState = new ErrorState(this, error);
    this.setState(this.errorState);
    this.emit('error', error);
  }
  
  // æ’­æ”¾åˆ—è¡¨ç®¡ç†
  setPlaylist(tracks) {
    this.playlist = tracks;
    this.currentTrackIndex = 0;
    console.log(`ğŸ“‹ æ’­æ”¾åˆ—è¡¨å·²æ›´æ–° (${tracks.length} é¦–æ­Œæ›²)`);
    this.emit('playlistChange', tracks);
  }
  
  addTrack(track) {
    this.playlist.push(track);
    console.log(`â• æ·»åŠ æ­Œæ›²: ${track.title} - ${track.artist}`);
    this.emit('trackAdd', track);
  }
  
  removeTrack(index) {
    if (index >= 0 && index < this.playlist.length) {
      const removedTrack = this.playlist.splice(index, 1)[0];
      
      // è°ƒæ•´å½“å‰æ’­æ”¾ç´¢å¼•
      if (index < this.currentTrackIndex) {
        this.currentTrackIndex--;
      } else if (index === this.currentTrackIndex) {
        if (this.currentTrackIndex >= this.playlist.length) {
          this.currentTrackIndex = 0;
        }
        // å¦‚æœæ­£åœ¨æ’­æ”¾è¢«åˆ é™¤çš„æ­Œæ›²ï¼Œåœæ­¢æ’­æ”¾
        if (this.currentState !== this.stoppedState) {
          this.stop();
        }
      }
      
      console.log(`â– ç§»é™¤æ­Œæ›²: ${removedTrack.title} - ${removedTrack.artist}`);
      this.emit('trackRemove', removedTrack);
      return removedTrack;
    }
    return null;
  }
  
  getCurrentTrack() {
    return this.playlist[this.currentTrackIndex] || null;
  }
  
  // è·å–æ’­æ”¾å™¨çŠ¶æ€ä¿¡æ¯
  getStatus() {
    const currentTrack = this.getCurrentTrack();
    return {
      state: this.currentState.getName(),
      availableActions: this.currentState.getAvailableActions(),
      currentTrack: currentTrack ? {
        title: currentTrack.title,
        artist: currentTrack.artist,
        duration: currentTrack.duration
      } : null,
      trackIndex: this.currentTrackIndex,
      playlistLength: this.playlist.length,
      volume: this.volume,
      position: this.position,
      duration: this.duration
    };
  }
  
  // è·å–æ’­æ”¾ç»Ÿè®¡
  getStats() {
    return {
      ...this.stats,
      totalPlayTimeFormatted: this.formatDuration(this.stats.totalPlayTime),
      averagePlayTime: this.stats.tracksPlayed > 0 
        ? Math.round(this.stats.totalPlayTime / this.stats.tracksPlayed)
        : 0
    };
  }
  
  // è·å–çŠ¶æ€å†å²
  getStateHistory() {
    return this.stateHistory.map(entry => ({
      ...entry,
      timestampFormatted: new Date(entry.timestamp).toLocaleTimeString()
    }));
  }
  
  // è·å–æ’­æ”¾å†å²
  getPlayHistory() {
    return this.playHistory.map(entry => ({
      ...entry,
      startTimeFormatted: new Date(entry.startTime).toLocaleTimeString(),
      endTimeFormatted: entry.endTime ? new Date(entry.endTime).toLocaleTimeString() : null,
      playDurationFormatted: entry.playDuration ? this.formatDuration(entry.playDuration) : null
    }));
  }
  
  // äº‹ä»¶ç³»ç»Ÿ
  on(event, listener) {
    if (!this.listeners.has(event)) {
      this.listeners.set(event, new Set());
    }
    this.listeners.get(event).add(listener);
  }
  
  off(event, listener) {
    if (this.listeners.has(event)) {
      this.listeners.get(event).delete(listener);
    }
  }
  
  emit(event, data) {
    if (this.listeners.has(event)) {
      for (const listener of this.listeners.get(event)) {
        try {
          listener(data);
        } catch (error) {
          console.error(`äº‹ä»¶ç›‘å¬å™¨é”™è¯¯ (${event}):`, error);
        }
      }
    }
  }
  
  // å·¥å…·æ–¹æ³•
  formatDuration(ms) {
    const seconds = Math.floor(ms / 1000);
    const minutes = Math.floor(seconds / 60);
    const hours = Math.floor(minutes / 60);
    
    if (hours > 0) {
      return `${hours}:${(minutes % 60).toString().padStart(2, '0')}:${(seconds % 60).toString().padStart(2, '0')}`;
    } else {
      return `${minutes}:${(seconds % 60).toString().padStart(2, '0')}`;
    }
  }
}

// ä½¿ç”¨ç¤ºä¾‹
function stateDemo() {
  console.log('=== çŠ¶æ€æ¨¡å¼éŸ³ä¹æ’­æ”¾å™¨ç¤ºä¾‹ ===');
  
  const player = new MusicPlayer();
  
  // æ·»åŠ äº‹ä»¶ç›‘å¬å™¨
  player.on('stateChange', (data) => {
    console.log(`ğŸ“¡ çŠ¶æ€å˜åŒ–äº‹ä»¶: ${data.oldState} â†’ ${data.newState}`);
  });
  
  player.on('trackStart', (track) => {
    console.log(`ğŸµ å¼€å§‹æ’­æ”¾äº‹ä»¶: ${track.title}`);
  });
  
  player.on('error', (error) => {
    console.log(`ğŸš¨ é”™è¯¯äº‹ä»¶: ${error.message}`);
  });
  
  // è®¾ç½®æ’­æ”¾åˆ—è¡¨
  const playlist = [
    { title: 'å¤œæ›²', artist: 'å‘¨æ°ä¼¦', duration: 240000 },
    { title: 'é’èŠ±ç“·', artist: 'å‘¨æ°ä¼¦', duration: 228000 },
    { title: 'ç¨»é¦™', artist: 'å‘¨æ°ä¼¦', duration: 223000 },
    { title: 'å‘Šç™½æ°”çƒ', artist: 'å‘¨æ°ä¼¦', duration: 207000 }
  ];
  
  player.setPlaylist(playlist);
  
  // æ˜¾ç¤ºåˆå§‹çŠ¶æ€
  console.log('\nğŸ“Š åˆå§‹çŠ¶æ€:');
  console.log(player.getStatus());
  
  // æµ‹è¯•çŠ¶æ€è½¬æ¢
  console.log('\nğŸ® æµ‹è¯•æ’­æ”¾å™¨æ“ä½œ:');
  
  // å°è¯•åœ¨åœæ­¢çŠ¶æ€ä¸‹æš‚åœï¼ˆæ— æ•ˆæ“ä½œï¼‰
  player.pause();
  
  // å¼€å§‹æ’­æ”¾
  player.play();
  
  // ç­‰å¾…åŠ è½½å®Œæˆåç»§ç»­æµ‹è¯•
  setTimeout(() => {
    console.log('\nâ¸ï¸ æµ‹è¯•æš‚åœå’Œæ¢å¤:');
    player.pause();
    
    setTimeout(() => {
      player.play(); // æ¢å¤æ’­æ”¾
      
      setTimeout(() => {
        console.log('\nâ­ï¸ æµ‹è¯•åˆ‡æ¢æ­Œæ›²:');
        player.next();
        
        setTimeout(() => {
          console.log('\nğŸ”Š æµ‹è¯•éŸ³é‡è°ƒèŠ‚:');
          player.setVolume(80);
          
          console.log('\nâ¹ï¸ æµ‹è¯•åœæ­¢:');
          player.stop();
          
          // æ¨¡æ‹Ÿé”™è¯¯æƒ…å†µ
          setTimeout(() => {
            console.log('\nâŒ æ¨¡æ‹Ÿæ’­æ”¾é”™è¯¯:');
            player.playlist = []; // æ¸…ç©ºæ’­æ”¾åˆ—è¡¨
            player.play(); // å°è¯•æ’­æ”¾ç©ºåˆ—è¡¨
            
            setTimeout(() => {
              console.log('\nğŸ“Š æœ€ç»ˆç»Ÿè®¡ä¿¡æ¯:');
              console.log('æ’­æ”¾å™¨çŠ¶æ€:', player.getStatus());
              console.log('æ’­æ”¾ç»Ÿè®¡:', player.getStats());
              
              console.log('\nğŸ“œ çŠ¶æ€å†å²:');
              const stateHistory = player.getStateHistory();
              stateHistory.forEach((entry, index) => {
                console.log(`${index + 1}. ${entry.timestampFormatted}: ${entry.from} â†’ ${entry.to}`);
              });
              
              console.log('\nğŸµ æ’­æ”¾å†å²:');
              const playHistory = player.getPlayHistory();
              playHistory.forEach((entry, index) => {
                console.log(`${index + 1}. ${entry.track.title} - ${entry.startTimeFormatted} (${entry.playDurationFormatted || 'æœªå®Œæˆ'})`);
              });
            }, 1000);
          }, 1000);
        }, 1000);
      }, 1000);
    }, 1000);
  }, 3000); // ç­‰å¾…åŠ è½½å®Œæˆ
}

stateDemo();
```

## äº”ã€æ¨¡æ¿æ–¹æ³•æ¨¡å¼ï¼šç®—æ³•éª¨æ¶çš„å®šä¹‰

### 5.1 ä»€ä¹ˆæ˜¯æ¨¡æ¿æ–¹æ³•æ¨¡å¼ï¼Ÿ

æ¨¡æ¿æ–¹æ³•æ¨¡å¼åœ¨ä¸€ä¸ªæ–¹æ³•ä¸­å®šä¹‰ä¸€ä¸ªç®—æ³•çš„éª¨æ¶ï¼Œè€Œå°†ä¸€äº›æ­¥éª¤å»¶è¿Ÿåˆ°å­ç±»ä¸­ã€‚æ¨¡æ¿æ–¹æ³•ä½¿å¾—å­ç±»å¯ä»¥åœ¨ä¸æ”¹å˜ç®—æ³•ç»“æ„çš„æƒ…å†µä¸‹ï¼Œé‡æ–°å®šä¹‰ç®—æ³•ä¸­çš„æŸäº›æ­¥éª¤ã€‚å°±åƒæ˜¯åšèœçš„æµç¨‹ï¼šå‡†å¤‡é£Ÿæ â†’ åŠ å·¥é£Ÿæ â†’ çƒ¹é¥ª â†’ è£…ç›˜ï¼Œæ¯ä¸ªæ­¥éª¤çš„å…·ä½“å®ç°å¯ä»¥ä¸åŒï¼Œä½†æµç¨‹æ˜¯å›ºå®šçš„ã€‚

### 5.2 æ•°æ®å¤„ç†ç®¡é“çš„æ¨¡æ¿æ–¹æ³•

```javascript
// æŠ½è±¡æ•°æ®å¤„ç†å™¨ï¼ˆæ¨¡æ¿ç±»ï¼‰
class DataProcessor {
  constructor() {
    this.startTime = null;
    this.endTime = null;
    this.processedCount = 0;
    this.errorCount = 0;
    this.warnings = [];
  }
  
  // æ¨¡æ¿æ–¹æ³• - å®šä¹‰ç®—æ³•éª¨æ¶
  process(data) {
    console.log('ğŸš€ å¼€å§‹æ•°æ®å¤„ç†æµç¨‹...');
    this.startTime = Date.now();
    
    try {
      // æ­¥éª¤1: éªŒè¯è¾“å…¥æ•°æ®
      console.log('ğŸ“‹ æ­¥éª¤1: éªŒè¯è¾“å…¥æ•°æ®');
      if (!this.validateInput(data)) {
        throw new Error('è¾“å…¥æ•°æ®éªŒè¯å¤±è´¥');
      }
      
      // æ­¥éª¤2: é¢„å¤„ç†æ•°æ®
      console.log('ğŸ”§ æ­¥éª¤2: é¢„å¤„ç†æ•°æ®');
      const preprocessedData = this.preprocess(data);
      
      // æ­¥éª¤3: æ ¸å¿ƒå¤„ç†é€»è¾‘
      console.log('âš™ï¸ æ­¥éª¤3: æ‰§è¡Œæ ¸å¿ƒå¤„ç†');
      const processedData = this.processCore(preprocessedData);
      
      // æ­¥éª¤4: åå¤„ç†
      console.log('ğŸ¯ æ­¥éª¤4: åå¤„ç†æ•°æ®');
      const finalData = this.postprocess(processedData);
      
      // æ­¥éª¤5: éªŒè¯è¾“å‡º
      console.log('âœ… æ­¥éª¤5: éªŒè¯è¾“å‡ºæ•°æ®');
      if (!this.validateOutput(finalData)) {
        throw new Error('è¾“å‡ºæ•°æ®éªŒè¯å¤±è´¥');
      }
      
      // æ­¥éª¤6: ä¿å­˜ç»“æœ
      console.log('ğŸ’¾ æ­¥éª¤6: ä¿å­˜å¤„ç†ç»“æœ');
      this.saveResult(finalData);
      
      this.endTime = Date.now();
      this.logSuccess();
      
      return finalData;
      
    } catch (error) {
      this.endTime = Date.now();
      this.handleError(error);
      throw error;
    } finally {
      // æ¸…ç†èµ„æºï¼ˆé’©å­æ–¹æ³•ï¼‰
      this.cleanup();
    }
  }
  
  // æŠ½è±¡æ–¹æ³• - å­ç±»å¿…é¡»å®ç°
  validateInput(data) {
    throw new Error('validateInput() æ–¹æ³•å¿…é¡»è¢«å­ç±»å®ç°');
  }
  
  processCore(data) {
    throw new Error('processCore() æ–¹æ³•å¿…é¡»è¢«å­ç±»å®ç°');
  }
  
  validateOutput(data) {
    throw new Error('validateOutput() æ–¹æ³•å¿…é¡»è¢«å­ç±»å®ç°');
  }
  
  // å…·ä½“æ–¹æ³• - æä¾›é»˜è®¤å®ç°ï¼Œå­ç±»å¯ä»¥é‡å†™
  preprocess(data) {
    console.log('  ğŸ“ é»˜è®¤é¢„å¤„ç†: æ•°æ®æ¸…ç†å’Œæ ¼å¼åŒ–');
    
    // ç§»é™¤ç©ºå€¼å’Œæ— æ•ˆæ•°æ®
    if (Array.isArray(data)) {
      return data.filter(item => item != null && item !== '');
    }
    
    if (typeof data === 'object' && data !== null) {
      const cleaned = {};
      for (const [key, value] of Object.entries(data)) {
        if (value != null && value !== '') {
          cleaned[key] = value;
        }
      }
      return cleaned;
    }
    
    return data;
  }
  
  postprocess(data) {
    console.log('  ğŸ¨ é»˜è®¤åå¤„ç†: æ•°æ®æ ¼å¼åŒ–');
    this.processedCount = Array.isArray(data) ? data.length : 1;
    return data;
  }
  
  saveResult(data) {
    console.log('  ğŸ’¾ é»˜è®¤ä¿å­˜: è¾“å‡ºåˆ°æ§åˆ¶å°');
    console.log('å¤„ç†ç»“æœ:', JSON.stringify(data, null, 2));
  }
  
  // é’©å­æ–¹æ³• - å¯é€‰å®ç°
  cleanup() {
    console.log('ğŸ§¹ æ¸…ç†èµ„æº');
  }
  
  // å·¥å…·æ–¹æ³•
  handleError(error) {
    this.errorCount++;
    console.error(`âŒ å¤„ç†å¤±è´¥: ${error.message}`);
    this.logError(error);
  }
  
  logSuccess() {
    const duration = this.endTime - this.startTime;
    console.log(`âœ… å¤„ç†å®Œæˆ! è€—æ—¶: ${duration}ms, å¤„ç†æ•°é‡: ${this.processedCount}, é”™è¯¯: ${this.errorCount}`);
    
    if (this.warnings.length > 0) {
      console.log(`âš ï¸ è­¦å‘Š (${this.warnings.length}ä¸ª):`);
      this.warnings.forEach((warning, index) => {
        console.log(`  ${index + 1}. ${warning}`);
      });
    }
  }
  
  logError(error) {
    const duration = this.endTime - this.startTime;
    console.log(`âŒ å¤„ç†å¤±è´¥! è€—æ—¶: ${duration}ms, é”™è¯¯: ${error.message}`);
  }
  
  addWarning(message) {
    this.warnings.push(message);
    console.log(`âš ï¸ è­¦å‘Š: ${message}`);
  }
  
  // è·å–å¤„ç†ç»Ÿè®¡
  getStats() {
    return {
      startTime: this.startTime,
      endTime: this.endTime,
      duration: this.endTime ? this.endTime - this.startTime : null,
      processedCount: this.processedCount,
      errorCount: this.errorCount,
      warningCount: this.warnings.length,
      warnings: [...this.warnings]
    };
  }
}

// å…·ä½“å®ç°1: CSVæ•°æ®å¤„ç†å™¨
class CSVProcessor extends DataProcessor {
  constructor(options = {}) {
    super();
    this.delimiter = options.delimiter || ',';
    this.hasHeader = options.hasHeader !== false;
    this.encoding = options.encoding || 'utf-8';
  }
  
  validateInput(data) {
    if (typeof data !== 'string') {
      return false;
    }
    
    if (data.trim().length === 0) {
      return false;
    }
    
    // æ£€æŸ¥æ˜¯å¦åŒ…å«åˆ†éš”ç¬¦
    if (!data.includes(this.delimiter)) {
      this.addWarning('æ•°æ®ä¸­æœªæ‰¾åˆ°æŒ‡å®šçš„åˆ†éš”ç¬¦');
    }
    
    return true;
  }
  
  preprocess(data) {
    console.log('  ğŸ“ CSVé¢„å¤„ç†: è§£æè¡Œå’Œåˆ—');
    
    // æŒ‰è¡Œåˆ†å‰²
    const lines = data.trim().split('\n').map(line => line.trim()).filter(line => line.length > 0);
    
    if (lines.length === 0) {
      throw new Error('æ²¡æœ‰æœ‰æ•ˆçš„æ•°æ®è¡Œ');
    }
    
    // è§£æCSV
    const rows = lines.map(line => {
      // ç®€å•çš„CSVè§£æï¼ˆä¸å¤„ç†å¼•å·å†…çš„é€—å·ï¼‰
      return line.split(this.delimiter).map(cell => cell.trim());
    });
    
    // å¤„ç†è¡¨å¤´
    let headers = null;
    let dataRows = rows;
    
    if (this.hasHeader && rows.length > 0) {
      headers = rows[0];
      dataRows = rows.slice(1);
      console.log(`  ğŸ“‹ å‘ç°è¡¨å¤´: ${headers.join(', ')}`);
    }
    
    return {
      headers,
      rows: dataRows,
      originalLines: lines.length,
      dataLines: dataRows.length
    };
  }
  
  processCore(data) {
    console.log('  âš™ï¸ CSVæ ¸å¿ƒå¤„ç†: è½¬æ¢ä¸ºå¯¹è±¡æ•°ç»„');
    
    const { headers, rows } = data;
    const result = [];
    
    for (let i = 0; i < rows.length; i++) {
      const row = rows[i];
      
      if (headers) {
        // è½¬æ¢ä¸ºå¯¹è±¡
        const obj = {};
        for (let j = 0; j < headers.length; j++) {
          const header = headers[j];
          const value = j < row.length ? row[j] : '';
          
          // å°è¯•è½¬æ¢æ•°æ®ç±»å‹
          obj[header] = this.convertValue(value);
        }
        
        // éªŒè¯è¡Œæ•°æ®
        if (this.validateRow(obj, i + 1)) {
          result.push(obj);
        }
      } else {
        // ä¿æŒæ•°ç»„æ ¼å¼
        const processedRow = row.map(value => this.convertValue(value));
        if (this.validateRow(processedRow, i + 1)) {
          result.push(processedRow);
        }
      }
    }
    
    return result;
  }
  
  postprocess(data) {
    console.log('  ğŸ¨ CSVåå¤„ç†: æ•°æ®ç»Ÿè®¡å’Œæ¸…ç†');
    
    // ç»Ÿè®¡ä¿¡æ¯
    this.processedCount = data.length;
    
    // æ•°æ®æ¸…ç†å’ŒéªŒè¯
    const cleanedData = data.filter(item => {
      if (Array.isArray(item)) {
        return item.some(value => value !== null && value !== '');
      } else {
        return Object.values(item).some(value => value !== null && value !== '');
      }
    });
    
    if (cleanedData.length < data.length) {
      this.addWarning(`ç§»é™¤äº† ${data.length - cleanedData.length} è¡Œç©ºæ•°æ®`);
    }
    
    return cleanedData;
  }
  
  validateOutput(data) {
    if (!Array.isArray(data)) {
      return false;
    }
    
    if (data.length === 0) {
      this.addWarning('å¤„ç†ç»“æœä¸ºç©º');
      return true; // ç©ºç»“æœä¹Ÿæ˜¯æœ‰æ•ˆçš„
    }
    
    // æ£€æŸ¥æ•°æ®ä¸€è‡´æ€§
    if (this.hasHeader && data.length > 0) {
      const firstItem = data[0];
      if (typeof firstItem === 'object' && !Array.isArray(firstItem)) {
        const keys = Object.keys(firstItem);
        const inconsistentRows = data.filter(item => {
          const itemKeys = Object.keys(item);
          return itemKeys.length !== keys.length || !keys.every(key => itemKeys.includes(key));
        });
        
        if (inconsistentRows.length > 0) {
          this.addWarning(`å‘ç° ${inconsistentRows.length} è¡Œæ•°æ®ç»“æ„ä¸ä¸€è‡´`);
        }
      }
    }
    
    return true;
  }
  
  saveResult(data) {
    console.log('  ğŸ’¾ CSVä¿å­˜: æ ¼å¼åŒ–è¾“å‡º');
    
    if (data.length === 0) {
      console.log('ğŸ“„ å¤„ç†ç»“æœ: æ— æ•°æ®');
      return;
    }
    
    console.log(`ğŸ“„ å¤„ç†ç»“æœ (${data.length} è¡Œ):`);
    
    // æ˜¾ç¤ºå‰å‡ è¡Œä½œä¸ºç¤ºä¾‹
    const sampleSize = Math.min(3, data.length);
    for (let i = 0; i < sampleSize; i++) {
      console.log(`  ${i + 1}. ${JSON.stringify(data[i])}`);
    }
    
    if (data.length > sampleSize) {
      console.log(`  ... è¿˜æœ‰ ${data.length - sampleSize} è¡Œæ•°æ®`);
    }
  }
  
  // è¾…åŠ©æ–¹æ³•
  convertValue(value) {
    if (value === '') return null;
    
    // å°è¯•è½¬æ¢ä¸ºæ•°å­—
    if (/^-?\d+$/.test(value)) {
      return parseInt(value, 10);
    }
    
    if (/^-?\d*\.\d+$/.test(value)) {
      return parseFloat(value);
    }
    
    // å°è¯•è½¬æ¢ä¸ºå¸ƒå°”å€¼
    if (value.toLowerCase() === 'true') return true;
    if (value.toLowerCase() === 'false') return false;
    
    // ä¿æŒå­—ç¬¦ä¸²
    return value;
  }
  
  validateRow(row, rowNumber) {
    // å¯ä»¥åœ¨è¿™é‡Œæ·»åŠ è¡Œçº§åˆ«çš„éªŒè¯é€»è¾‘
    return true;
  }
}

// å…·ä½“å®ç°2: JSONæ•°æ®å¤„ç†å™¨
class JSONProcessor extends DataProcessor {
  constructor(options = {}) {
    super();
    this.schema = options.schema || null;
    this.strictMode = options.strictMode || false;
  }
  
  validateInput(data) {
    if (typeof data !== 'string') {
      return false;
    }
    
    try {
      JSON.parse(data);
      return true;
    } catch (error) {
      console.error('JSONæ ¼å¼é”™è¯¯:', error.message);
      return false;
    }
  }
  
  preprocess(data) {
    console.log('  ğŸ“ JSONé¢„å¤„ç†: è§£æJSONæ•°æ®');
    
    const parsed = JSON.parse(data);
    
    // ç»Ÿä¸€è½¬æ¢ä¸ºæ•°ç»„æ ¼å¼
    let items;
    if (Array.isArray(parsed)) {
      items = parsed;
    } else if (typeof parsed === 'object' && parsed !== null) {
      items = [parsed];
    } else {
      items = [{ value: parsed }];
    }
    
    console.log(`  ğŸ“Š è§£æå¾—åˆ° ${items.length} ä¸ªæ•°æ®é¡¹`);
    
    return {
      items,
      originalType: Array.isArray(parsed) ? 'array' : typeof parsed,
      totalItems: items.length
    };
  }
  
  processCore(data) {
    console.log('  âš™ï¸ JSONæ ¸å¿ƒå¤„ç†: æ•°æ®è½¬æ¢å’ŒéªŒè¯');
    
    const { items } = data;
    const result = [];
    
    for (let i = 0; i < items.length; i++) {
      const item = items[i];
      
      try {
        // åº”ç”¨schemaéªŒè¯ï¼ˆå¦‚æœæœ‰ï¼‰
        if (this.schema) {
          const validatedItem = this.applySchema(item, i);
          if (validatedItem !== null) {
            result.push(validatedItem);
          }
        } else {
          // åŸºæœ¬å¤„ç†
          const processedItem = this.processItem(item, i);
          if (processedItem !== null) {
            result.push(processedItem);
          }
        }
      } catch (error) {
        this.errorCount++;
        if (this.strictMode) {
          throw new Error(`å¤„ç†ç¬¬ ${i + 1} é¡¹æ—¶å‡ºé”™: ${error.message}`);
        } else {
          this.addWarning(`è·³è¿‡ç¬¬ ${i + 1} é¡¹: ${error.message}`);
        }
      }
    }
    
    return result;
  }
  
  validateOutput(data) {
    if (!Array.isArray(data)) {
      return false;
    }
    
    // æ£€æŸ¥æ•°æ®å®Œæ•´æ€§
    const invalidItems = data.filter(item => item === null || item === undefined);
    if (invalidItems.length > 0) {
      this.addWarning(`å‘ç° ${invalidItems.length} ä¸ªæ— æ•ˆæ•°æ®é¡¹`);
    }
    
    return true;
  }
  
  saveResult(data) {
    console.log('  ğŸ’¾ JSONä¿å­˜: æ ¼å¼åŒ–JSONè¾“å‡º');
    
    const output = {
      success: true,
      timestamp: new Date().toISOString(),
      count: data.length,
      data: data
    };
    
    console.log('ğŸ“„ å¤„ç†ç»“æœ:');
    console.log(JSON.stringify(output, null, 2));
  }
  
  // è¾…åŠ©æ–¹æ³•
  processItem(item, index) {
    // åŸºæœ¬çš„æ•°æ®å¤„ç†é€»è¾‘
    if (typeof item === 'object' && item !== null) {
      // æ·»åŠ å…ƒæ•°æ®
      return {
        ...item,
        _index: index,
        _processedAt: Date.now()
      };
    }
    
    return {
      value: item,
      _index: index,
      _processedAt: Date.now()
    };
  }
  
  applySchema(item, index) {
    // ç®€å•çš„schemaéªŒè¯ç¤ºä¾‹
    if (!this.schema || typeof this.schema !== 'object') {
      return this.processItem(item, index);
    }
    
    const result = {};
    
    for (const [key, rules] of Object.entries(this.schema)) {
      const value = item[key];
      
      // æ£€æŸ¥å¿…å¡«å­—æ®µ
      if (rules.required && (value === undefined || value === null)) {
        throw new Error(`ç¼ºå°‘å¿…å¡«å­—æ®µ: ${key}`);
      }
      
      // ç±»å‹æ£€æŸ¥
      if (value !== undefined && value !== null && rules.type) {
        if (typeof value !== rules.type) {
          if (rules.type === 'number' && typeof value === 'string' && !isNaN(value)) {
            result[key] = Number(value);
          } else {
            throw new Error(`å­—æ®µ ${key} ç±»å‹é”™è¯¯ï¼ŒæœŸæœ› ${rules.type}ï¼Œå®é™… ${typeof value}`);
          }
        } else {
          result[key] = value;
        }
      } else if (value !== undefined) {
        result[key] = value;
      }
      
      // åº”ç”¨é»˜è®¤å€¼
      if (result[key] === undefined && rules.default !== undefined) {
        result[key] = rules.default;
      }
    }
    
    // æ·»åŠ å…ƒæ•°æ®
    result._index = index;
    result._processedAt = Date.now();
    
    return result;
  }
}

// å…·ä½“å®ç°3: å›¾ç‰‡å¤„ç†å™¨
class ImageProcessor extends DataProcessor {
  constructor(options = {}) {
    super();
    this.maxSize = options.maxSize || 1024 * 1024; // 1MB
    this.allowedFormats = options.allowedFormats || ['jpg', 'jpeg', 'png', 'gif', 'webp'];
    this.outputFormat = options.outputFormat || 'webp';
  }
  
  validateInput(data) {
    // å‡è®¾dataæ˜¯æ–‡ä»¶ä¿¡æ¯æ•°ç»„
    if (!Array.isArray(data)) {
      return false;
    }
    
    for (const file of data) {
      if (!file.name || !file.size || !file.type) {
        return false;
      }
      
      // æ£€æŸ¥æ–‡ä»¶å¤§å°
      if (file.size > this.maxSize) {
        this.addWarning(`æ–‡ä»¶ ${file.name} è¶…è¿‡å¤§å°é™åˆ¶ (${file.size} > ${this.maxSize})`);
      }
      
      // æ£€æŸ¥æ–‡ä»¶æ ¼å¼
      const extension = file.name.split('.').pop().toLowerCase();
      if (!this.allowedFormats.includes(extension)) {
        this.addWarning(`æ–‡ä»¶ ${file.name} æ ¼å¼ä¸æ”¯æŒ (${extension})`);
      }
    }
    
    return true;
  }
  
  preprocess(data) {
    console.log('  ğŸ“ å›¾ç‰‡é¢„å¤„ç†: è¿‡æ»¤å’Œåˆ†ç±»');
    
    const validFiles = data.filter(file => {
      const extension = file.name.split('.').pop().toLowerCase();
      return file.size <= this.maxSize && this.allowedFormats.includes(extension);
    });
    
    console.log(`  ğŸ“Š æœ‰æ•ˆæ–‡ä»¶: ${validFiles.length}/${data.length}`);
    
    return {
      files: validFiles,
      totalSize: validFiles.reduce((sum, file) => sum + file.size, 0),
      skippedCount: data.length - validFiles.length
    };
  }
  
  processCore(data) {
    console.log('  âš™ï¸ å›¾ç‰‡æ ¸å¿ƒå¤„ç†: æ¨¡æ‹Ÿå›¾ç‰‡è½¬æ¢');
    
    const { files } = data;
    const results = [];
    
    for (let i = 0; i < files.length; i++) {
      const file = files[i];
      
      try {
        // æ¨¡æ‹Ÿå›¾ç‰‡å¤„ç†
        const processed = this.processImage(file);
        results.push(processed);
        
        console.log(`  âœ… å¤„ç†å®Œæˆ: ${file.name} â†’ ${processed.name}`);
      } catch (error) {
        this.errorCount++;
        this.addWarning(`å¤„ç† ${file.name} å¤±è´¥: ${error.message}`);
      }
    }
    
    return results;
  }
  
  validateOutput(data) {
    if (!Array.isArray(data)) {
      return false;
    }
    
    // æ£€æŸ¥å¤„ç†ç»“æœ
    for (const result of data) {
      if (!result.name || !result.processedSize || !result.originalSize) {
        return false;
      }
    }
    
    return true;
  }
  
  saveResult(data) {
    console.log('  ğŸ’¾ å›¾ç‰‡ä¿å­˜: ç”Ÿæˆå¤„ç†æŠ¥å‘Š');
    
    const totalOriginalSize = data.reduce((sum, item) => sum + item.originalSize, 0);
    const totalProcessedSize = data.reduce((sum, item) => sum + item.processedSize, 0);
    const compressionRatio = ((totalOriginalSize - totalProcessedSize) / totalOriginalSize * 100).toFixed(2);
    
    console.log('ğŸ“„ å›¾ç‰‡å¤„ç†æŠ¥å‘Š:');
    console.log(`  ğŸ“Š å¤„ç†æ–‡ä»¶æ•°: ${data.length}`);
    console.log(`  ğŸ“ åŸå§‹æ€»å¤§å°: ${this.formatFileSize(totalOriginalSize)}`);
    console.log(`  ğŸ“¦ å¤„ç†åå¤§å°: ${this.formatFileSize(totalProcessedSize)}`);
    console.log(`  ğŸ“‰ å‹ç¼©ç‡: ${compressionRatio}%`);
    
    console.log('\n  ğŸ“‹ è¯¦ç»†åˆ—è¡¨:');
    data.forEach((item, index) => {
      const ratio = ((item.originalSize - item.processedSize) / item.originalSize * 100).toFixed(1);
      console.log(`    ${index + 1}. ${item.name} (${ratio}% å‹ç¼©)`);
    });
  }
  
  // è¾…åŠ©æ–¹æ³•
  processImage(file) {
    // æ¨¡æ‹Ÿå›¾ç‰‡å¤„ç†é€»è¾‘
    const originalExtension = file.name.split('.').pop();
    const baseName = file.name.replace(`.${originalExtension}`, '');
    const newName = `${baseName}.${this.outputFormat}`;
    
    // æ¨¡æ‹Ÿå‹ç¼©æ•ˆæœ
    const compressionFactor = this.outputFormat === 'webp' ? 0.7 : 0.85;
    const processedSize = Math.floor(file.size * compressionFactor);
    
    return {
      name: newName,
      originalName: file.name,
      originalSize: file.size,
      processedSize: processedSize,
      format: this.outputFormat,
      processedAt: Date.now()
    };
  }
  
  formatFileSize(bytes) {
    const units = ['B', 'KB', 'MB', 'GB'];
    let size = bytes;
    let unitIndex = 0;
    
    while (size >= 1024 && unitIndex < units.length - 1) {
      size /= 1024;
      unitIndex++;
    }
    
    return `${size.toFixed(2)} ${units[unitIndex]}`;
  }
}

// ä½¿ç”¨ç¤ºä¾‹
function templateMethodDemo() {
  console.log('=== æ¨¡æ¿æ–¹æ³•æ¨¡å¼æ•°æ®å¤„ç†ç¤ºä¾‹ ===');
  
  // ç¤ºä¾‹1: CSVå¤„ç†
  console.log('\nğŸ“Š CSVæ•°æ®å¤„ç†:');
  const csvData = `name,age,city,salary
John Doe,30,New York,50000
Jane Smith,25,Los Angeles,45000
Bob Johnson,35,Chicago,55000
,28,Boston,
Alice Brown,32,Seattle,60000`;
  
  const csvProcessor = new CSVProcessor({ delimiter: ',', hasHeader: true });
  
  try {
    const csvResult = csvProcessor.process(csvData);
    console.log('\nğŸ“ˆ CSVå¤„ç†ç»Ÿè®¡:', csvProcessor.getStats());
  } catch (error) {
    console.error('CSVå¤„ç†å¤±è´¥:', error.message);
  }
  
  // ç¤ºä¾‹2: JSONå¤„ç†
  console.log('\n\nğŸ“‹ JSONæ•°æ®å¤„ç†:');
  const jsonData = JSON.stringify([
    { id: 1, name: 'Product A', price: '29.99', category: 'electronics' },
    { id: 2, name: 'Product B', price: 'invalid', category: 'books' },
    { id: 3, name: 'Product C', price: '15.50', category: 'clothing' },
    { name: 'Product D', price: '8.99' } // ç¼ºå°‘id
  ]);
  
  const jsonSchema = {
    id: { type: 'number', required: true },
    name: { type: 'string', required: true },
    price: { type: 'number', required: true },
    category: { type: 'string', default: 'uncategorized' }
  };
  
  const jsonProcessor = new JSONProcessor({ schema: jsonSchema, strictMode: false });
  
  try {
    const jsonResult = jsonProcessor.process(jsonData);
    console.log('\nğŸ“ˆ JSONå¤„ç†ç»Ÿè®¡:', jsonProcessor.getStats());
  } catch (error) {
    console.error('JSONå¤„ç†å¤±è´¥:', error.message);
  }
  
  // ç¤ºä¾‹3: å›¾ç‰‡å¤„ç†
  console.log('\n\nğŸ–¼ï¸ å›¾ç‰‡æ•°æ®å¤„ç†:');
  const imageData = [
    { name: 'photo1.jpg', size: 2048000, type: 'image/jpeg' },
    { name: 'photo2.png', size: 1536000, type: 'image/png' },
    { name: 'photo3.gif', size: 512000, type: 'image/gif' },
    { name: 'document.pdf', size: 1024000, type: 'application/pdf' }, // ä¸æ”¯æŒçš„æ ¼å¼
    { name: 'large_image.jpg', size: 5120000, type: 'image/jpeg' } // è¶…å¤§æ–‡ä»¶
  ];
  
  const imageProcessor = new ImageProcessor({
    maxSize: 3 * 1024 * 1024, // 3MB
    allowedFormats: ['jpg', 'jpeg', 'png', 'gif'],
    outputFormat: 'webp'
  });
  
  try {
    const imageResult = imageProcessor.process(imageData);
    console.log('\nğŸ“ˆ å›¾ç‰‡å¤„ç†ç»Ÿè®¡:', imageProcessor.getStats());
  } catch (error) {
    console.error('å›¾ç‰‡å¤„ç†å¤±è´¥:', error.message);
  }
}

templateMethodDemo();
```

## å…­ã€è¡Œä¸ºå‹æ¨¡å¼æ€»ç»“

### 6.1 æ¨¡å¼å¯¹æ¯”ä¸é€‰æ‹©

```mermaid
graph TD
    A[è¡Œä¸ºå‹æ¨¡å¼é€‰æ‹©] --> B{å¯¹è±¡é—´é€šä¿¡}
    A --> C{ç®—æ³•å°è£…}
    A --> D{çŠ¶æ€ç®¡ç†}
    A --> E{è¯·æ±‚å¤„ç†}
    
    B --> F[è§‚å¯Ÿè€…æ¨¡å¼]
    B --> G[å‘å¸ƒè®¢é˜…æ¨¡å¼]
    
    C --> H[ç­–ç•¥æ¨¡å¼]
    C --> I[æ¨¡æ¿æ–¹æ³•æ¨¡å¼]
    
    D --> J[çŠ¶æ€æ¨¡å¼]
    
    E --> K[å‘½ä»¤æ¨¡å¼]
    
    F --> F1[ä¸€å¯¹å¤šä¾èµ–å…³ç³»<br/>ç›´æ¥å¼•ç”¨]
    G --> G1[æ¾è€¦åˆé€šä¿¡<br/>äº‹ä»¶æ€»çº¿]
    H --> H1[ç®—æ³•æ—å°è£…<br/>è¿è¡Œæ—¶åˆ‡æ¢]
    I --> I1[ç®—æ³•éª¨æ¶å›ºå®š<br/>æ­¥éª¤å¯å˜]
    J --> J1[çŠ¶æ€é©±åŠ¨è¡Œä¸º<br/>çŠ¶æ€è½¬æ¢]
    K --> K1[è¯·æ±‚å°è£…<br/>æ’¤é”€é‡åš]
```

### 6.2 å®é™…åº”ç”¨åœºæ™¯

**è§‚å¯Ÿè€…æ¨¡å¼**ï¼š
- Vue.js çš„å“åº”å¼ç³»ç»Ÿ
- React çš„çŠ¶æ€ç®¡ç†
- DOM äº‹ä»¶ç›‘å¬
- æ•°æ®ç»‘å®šæ¡†æ¶

**å‘å¸ƒè®¢é˜…æ¨¡å¼**ï¼š
- EventBus äº‹ä»¶æ€»çº¿
- Node.js EventEmitter
- å¾®æœåŠ¡é—´é€šä¿¡
- å‰ç«¯ç»„ä»¶é€šä¿¡

**ç­–ç•¥æ¨¡å¼**ï¼š
- è¡¨å•éªŒè¯è§„åˆ™
- æ”¯ä»˜æ–¹å¼é€‰æ‹©
- æ’åºç®—æ³•åˆ‡æ¢
- ä¸»é¢˜åˆ‡æ¢ç³»ç»Ÿ

**å‘½ä»¤æ¨¡å¼**ï¼š
- ç¼–è¾‘å™¨æ’¤é”€é‡åš
- å®å‘½ä»¤å½•åˆ¶
- é˜Ÿåˆ—ä»»åŠ¡å¤„ç†
- GUI æŒ‰é’®æ“ä½œ

**çŠ¶æ€æ¨¡å¼**ï¼š
- æ¸¸æˆè§’è‰²çŠ¶æ€
- å·¥ä½œæµå¼•æ“
- æ’­æ”¾å™¨æ§åˆ¶
- è®¢å•çŠ¶æ€ç®¡ç†

**æ¨¡æ¿æ–¹æ³•æ¨¡å¼**ï¼š
- æ•°æ®å¤„ç†ç®¡é“
- æµ‹è¯•æ¡†æ¶ç»“æ„
- ç”Ÿå‘½å‘¨æœŸé’©å­
- æ„å»ºå·¥å…·æµç¨‹

### 6.3 æœ€ä½³å®è·µ

1. **é€‰æ‹©åˆé€‚çš„æ¨¡å¼**ï¼šæ ¹æ®å…·ä½“é—®é¢˜é€‰æ‹©æœ€é€‚åˆçš„æ¨¡å¼ï¼Œä¸è¦ä¸ºäº†ä½¿ç”¨æ¨¡å¼è€Œä½¿ç”¨æ¨¡å¼ã€‚

2. **ä¿æŒç®€å•**ï¼šä¼˜å…ˆé€‰æ‹©ç®€å•çš„è§£å†³æ–¹æ¡ˆï¼Œå¤æ‚çš„æ¨¡å¼åº”è¯¥åœ¨ç¡®å®éœ€è¦æ—¶æ‰ä½¿ç”¨ã€‚

3. **è€ƒè™‘æ€§èƒ½**ï¼šæŸäº›æ¨¡å¼ï¼ˆå¦‚è§‚å¯Ÿè€…æ¨¡å¼ï¼‰å¯èƒ½ä¼šå½±å“æ€§èƒ½ï¼Œéœ€è¦åˆç†æ§åˆ¶ç›‘å¬å™¨æ•°é‡ã€‚

4. **æ–‡æ¡£åŒ–**ï¼šæ¸…æ¥šåœ°è®°å½•ä½¿ç”¨çš„æ¨¡å¼å’Œè®¾è®¡å†³ç­–ï¼Œä¾¿äºå›¢é˜Ÿç†è§£å’Œç»´æŠ¤ã€‚

5. **æµ‹è¯•è¦†ç›–**ï¼šä¸ºæ¨¡å¼å®ç°ç¼–å†™å……åˆ†çš„æµ‹è¯•ï¼Œç¡®ä¿å„ç§åœºæ™¯ä¸‹çš„æ­£ç¡®æ€§ã€‚

è¡Œä¸ºå‹æ¨¡å¼å¸®åŠ©æˆ‘ä»¬ä¼˜é›…åœ°å¤„ç†å¯¹è±¡é—´çš„äº¤äº’å’ŒèŒè´£åˆ†é…ï¼Œè®©ä»£ç æ›´åŠ çµæ´»ã€å¯ç»´æŠ¤ã€‚åœ¨å®é™…å¼€å‘ä¸­ï¼Œè¿™äº›æ¨¡å¼ç»å¸¸ç»„åˆä½¿ç”¨ï¼Œå½¢æˆæ›´å¼ºå¤§çš„è§£å†³æ–¹æ¡ˆã€‚æŒæ¡è¿™äº›æ¨¡å¼ï¼Œèƒ½è®©æˆ‘ä»¬å†™å‡ºæ›´åŠ ä¸“ä¸šå’Œä¼˜é›…çš„ä»£ç ï¼
```