# 创建型模式："花式"创建对象

> 如果说编程是一门艺术，那么设计模式就是这门艺术的经典技法。今天我们来聊聊创建型模式，看看如何优雅地"生产"对象。

## 前言：为什么需要设计模式？

想象一下，你正在开发一个复杂的前端应用。随着功能越来越多，代码越来越复杂，你发现自己陷入了"屎山"代码的泥潭：

- 到处都是 `new` 关键字，对象创建逻辑散落各处
- 相似的代码重复出现，维护起来痛苦不堪
- 一个小改动可能引发连锁反应，bug 满天飞
- 对象创建过程复杂，参数众多，容易出错

这时候，设计模式就像是你的救星。它们是前人总结出来的最佳实践，能让你的代码更加优雅、可维护、可扩展。

**创建型模式**专门解决对象创建的问题，它们的核心思想是：**将对象的创建与使用分离**，让对象创建更加灵活、可控。

今天我们来深入探讨五种核心的创建型模式：

1. **单例模式**：确保全局唯一实例
2. **工厂模式**：封装对象创建逻辑
3. **建造者模式**：分步骤构建复杂对象
4. **原型模式**：通过克隆创建对象
5. **抽象工厂模式**：创建相关对象族

## 一、单例模式：全局唯一的"独苗"

### 1.1 什么是单例模式？

单例模式确保一个类只有一个实例，并提供全局访问点。在前端开发中，这种模式非常常见，比如：

- Vuex/Redux 的 Store
- 全局配置对象
- 日志记录器
- 缓存管理器
- API 客户端

### 1.2 经典单例实现

```javascript
// 传统的单例模式实现
class Singleton {
  constructor() {
    // 如果实例已存在，直接返回
    if (Singleton.instance) {
      return Singleton.instance;
    }
    
    // 初始化实例
    this.data = {};
    this.timestamp = Date.now();
    
    // 保存实例引用
    Singleton.instance = this;
  }
  
  getData() {
    return this.data;
  }
  
  setData(key, value) {
    this.data[key] = value;
  }
}

// 测试单例
const instance1 = new Singleton();
const instance2 = new Singleton();

console.log(instance1 === instance2); // true
instance1.setData('name', 'John');
console.log(instance2.getData()); // { name: 'John' }
```

### 1.3 现代 JavaScript 的单例实现

#### 使用 Symbol 确保私有性

```javascript
const INSTANCE = Symbol('instance');

class ConfigManager {
  constructor() {
    if (ConfigManager[INSTANCE]) {
      return ConfigManager[INSTANCE];
    }
    
    this.config = new Map();
    this.listeners = new Set();
    
    ConfigManager[INSTANCE] = this;
  }
  
  set(key, value) {
    const oldValue = this.config.get(key);
    this.config.set(key, value);
    
    // 通知监听器
    this.notifyListeners(key, value, oldValue);
  }
  
  get(key, defaultValue = null) {
    return this.config.get(key) ?? defaultValue;
  }
  
  has(key) {
    return this.config.has(key);
  }
  
  delete(key) {
    const existed = this.config.has(key);
    this.config.delete(key);
    
    if (existed) {
      this.notifyListeners(key, undefined, this.config.get(key));
    }
  }
  
  // 添加配置变更监听器
  addListener(callback) {
    this.listeners.add(callback);
    
    // 返回移除监听器的函数
    return () => this.listeners.delete(callback);
  }
  
  notifyListeners(key, newValue, oldValue) {
    this.listeners.forEach(callback => {
      try {
        callback({ key, newValue, oldValue });
      } catch (error) {
        console.error('配置监听器执行失败:', error);
      }
    });
  }
  
  // 静态方法获取实例
  static getInstance() {
    if (!ConfigManager[INSTANCE]) {
      new ConfigManager();
    }
    return ConfigManager[INSTANCE];
  }
  
  // 批量设置配置
  setMultiple(configs) {
    Object.entries(configs).forEach(([key, value]) => {
      this.set(key, value);
    });
  }
  
  // 获取所有配置
  getAll() {
    return Object.fromEntries(this.config);
  }
}

// 使用示例
const config = ConfigManager.getInstance();
config.set('apiUrl', 'https://api.example.com');
config.set('timeout', 5000);
config.set('retryCount', 3);

// 添加监听器
const removeListener = config.addListener(({ key, newValue, oldValue }) => {
  console.log(`配置 ${key} 从 ${oldValue} 变更为 ${newValue}`);
});

// 在另一个模块中获取相同实例
const anotherConfig = ConfigManager.getInstance();
console.log(config === anotherConfig); // true
console.log(anotherConfig.get('apiUrl')); // 'https://api.example.com'
```

#### 使用模块的方式实现单例（推荐）

```javascript
// logger.js - 日志管理器单例
class Logger {
  constructor() {
    this.logs = [];
    this.maxLogs = 1000;
    this.logLevel = 'info';
  }
  
  setLevel(level) {
    const validLevels = ['debug', 'info', 'warn', 'error'];
    if (validLevels.includes(level)) {
      this.logLevel = level;
    }
  }
  
  log(message, level = 'info', meta = {}) {
    const levelPriority = {
      debug: 0,
      info: 1,
      warn: 2,
      error: 3
    };
    
    // 检查日志级别
    if (levelPriority[level] < levelPriority[this.logLevel]) {
      return;
    }
    
    const timestamp = new Date().toISOString();
    const logEntry = {
      timestamp,
      level,
      message,
      meta,
      id: this.generateId()
    };
    
    this.logs.push(logEntry);
    
    // 限制日志数量
    if (this.logs.length > this.maxLogs) {
      this.logs.shift();
    }
    
    // 输出到控制台
    this.outputToConsole(logEntry);
    
    // 可以在这里添加其他输出方式（如发送到服务器）
    this.sendToServer(logEntry);
  }
  
  debug(message, meta) {
    this.log(message, 'debug', meta);
  }
  
  info(message, meta) {
    this.log(message, 'info', meta);
  }
  
  warn(message, meta) {
    this.log(message, 'warn', meta);
  }
  
  error(message, meta) {
    this.log(message, 'error', meta);
  }
  
  getLogs(level = null, limit = 100) {
    let filteredLogs = level 
      ? this.logs.filter(log => log.level === level)
      : this.logs;
    
    return filteredLogs.slice(-limit);
  }
  
  clear() {
    this.logs = [];
  }
  
  outputToConsole(logEntry) {
    const { timestamp, level, message, meta } = logEntry;
    const prefix = `[${timestamp}] ${level.toUpperCase()}:`;
    
    switch (level) {
      case 'debug':
        console.debug(prefix, message, meta);
        break;
      case 'info':
        console.info(prefix, message, meta);
        break;
      case 'warn':
        console.warn(prefix, message, meta);
        break;
      case 'error':
        console.error(prefix, message, meta);
        break;
    }
  }
  
  async sendToServer(logEntry) {
    // 只发送 warn 和 error 级别的日志到服务器
    if (['warn', 'error'].includes(logEntry.level)) {
      try {
        // 这里可以实现实际的服务器发送逻辑
        // await fetch('/api/logs', {
        //   method: 'POST',
        //   headers: { 'Content-Type': 'application/json' },
        //   body: JSON.stringify(logEntry)
        // });
      } catch (error) {
        console.error('发送日志到服务器失败:', error);
      }
    }
  }
  
  generateId() {
    return Date.now().toString(36) + Math.random().toString(36).substr(2);
  }
  
  // 导出日志
  exportLogs(format = 'json') {
    switch (format) {
      case 'json':
        return JSON.stringify(this.logs, null, 2);
      case 'csv':
        const headers = 'timestamp,level,message,meta\n';
        const rows = this.logs.map(log => 
          `${log.timestamp},${log.level},"${log.message}","${JSON.stringify(log.meta)}"`
        ).join('\n');
        return headers + rows;
      default:
        return this.logs.map(log => 
          `[${log.timestamp}] ${log.level.toUpperCase()}: ${log.message}`
        ).join('\n');
    }
  }
}

// 导出单例实例
export default new Logger();

// 使用示例
// import logger from './logger.js';
// 
// logger.setLevel('debug');
// logger.info('应用启动', { version: '1.0.0' });
// logger.warn('API 响应缓慢', { responseTime: 3000 });
// logger.error('网络请求失败', { url: '/api/users', status: 500 });
```

### 1.4 实际应用：API 客户端单例

```javascript
// apiClient.js - API 客户端单例
class ApiClient {
  constructor() {
    if (ApiClient.instance) {
      return ApiClient.instance;
    }
    
    this.baseURL = process.env.VUE_APP_API_BASE_URL || 'https://api.example.com';
    this.timeout = 10000;
    this.defaultHeaders = {
      'Content-Type': 'application/json'
    };
    
    // 请求和响应拦截器
    this.requestInterceptors = [];
    this.responseInterceptors = [];
    
    // 请求缓存
    this.cache = new Map();
    this.cacheTimeout = 5 * 60 * 1000; // 5分钟
    
    ApiClient.instance = this;
  }
  
  // 添加请求拦截器
  addRequestInterceptor(interceptor) {
    this.requestInterceptors.push(interceptor);
    return () => {
      const index = this.requestInterceptors.indexOf(interceptor);
      if (index > -1) {
        this.requestInterceptors.splice(index, 1);
      }
    };
  }
  
  // 添加响应拦截器
  addResponseInterceptor(interceptor) {
    this.responseInterceptors.push(interceptor);
    return () => {
      const index = this.responseInterceptors.indexOf(interceptor);
      if (index > -1) {
        this.responseInterceptors.splice(index, 1);
      }
    };
  }
  
  // 生成缓存键
  generateCacheKey(config) {
    const { method, url, params, data } = config;
    return `${method}:${url}:${JSON.stringify(params)}:${JSON.stringify(data)}`;
  }
  
  // 检查缓存
  getFromCache(cacheKey) {
    const cached = this.cache.get(cacheKey);
    if (cached && Date.now() - cached.timestamp < this.cacheTimeout) {
      return cached.data;
    }
    this.cache.delete(cacheKey);
    return null;
  }
  
  // 设置缓存
  setCache(cacheKey, data) {
    this.cache.set(cacheKey, {
      data,
      timestamp: Date.now()
    });
  }
  
  async request(config) {
    // 应用请求拦截器
    let finalConfig = { ...config };
    for (const interceptor of this.requestInterceptors) {
      finalConfig = await interceptor(finalConfig);
    }
    
    // 检查缓存（仅对 GET 请求）
    if (finalConfig.method === 'GET' && finalConfig.cache !== false) {
      const cacheKey = this.generateCacheKey(finalConfig);
      const cachedData = this.getFromCache(cacheKey);
      if (cachedData) {
        return cachedData;
      }
    }
    
    // 构建请求 URL
    let url = `${this.baseURL}${finalConfig.url}`;
    if (finalConfig.params) {
      const searchParams = new URLSearchParams(finalConfig.params);
      url += `?${searchParams.toString()}`;
    }
    
    // 构建请求选项
    const requestOptions = {
      method: finalConfig.method || 'GET',
      headers: {
        ...this.defaultHeaders,
        ...finalConfig.headers
      },
      signal: AbortSignal.timeout(this.timeout)
    };
    
    if (finalConfig.data && ['POST', 'PUT', 'PATCH'].includes(requestOptions.method)) {
      requestOptions.body = JSON.stringify(finalConfig.data);
    }
    
    try {
      const response = await fetch(url, requestOptions);
      
      let result = {
        data: null,
        status: response.status,
        statusText: response.statusText,
        headers: Object.fromEntries(response.headers.entries())
      };
      
      // 解析响应数据
      const contentType = response.headers.get('content-type');
      if (contentType && contentType.includes('application/json')) {
        result.data = await response.json();
      } else {
        result.data = await response.text();
      }
      
      // 检查响应状态
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      
      // 应用响应拦截器
      for (const interceptor of this.responseInterceptors) {
        result = await interceptor(result);
      }
      
      // 缓存 GET 请求的响应
      if (finalConfig.method === 'GET' && finalConfig.cache !== false) {
        const cacheKey = this.generateCacheKey(finalConfig);
        this.setCache(cacheKey, result);
      }
      
      return result;
    } catch (error) {
      // 处理网络错误
      if (error.name === 'AbortError') {
        throw new Error('请求超时');
      }
      throw new Error(`网络请求失败: ${error.message}`);
    }
  }
  
  // 便捷方法
  get(url, config = {}) {
    return this.request({ ...config, method: 'GET', url });
  }
  
  post(url, data, config = {}) {
    return this.request({ ...config, method: 'POST', url, data });
  }
  
  put(url, data, config = {}) {
    return this.request({ ...config, method: 'PUT', url, data });
  }
  
  patch(url, data, config = {}) {
    return this.request({ ...config, method: 'PATCH', url, data });
  }
  
  delete(url, config = {}) {
    return this.request({ ...config, method: 'DELETE', url });
  }
  
  // 清除缓存
  clearCache() {
    this.cache.clear();
  }
  
  // 设置默认配置
  setDefaults(config) {
    if (config.baseURL) this.baseURL = config.baseURL;
    if (config.timeout) this.timeout = config.timeout;
    if (config.headers) {
      this.defaultHeaders = { ...this.defaultHeaders, ...config.headers };
    }
  }
}

// 导出单例实例
const apiClient = new ApiClient();

// 添加认证拦截器
apiClient.addRequestInterceptor(async (config) => {
  const token = localStorage.getItem('authToken');
  if (token) {
    config.headers = {
      ...config.headers,
      'Authorization': `Bearer ${token}`
    };
  }
  return config;
});

// 添加错误处理拦截器
apiClient.addResponseInterceptor(async (response) => {
  if (response.status === 401) {
    // 处理认证失败
    localStorage.removeItem('authToken');
    window.location.href = '/login';
    throw new Error('认证失败，请重新登录');
  }
  return response;
});

export default apiClient;
```

## 二、工厂模式：对象生产的"流水线"

### 2.1 简单工厂模式

简单工厂模式通过一个工厂类来创建不同类型的对象，客户端不需要知道具体的创建逻辑。

```javascript
// 不同类型的通知类
class EmailNotification {
  constructor(recipient, subject, body) {
    this.recipient = recipient;
    this.subject = subject;
    this.body = body;
    this.type = 'email';
  }
  
  async send() {
    console.log(`发送邮件到 ${this.recipient}`);
    console.log(`主题: ${this.subject}`);
    console.log(`内容: ${this.body}`);
    
    // 模拟发送邮件的异步操作
    await new Promise(resolve => setTimeout(resolve, 1000));
    
    return {
      success: true,
      type: this.type,
      recipient: this.recipient,
      sentAt: new Date().toISOString()
    };
  }
  
  validate() {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex.test(this.recipient);
  }
}

class SMSNotification {
  constructor(phoneNumber, message) {
    this.phoneNumber = phoneNumber;
    this.message = message;
    this.type = 'sms';
  }
  
  async send() {
    console.log(`发送短信到 ${this.phoneNumber}`);
    console.log(`内容: ${this.message}`);
    
    // 模拟发送短信的异步操作
    await new Promise(resolve => setTimeout(resolve, 500));
    
    return {
      success: true,
      type: this.type,
      recipient: this.phoneNumber,
      sentAt: new Date().toISOString()
    };
  }
  
  validate() {
    const phoneRegex = /^\+?[1-9]\d{1,14}$/;
    return phoneRegex.test(this.phoneNumber);
  }
}

class PushNotification {
  constructor(deviceId, title, body, data = {}) {
    this.deviceId = deviceId;
    this.title = title;
    this.body = body;
    this.data = data;
    this.type = 'push';
  }
  
  async send() {
    console.log(`发送推送到设备 ${this.deviceId}`);
    console.log(`标题: ${this.title}`);
    console.log(`内容: ${this.body}`);
    
    // 模拟发送推送的异步操作
    await new Promise(resolve => setTimeout(resolve, 300));
    
    return {
      success: true,
      type: this.type,
      recipient: this.deviceId,
      sentAt: new Date().toISOString()
    };
  }
  
  validate() {
    return this.deviceId && this.title && this.body;
  }
}

class WebhookNotification {
  constructor(url, payload, headers = {}) {
    this.url = url;
    this.payload = payload;
    this.headers = headers;
    this.type = 'webhook';
  }
  
  async send() {
    console.log(`发送 Webhook 到 ${this.url}`);
    console.log(`负载:`, this.payload);
    
    try {
      // 模拟 HTTP 请求
      await new Promise(resolve => setTimeout(resolve, 800));
      
      return {
        success: true,
        type: this.type,
        recipient: this.url,
        sentAt: new Date().toISOString()
      };
    } catch (error) {
      return {
        success: false,
        type: this.type,
        recipient: this.url,
        error: error.message,
        sentAt: new Date().toISOString()
      };
    }
  }
  
  validate() {
    try {
      new URL(this.url);
      return true;
    } catch {
      return false;
    }
  }
}

// 通知工厂
class NotificationFactory {
  static notificationTypes = {
    email: EmailNotification,
    sms: SMSNotification,
    push: PushNotification,
    webhook: WebhookNotification
  };
  
  static createNotification(type, ...args) {
    const NotificationClass = this.notificationTypes[type];
    
    if (!NotificationClass) {
      throw new Error(`不支持的通知类型: ${type}`);
    }
    
    const notification = new NotificationClass(...args);
    
    // 验证通知参数
    if (!notification.validate()) {
      throw new Error(`通知参数验证失败: ${type}`);
    }
    
    return notification;
  }
  
  // 批量创建通知
  static createBatchNotifications(notifications) {
    return notifications.map(({ type, ...args }) => {
      return this.createNotification(type, ...Object.values(args));
    });
  }
  
  // 注册新的通知类型
  static registerNotificationType(type, NotificationClass) {
    this.notificationTypes[type] = NotificationClass;
  }
  
  // 获取支持的通知类型
  static getSupportedTypes() {
    return Object.keys(this.notificationTypes);
  }
  
  // 创建通知并发送
  static async createAndSend(type, ...args) {
    const notification = this.createNotification(type, ...args);
    return await notification.send();
  }
}

// 使用示例
async function demonstrateNotificationFactory() {
  try {
    // 创建不同类型的通知
    const emailNotification = NotificationFactory.createNotification(
      'email',
      'user@example.com',
      '欢迎注册',
      '感谢您注册我们的服务！'
    );
    
    const smsNotification = NotificationFactory.createNotification(
      'sms',
      '+86 138 0013 8000',
      '您的验证码是: 123456'
    );
    
    const pushNotification = NotificationFactory.createNotification(
      'push',
      'device_123',
      '新消息',
      '您有一条新消息',
      { messageId: '456', priority: 'high' }
    );
    
    // 批量创建通知
    const batchNotifications = NotificationFactory.createBatchNotifications([
      {
        type: 'email',
        recipient: 'admin@example.com',
        subject: '系统报告',
        body: '今日系统运行正常'
      },
      {
        type: 'webhook',
        url: 'https://api.example.com/webhook',
        payload: { event: 'user_registered', userId: 123 }
      }
    ]);
    
    // 发送所有通知
    const allNotifications = [emailNotification, smsNotification, pushNotification, ...batchNotifications];
    
    const results = await Promise.allSettled(
      allNotifications.map(notification => notification.send())
    );
    
    results.forEach((result, index) => {
      if (result.status === 'fulfilled') {
        console.log(`通知 ${index + 1} 发送成功:`, result.value);
      } else {
        console.error(`通知 ${index + 1} 发送失败:`, result.reason);
      }
    });
    
  } catch (error) {
    console.error('通知创建失败:', error.message);
  }
}

// 扩展：注册自定义通知类型
class SlackNotification {
  constructor(channel, message, username = 'Bot') {
    this.channel = channel;
    this.message = message;
    this.username = username;
    this.type = 'slack';
  }
  
  async send() {
    console.log(`发送 Slack 消息到频道 ${this.channel}`);
    console.log(`用户: ${this.username}`);
    console.log(`消息: ${this.message}`);
    
    await new Promise(resolve => setTimeout(resolve, 600));
    
    return {
      success: true,
      type: this.type,
      recipient: this.channel,
      sentAt: new Date().toISOString()
    };
  }
  
  validate() {
    return this.channel && this.message;
  }
}

// 注册新的通知类型
NotificationFactory.registerNotificationType('slack', SlackNotification);

// 使用新注册的通知类型
const slackNotification = NotificationFactory.createNotification(
  'slack',
  '#general',
  '系统部署完成',
  'DeployBot'
);
```

### 2.2 工厂方法模式

工厂方法模式定义一个创建对象的接口，让子类决定实例化哪一个类。

```javascript
// 抽象产品：UI 组件
class UIComponent {
  constructor() {
    if (new.target === UIComponent) {
      throw new Error('UIComponent 是抽象类，不能直接实例化');
    }
  }
  
  render() {
    throw new Error('render 方法必须被子类实现');
  }
  
  bindEvents() {
    throw new Error('bindEvents 方法必须被子类实现');
  }
}

// 具体产品：按钮组件
class Button extends UIComponent {
  constructor(text, type = 'primary', size = 'medium') {
    super();
    this.text = text;
    this.type = type;
    this.size = size;
    this.element = null;
  }
  
  render() {
    this.element = document.createElement('button');
    this.element.textContent = this.text;
    this.element.className = `btn btn-${this.type} btn-${this.size}`;
    
    this.bindEvents();
    return this.element;
  }
  
  bindEvents() {
    if (this.element) {
      this.element.addEventListener('click', (e) => {
        console.log(`按钮 "${this.text}" 被点击`);
        this.onClick && this.onClick(e);
      });
    }
  }
  
  onClick(callback) {
    this.onClick = callback;
    return this;
  }
}

// 具体产品：输入框组件
class Input extends UIComponent {
  constructor(placeholder = '', type = 'text', required = false) {
    super();
    this.placeholder = placeholder;
    this.type = type;
    this.required = required;
    this.element = null;
    this.value = '';
  }
  
  render() {
    this.element = document.createElement('input');
    this.element.type = this.type;
    this.element.placeholder = this.placeholder;
    this.element.required = this.required;
    this.element.className = 'form-input';
    
    this.bindEvents();
    return this.element;
  }
  
  bindEvents() {
    if (this.element) {
      this.element.addEventListener('input', (e) => {
        this.value = e.target.value;
        this.onInput && this.onInput(e.target.value);
      });
      
      this.element.addEventListener('change', (e) => {
        this.onChange && this.onChange(e.target.value);
      });
    }
  }
  
  onInput(callback) {
    this.onInput = callback;
    return this;
  }
  
  onChange(callback) {
    this.onChange = callback;
    return this;
  }
  
  getValue() {
    return this.value;
  }
  
  setValue(value) {
    this.value = value;
    if (this.element) {
      this.element.value = value;
    }
    return this;
  }
}

// 具体产品：选择框组件
class Select extends UIComponent {
  constructor(options = [], multiple = false) {
    super();
    this.options = options;
    this.multiple = multiple;
    this.element = null;
    this.selectedValues = multiple ? [] : null;
  }
  
  render() {
    this.element = document.createElement('select');
    this.element.multiple = this.multiple;
    this.element.className = 'form-select';
    
    // 添加选项
    this.options.forEach(option => {
      const optionElement = document.createElement('option');
      optionElement.value = option.value;
      optionElement.textContent = option.label;
      this.element.appendChild(optionElement);
    });
    
    this.bindEvents();
    return this.element;
  }
  
  bindEvents() {
    if (this.element) {
      this.element.addEventListener('change', (e) => {
        if (this.multiple) {
          this.selectedValues = Array.from(e.target.selectedOptions).map(option => option.value);
        } else {
          this.selectedValues = e.target.value;
        }
        
        this.onChange && this.onChange(this.selectedValues);
      });
    }
  }
  
  onChange(callback) {
    this.onChange = callback;
    return this;
  }
  
  getSelectedValues() {
    return this.selectedValues;
  }
  
  setSelectedValues(values) {
    this.selectedValues = values;
    if (this.element) {
      if (this.multiple) {
        Array.from(this.element.options).forEach(option => {
          option.selected = values.includes(option.value);
        });
      } else {
        this.element.value = values;
      }
    }
    return this;
  }
}

// 抽象工厂：UI 组件工厂
class UIComponentFactory {
  createComponent(type, ...args) {
    throw new Error('createComponent 方法必须被子类实现');
  }
}

// 具体工厂：Web 组件工厂
class WebComponentFactory extends UIComponentFactory {
  createComponent(type, ...args) {
    switch (type) {
      case 'button':
        return new Button(...args);
      case 'input':
        return new Input(...args);
      case 'select':
        return new Select(...args);
      default:
        throw new Error(`不支持的组件类型: ${type}`);
    }
  }
}

// 具体工厂：移动端组件工厂
class MobileComponentFactory extends UIComponentFactory {
  createComponent(type, ...args) {
    switch (type) {
      case 'button':
        const button = new Button(...args);
        // 移动端特定的样式和行为
        button.render = function() {
          this.element = document.createElement('button');
          this.element.textContent = this.text;
          this.element.className = `mobile-btn mobile-btn-${this.type} mobile-btn-${this.size}`;
          this.element.style.touchAction = 'manipulation';
          this.bindEvents();
          return this.element;
        };
        return button;
        
      case 'input':
        const input = new Input(...args);
        // 移动端特定的样式和行为
        input.render = function() {
          this.element = document.createElement('input');
          this.element.type = this.type;
          this.element.placeholder = this.placeholder;
          this.element.required = this.required;
          this.element.className = 'mobile-input';
          this.element.style.fontSize = '16px'; // 防止 iOS 缩放
          this.bindEvents();
          return this.element;
        };
        return input;
        
      case 'select':
        const select = new Select(...args);
        // 移动端可能使用原生选择器
        return select;
        
      default:
        throw new Error(`不支持的移动端组件类型: ${type}`);
    }
  }
}

// 表单构建器
class FormBuilder {
  constructor(factory) {
    this.factory = factory;
    this.components = [];
    this.formElement = null;
  }
  
  addButton(text, type = 'primary', size = 'medium') {
    const button = this.factory.createComponent('button', text, type, size);
    this.components.push(button);
    return this;
  }
  
  addInput(placeholder = '', type = 'text', required = false) {
    const input = this.factory.createComponent('input', placeholder, type, required);
    this.components.push(input);
    return this;
  }
  
  addSelect(options = [], multiple = false) {
    const select = this.factory.createComponent('select', options, multiple);
    this.components.push(select);
    return this;
  }
  
  build() {
    this.formElement = document.createElement('form');
    this.formElement.className = 'dynamic-form';
    
    this.components.forEach(component => {
      const wrapper = document.createElement('div');
      wrapper.className = 'form-group';
      wrapper.appendChild(component.render());
      this.formElement.appendChild(wrapper);
    });
    
    return this.formElement;
  }
  
  getFormData() {
    const data = {};
    this.components.forEach((component, index) => {
      if (component instanceof Input) {
        data[`input_${index}`] = component.getValue();
      } else if (component instanceof Select) {
        data[`select_${index}`] = component.getSelectedValues();
      }
    });
    return data;
  }
}

// 使用示例
function demonstrateFactoryMethod() {
  // 创建 Web 端表单
  const webFactory = new WebComponentFactory();
  const webForm = new FormBuilder(webFactory)
    .addInput('请输入用户名', 'text', true)
    .addInput('请输入密码', 'password', true)
    .addSelect([
      { value: 'admin', label: '管理员' },
      { value: 'user', label: '普通用户' },
      { value: 'guest', label: '访客' }
    ])
    .addButton('登录', 'primary')
    .addButton('取消', 'secondary')
    .build();
  
  // 创建移动端表单
  const mobileFactory = new MobileComponentFactory();
  const mobileForm = new FormBuilder(mobileFactory)
    .addInput('手机号', 'tel', true)
    .addInput('验证码', 'text', true)
    .addButton('登录', 'primary', 'large')
    .build();
  
  console.log('Web 表单创建完成');
  console.log('移动端表单创建完成');
  
  // 可以将表单添加到页面中
  // document.body.appendChild(webForm);
  // document.body.appendChild(mobileForm);
}
```

## 三、建造者模式：分步骤构建复杂对象

建造者模式将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。

### 3.1 SQL 查询构建器

```javascript
// SQL 查询构建器
class SQLQueryBuilder {
  constructor() {
    this.reset();
  }
  
  reset() {
    this.query = {
      type: null,
      table: null,
      fields: [],
      values: {},
      conditions: [],
      joins: [],
      groupBy: [],
      having: [],
      orderBy: [],
      limit: null,
      offset: null
    };
    return this;
  }
  
  // SELECT 查询
  select(fields = ['*']) {
    this.query.type = 'SELECT';
    this.query.fields = Array.isArray(fields) ? fields : [fields];
    return this;
  }
  
  // INSERT 查询
  insert(data) {
    this.query.type = 'INSERT';
    this.query.values = data;
    return this;
  }
  
  // UPDATE 查询
  update(data) {
    this.query.type = 'UPDATE';
    this.query.values = data;
    return this;
  }
  
  // DELETE 查询
  delete() {
    this.query.type = 'DELETE';
    return this;
  }
  
  // 指定表名
  from(table) {
    this.query.table = table;
    return this;
  }
  
  into(table) {
    this.query.table = table;
    return this;
  }
  
  // WHERE 条件
  where(field, operator, value) {
    if (arguments.length === 1 && typeof field === 'object') {
      // 支持对象形式的条件
      Object.entries(field).forEach(([key, val]) => {
        this.query.conditions.push({
          field: key,
          operator: '=',
          value: val,
          logic: 'AND'
        });
      });
    } else {
      this.query.conditions.push({
        field,
        operator,
        value,
        logic: 'AND'
      });
    }
    return this;
  }
  
  // OR 条件
  orWhere(field, operator, value) {
    this.query.conditions.push({
      field,
      operator,
      value,
      logic: 'OR'
    });
    return this;
  }
  
  // WHERE IN
  whereIn(field, values) {
    this.query.conditions.push({
      field,
      operator: 'IN',
      value: values,
      logic: 'AND'
    });
    return this;
  }
  
  // WHERE BETWEEN
  whereBetween(field, min, max) {
    this.query.conditions.push({
      field,
      operator: 'BETWEEN',
      value: [min, max],
      logic: 'AND'
    });
    return this;
  }
  
  // JOIN
  join(table, condition) {
    this.query.joins.push({
      type: 'INNER',
      table,
      condition
    });
    return this;
  }
  
  leftJoin(table, condition) {
    this.query.joins.push({
      type: 'LEFT',
      table,
      condition
    });
    return this;
  }
  
  rightJoin(table, condition) {
    this.query.joins.push({
      type: 'RIGHT',
      table,
      condition
    });
    return this;
  }
  
  // GROUP BY
  groupBy(fields) {
    this.query.groupBy = Array.isArray(fields) ? fields : [fields];
    return this;
  }
  
  // HAVING
  having(field, operator, value) {
    this.query.having.push({
      field,
      operator,
      value
    });
    return this;
  }
  
  // ORDER BY
  orderBy(field, direction = 'ASC') {
    this.query.orderBy.push({
      field,
      direction: direction.toUpperCase()
    });
    return this;
  }
  
  // LIMIT
  limit(count) {
    this.query.limit = count;
    return this;
  }
  
  // OFFSET
  offset(count) {
    this.query.offset = count;
    return this;
  }
  
  // 构建 SQL 字符串
  build() {
    let sql = '';
    const params = [];
    
    switch (this.query.type) {
      case 'SELECT':
        sql = this.buildSelect(params);
        break;
      case 'INSERT':
        sql = this.buildInsert(params);
        break;
      case 'UPDATE':
        sql = this.buildUpdate(params);
        break;
      case 'DELETE':
        sql = this.buildDelete(params);
        break;
      default:
        throw new Error('未指定查询类型');
    }
    
    return { sql: sql.trim(), params };
  }
  
  buildSelect(params) {
    let sql = `SELECT ${this.query.fields.join(', ')} FROM ${this.query.table}`;
    
    // JOIN
    this.query.joins.forEach(join => {
      sql += ` ${join.type} JOIN ${join.table} ON ${join.condition}`;
    });
    
    // WHERE
    if (this.query.conditions.length > 0) {
      sql += ' WHERE ' + this.buildConditions(this.query.conditions, params);
    }
    
    // GROUP BY
    if (this.query.groupBy.length > 0) {
      sql += ` GROUP BY ${this.query.groupBy.join(', ')}`;
    }
    
    // HAVING
    if (this.query.having.length > 0) {
      sql += ' HAVING ' + this.buildConditions(this.query.having, params);
    }
    
    // ORDER BY
    if (this.query.orderBy.length > 0) {
      const orderClauses = this.query.orderBy.map(order => 
        `${order.field} ${order.direction}`
      );
      sql += ` ORDER BY ${orderClauses.join(', ')}`;
    }
    
    // LIMIT
    if (this.query.limit !== null) {
      sql += ` LIMIT ${this.query.limit}`;
    }
    
    // OFFSET
    if (this.query.offset !== null) {
      sql += ` OFFSET ${this.query.offset}`;
    }
    
    return sql;
  }
  
  buildInsert(params) {
    const fields = Object.keys(this.query.values);
    const placeholders = fields.map(() => '?');
    
    fields.forEach(field => {
      params.push(this.query.values[field]);
    });
    
    return `INSERT INTO ${this.query.table} (${fields.join(', ')}) VALUES (${placeholders.join(', ')})`;
  }
  
  buildUpdate(params) {
    const setClauses = Object.keys(this.query.values).map(field => {
      params.push(this.query.values[field]);
      return `${field} = ?`;
    });
    
    let sql = `UPDATE ${this.query.table} SET ${setClauses.join(', ')}`;
    
    if (this.query.conditions.length > 0) {
      sql += ' WHERE ' + this.buildConditions(this.query.conditions, params);
    }
    
    return sql;
  }
  
  buildDelete(params) {
    let sql = `DELETE FROM ${this.query.table}`;
    
    if (this.query.conditions.length > 0) {
      sql += ' WHERE ' + this.buildConditions(this.query.conditions, params);
    }
    
    return sql;
  }
  
  buildConditions(conditions, params) {
    return conditions.map((condition, index) => {
      let clause = '';
      
      if (index > 0) {
        clause += ` ${condition.logic} `;
      }
      
      switch (condition.operator) {
        case 'IN':
          const placeholders = condition.value.map(() => '?').join(', ');
          clause += `${condition.field} IN (${placeholders})`;
          params.push(...condition.value);
          break;
        case 'BETWEEN':
          clause += `${condition.field} BETWEEN ? AND ?`;
          params.push(condition.value[0], condition.value[1]);
          break;
        default:
          clause += `${condition.field} ${condition.operator} ?`;
          params.push(condition.value);
      }
      
      return clause;
    }).join('');
  }
  
  // 克隆构建器
  clone() {
    const newBuilder = new SQLQueryBuilder();
    newBuilder.query = JSON.parse(JSON.stringify(this.query));
    return newBuilder;
  }
}

// 使用示例
function demonstrateSQLBuilder() {
  const builder = new SQLQueryBuilder();
  
  // 复杂的 SELECT 查询
  const selectQuery = builder
    .select(['u.name', 'u.email', 'p.title', 'COUNT(c.id) as comment_count'])
    .from('users u')
    .leftJoin('posts p', 'p.user_id = u.id')
    .leftJoin('comments c', 'c.post_id = p.id')
    .where('u.status', '=', 'active')
    .where('u.created_at', '>', '2023-01-01')
    .orWhere('u.role', '=', 'admin')
    .whereIn('u.department_id', [1, 2, 3])
    .groupBy(['u.id', 'p.id'])
    .having('comment_count', '>', 5)
    .orderBy('u.created_at', 'DESC')
    .limit(20)
    .offset(0)
    .build();
  
  console.log('SELECT 查询:');
  console.log(selectQuery.sql);
  console.log('参数:', selectQuery.params);
  
  // INSERT 查询
  const insertQuery = builder
    .reset()
    .insert({
      name: 'John Doe',
      email: 'john@example.com',
      status: 'active',
      created_at: new Date().toISOString()
    })
    .into('users')
    .build();
  
  console.log('\nINSERT 查询:');
  console.log(insertQuery.sql);
  console.log('参数:', insertQuery.params);
  
  // UPDATE 查询
  const updateQuery = builder
    .reset()
    .update({
      status: 'inactive',
      updated_at: new Date().toISOString()
    })
    .from('users')
    .where('last_login', '<', '2023-01-01')
    .where('status', '=', 'active')
    .build();
  
  console.log('\nUPDATE 查询:');
  console.log(updateQuery.sql);
  console.log('参数:', updateQuery.params);
  
  // DELETE 查询
  const deleteQuery = builder
    .reset()
    .delete()
    .from('users')
    .where('status', '=', 'deleted')
    .where('deleted_at', '<', '2022-01-01')
    .build();
  
  console.log('\nDELETE 查询:');
  console.log(deleteQuery.sql);
  console.log('参数:', deleteQuery.params);
}
```

### 3.2 HTTP 请求构建器

```javascript
// HTTP 请求构建器
class HttpRequestBuilder {
  constructor() {
    this.reset();
  }
  
  reset() {
    this.config = {
      url: '',
      method: 'GET',
      headers: {},
      params: {},
      data: null,
      timeout: 10000,
      retries: 0,
      retryDelay: 1000,
      validateStatus: (status) => status >= 200 && status < 300,
      transformRequest: null,
      transformResponse: null,
      interceptors: {
        request: [],
        response: []
      }
    };
    return this;
  }
  
  // 设置 URL
  url(url) {
    this.config.url = url;
    return this;
  }
  
  // 设置请求方法
  method(method) {
    this.config.method = method.toUpperCase();
    return this;
  }
  
  get(url) {
    return this.method('GET').url(url);
  }
  
  post(url) {
    return this.method('POST').url(url);
  }
  
  put(url) {
    return this.method('PUT').url(url);
  }
  
  patch(url) {
    return this.method('PATCH').url(url);
  }
  
  delete(url) {
    return this.method('DELETE').url(url);
  }
  
  // 设置请求头
  header(key, value) {
    this.config.headers[key] = value;
    return this;
  }
  
  headers(headers) {
    Object.assign(this.config.headers, headers);
    return this;
  }
  
  // 设置认证
  auth(token, type = 'Bearer') {
    return this.header('Authorization', `${type} ${token}`);
  }
  
  // 设置内容类型
  contentType(type) {
    return this.header('Content-Type', type);
  }
  
  json() {
    return this.contentType('application/json');
  }
  
  form() {
    return this.contentType('application/x-www-form-urlencoded');
  }
  
  multipart() {
    return this.contentType('multipart/form-data');
  }
  
  // 设置查询参数
  param(key, value) {
    this.config.params[key] = value;
    return this;
  }
  
  params(params) {
    Object.assign(this.config.params, params);
    return this;
  }
  
  // 设置请求体
  data(data) {
    this.config.data = data;
    return this;
  }
  
  // 设置超时
  timeout(ms) {
    this.config.timeout = ms;
    return this;
  }
  
  // 设置重试
  retry(count, delay = 1000) {
    this.config.retries = count;
    this.config.retryDelay = delay;
    return this;
  }
  
  // 设置状态验证
  validateStatus(validator) {
    this.config.validateStatus = validator;
    return this;
  }
  
  // 设置请求转换器
  transformRequest(transformer) {
    this.config.transformRequest = transformer;
    return this;
  }
  
  // 设置响应转换器
  transformResponse(transformer) {
    this.config.transformResponse = transformer;
    return this;
  }
  
  // 添加请求拦截器
  requestInterceptor(interceptor) {
    this.config.interceptors.request.push(interceptor);
    return this;
  }
  
  // 添加响应拦截器
  responseInterceptor(interceptor) {
    this.config.interceptors.response.push(interceptor);
    return this;
  }
  
  // 构建最终的请求配置
  build() {
    // 构建完整的 URL
    let fullUrl = this.config.url;
    
    // 添加查询参数
    if (Object.keys(this.config.params).length > 0) {
      const searchParams = new URLSearchParams(this.config.params);
      fullUrl += (fullUrl.includes('?') ? '&' : '?') + searchParams.toString();
    }
    
    // 构建 fetch 配置
    const fetchConfig = {
      method: this.config.method,
      headers: this.config.headers,
      signal: AbortSignal.timeout(this.config.timeout)
    };
    
    // 添加请求体
    if (this.config.data && ['POST', 'PUT', 'PATCH'].includes(this.config.method)) {
      if (this.config.transformRequest) {
        fetchConfig.body = this.config.transformRequest(this.config.data);
      } else if (this.config.headers['Content-Type'] === 'application/json') {
        fetchConfig.body = JSON.stringify(this.config.data);
      } else if (this.config.data instanceof FormData) {
        fetchConfig.body = this.config.data;
        // 让浏览器自动设置 Content-Type
        delete fetchConfig.headers['Content-Type'];
      } else {
        fetchConfig.body = this.config.data;
      }
    }
    
    return {
      url: fullUrl,
      config: fetchConfig,
      retries: this.config.retries,
      retryDelay: this.config.retryDelay,
      validateStatus: this.config.validateStatus,
      transformResponse: this.config.transformResponse,
      interceptors: this.config.interceptors
    };
  }
  
  // 执行请求
  async execute() {
    const requestConfig = this.build();
    
    // 应用请求拦截器
    let finalConfig = requestConfig.config;
    for (const interceptor of requestConfig.interceptors.request) {
      finalConfig = await interceptor(finalConfig);
    }
    
    let lastError;
    
    // 重试逻辑
    for (let attempt = 0; attempt <= requestConfig.retries; attempt++) {
      try {
        const response = await fetch(requestConfig.url, finalConfig);
        
        // 验证响应状态
        if (!requestConfig.validateStatus(response.status)) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        let result = {
          data: null,
          status: response.status,
          statusText: response.statusText,
          headers: Object.fromEntries(response.headers.entries())
        };
        
        // 解析响应数据
        const contentType = response.headers.get('content-type');
        if (contentType && contentType.includes('application/json')) {
          result.data = await response.json();
        } else {
          result.data = await response.text();
        }
        
        // 应用响应转换器
        if (requestConfig.transformResponse) {
          result.data = requestConfig.transformResponse(result.data);
        }
        
        // 应用响应拦截器
        for (const interceptor of requestConfig.interceptors.response) {
          result = await interceptor(result);
        }
        
        return result;
        
      } catch (error) {
        lastError = error;
        
        // 如果不是最后一次尝试，等待后重试
        if (attempt < requestConfig.retries) {
          await new Promise(resolve => setTimeout(resolve, requestConfig.retryDelay));
        }
      }
    }
    
    throw lastError;
  }
  
  // 克隆构建器
  clone() {
    const newBuilder = new HttpRequestBuilder();
    newBuilder.config = JSON.parse(JSON.stringify(this.config));
    return newBuilder;
  }
}

// 使用示例
function demonstrateHttpBuilder() {
  const builder = new HttpRequestBuilder();
  
  // GET 请求
  const getRequest = builder
    .get('https://api.example.com/users')
    .param('page', 1)
    .param('limit', 10)
    .header('Accept', 'application/json')
    .timeout(5000)
    .retry(3, 1000)
    .build();
  
  console.log('GET 请求配置:', getRequest);
  
  // POST 请求
  const postRequest = builder
    .reset()
    .post('https://api.example.com/users')
    .json()
    .auth('your-token-here')
    .data({
      name: 'John Doe',
      email: 'john@example.com'
    })
    .timeout(10000)
    .validateStatus(status => status >= 200 && status < 300)
    .transformResponse(data => {
      return {
        ...data,
        timestamp: new Date().toISOString()
      };
    })
    .build();
  
  console.log('POST 请求配置:', postRequest);
  
  // 文件上传请求
  const uploadRequest = builder
    .reset()
    .post('https://api.example.com/upload')
    .multipart()
    .data(new FormData()) // 实际使用时添加文件
    .timeout(30000)
    .retry(2, 2000)
    .build();
  
  console.log('文件上传请求配置:', uploadRequest);
}

// 高级用法：请求模板
class RequestTemplate {
  constructor(baseBuilder) {
    this.baseBuilder = baseBuilder;
  }
  
  // 创建 API 请求模板
  static createApiTemplate(baseUrl, token) {
    const builder = new HttpRequestBuilder()
      .url(baseUrl)
      .json()
      .auth(token)
      .timeout(10000)
      .retry(3, 1000)
      .requestInterceptor(async (config) => {
        console.log('发送请求:', config.method, config.url);
        return config;
      })
      .responseInterceptor(async (response) => {
        console.log('收到响应:', response.status);
        return response;
      });
    
    return new RequestTemplate(builder);
  }
  
  // 用户相关请求
  users() {
    return this.baseBuilder.clone().url('/users');
  }
  
  user(id) {
    return this.baseBuilder.clone().url(`/users/${id}`);
  }
  
  // 文章相关请求
  posts() {
    return this.baseBuilder.clone().url('/posts');
  }
  
  post(id) {
    return this.baseBuilder.clone().url(`/posts/${id}`);
  }
}

// 使用请求模板
const apiTemplate = RequestTemplate.createApiTemplate(
  'https://api.example.com',
  'your-api-token'
);

// 获取用户列表
const getUsersRequest = apiTemplate.users()
  .get()
  .params({ page: 1, limit: 20 })
  .build();

// 创建新用户
const createUserRequest = apiTemplate.users()
  .post()
  .data({
    name: 'Jane Doe',
    email: 'jane@example.com'
  })
  .build();

// 更新用户
const updateUserRequest = apiTemplate.user(123)
  .put()
  .data({
    name: 'Jane Smith'
  })
  .build();

console.log('用户请求模板演示完成');
```

## 四、原型模式：通过克隆创建对象

原型模式通过复制现有对象来创建新对象，而不是通过类实例化。这在需要创建大量相似对象时特别有用。

### 4.1 基础原型模式

```javascript
// 原型对象
class ComponentPrototype {
  constructor() {
    this.type = 'component';
    this.styles = {};
    this.events = {};
  }

  // 克隆方法
  clone() {
    const cloned = Object.create(Object.getPrototypeOf(this));
    
    // 深拷贝属性
    cloned.type = this.type;
    cloned.styles = JSON.parse(JSON.stringify(this.styles));
    cloned.events = { ...this.events };
    
    return cloned;
  }

  setStyle(property, value) {
    this.styles[property] = value;
    return this;
  }

  addEventListener(event, handler) {
    this.events[event] = handler;
    return this;
  }
}

// 具体原型
class ButtonPrototype extends ComponentPrototype {
  constructor() {
    super();
    this.type = 'button';
    this.text = 'Click me';
    this.styles = {
      backgroundColor: '#007bff',
      color: 'white',
      border: 'none',
      padding: '10px 20px',
      borderRadius: '4px'
    };
  }

  clone() {
    const cloned = super.clone();
    cloned.text = this.text;
    return cloned;
  }

  setText(text) {
    this.text = text;
    return this;
  }
}

class CardPrototype extends ComponentPrototype {
  constructor() {
    super();
    this.type = 'card';
    this.title = '';
    this.content = '';
    this.styles = {
      backgroundColor: 'white',
      border: '1px solid #ddd',
      borderRadius: '8px',
      padding: '16px',
      boxShadow: '0 2px 4px rgba(0,0,0,0.1)'
    };
  }

  clone() {
    const cloned = super.clone();
    cloned.title = this.title;
    cloned.content = this.content;
    return cloned;
  }

  setTitle(title) {
    this.title = title;
    return this;
  }

  setContent(content) {
    this.content = content;
    return this;
  }
}
```

### 4.2 原型管理器

```javascript
// 原型管理器
class PrototypeManager {
  constructor() {
    this.prototypes = new Map();
  }

  // 注册原型
  register(name, prototype) {
    this.prototypes.set(name, prototype);
  }

  // 获取克隆对象
  create(name) {
    const prototype = this.prototypes.get(name);
    if (!prototype) {
      throw new Error(`Prototype '${name}' not found`);
    }
    return prototype.clone();
  }

  // 列出所有原型
  list() {
    return Array.from(this.prototypes.keys());
  }
}

// 使用示例
const prototypeManager = new PrototypeManager();

// 注册原型
const primaryButton = new ButtonPrototype()
  .setText('Primary Button')
  .setStyle('backgroundColor', '#007bff');

const secondaryButton = new ButtonPrototype()
  .setText('Secondary Button')
  .setStyle('backgroundColor', '#6c757d');

const infoCard = new CardPrototype()
  .setTitle('Information')
  .setContent('This is an info card')
  .setStyle('borderLeft', '4px solid #17a2b8');

prototypeManager.register('primary-button', primaryButton);
prototypeManager.register('secondary-button', secondaryButton);
prototypeManager.register('info-card', infoCard);

// 创建新实例
const newPrimaryButton = prototypeManager.create('primary-button')
  .setText('Save Changes');

const newInfoCard = prototypeManager.create('info-card')
  .setTitle('User Profile')
  .setContent('Welcome to your profile page');

console.log('Available prototypes:', prototypeManager.list());
// 输出: ['primary-button', 'secondary-button', 'info-card']
```

### 4.3 深拷贝原型模式

```javascript
// 深拷贝工具函数
function deepClone(obj) {
  if (obj === null || typeof obj !== 'object') {
    return obj;
  }

  if (obj instanceof Date) {
    return new Date(obj.getTime());
  }

  if (obj instanceof Array) {
    return obj.map(item => deepClone(item));
  }

  if (typeof obj === 'object') {
    const cloned = {};
    for (const key in obj) {
      if (obj.hasOwnProperty(key)) {
        cloned[key] = deepClone(obj[key]);
      }
    }
    return cloned;
  }
}

// 复杂对象原型
class FormPrototype {
  constructor() {
    this.fields = [];
    this.validation = {};
    this.metadata = {
      created: new Date(),
      version: '1.0.0',
      author: 'system'
    };
  }

  addField(field) {
    this.fields.push(field);
    return this;
  }

  addValidation(fieldName, rules) {
    this.validation[fieldName] = rules;
    return this;
  }

  clone() {
    const cloned = new FormPrototype();
    cloned.fields = deepClone(this.fields);
    cloned.validation = deepClone(this.validation);
    cloned.metadata = deepClone(this.metadata);
    cloned.metadata.created = new Date(); // 更新创建时间
    return cloned;
  }
}

// 使用示例
const userFormPrototype = new FormPrototype()
  .addField({ name: 'username', type: 'text', required: true })
  .addField({ name: 'email', type: 'email', required: true })
  .addField({ name: 'password', type: 'password', required: true })
  .addValidation('username', { minLength: 3, maxLength: 20 })
  .addValidation('email', { pattern: /^[^\s@]+@[^\s@]+\.[^\s@]+$/ })
  .addValidation('password', { minLength: 8, hasSpecialChar: true });

// 创建登录表单（基于用户表单）
const loginForm = userFormPrototype.clone();
loginForm.fields = loginForm.fields.filter(field => 
  ['username', 'password'].includes(field.name)
);

// 创建注册表单（基于用户表单）
const registerForm = userFormPrototype.clone();
registerForm.addField({ name: 'confirmPassword', type: 'password', required: true })
  .addValidation('confirmPassword', { mustMatch: 'password' });

console.log('Login form fields:', loginForm.fields.map(f => f.name));
// 输出: ['username', 'password']

console.log('Register form fields:', registerForm.fields.map(f => f.name));
// 输出: ['username', 'email', 'password', 'confirmPassword']
```

## 五、抽象工厂模式：创建产品族

抽象工厂模式提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。

### 5.1 UI组件抽象工厂

```javascript
// 抽象产品接口
class Button {
  render() {
    throw new Error('render method must be implemented');
  }
  
  onClick(handler) {
    throw new Error('onClick method must be implemented');
  }
}

class Input {
  render() {
    throw new Error('render method must be implemented');
  }
  
  getValue() {
    throw new Error('getValue method must be implemented');
  }
  
  setValue(value) {
    throw new Error('setValue method must be implemented');
  }
}

class Modal {
  show() {
    throw new Error('show method must be implemented');
  }
  
  hide() {
    throw new Error('hide method must be implemented');
  }
}

// 具体产品 - Material Design
class MaterialButton extends Button {
  constructor(text, variant = 'contained') {
    super();
    this.text = text;
    this.variant = variant;
    this.element = null;
  }
  
  render() {
    this.element = document.createElement('button');
    this.element.textContent = this.text;
    this.element.className = `mdc-button mdc-button--${this.variant}`;
    this.element.style.cssText = `
      background-color: #6200ea;
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 4px;
      font-size: 14px;
      font-weight: 500;
      text-transform: uppercase;
      cursor: pointer;
      transition: all 0.2s;
    `;
    return this.element;
  }
  
  onClick(handler) {
    if (this.element) {
      this.element.addEventListener('click', handler);
    }
  }
}

class MaterialInput extends Input {
  constructor(placeholder, type = 'text') {
    super();
    this.placeholder = placeholder;
    this.type = type;
    this.element = null;
  }
  
  render() {
    const container = document.createElement('div');
    container.className = 'mdc-text-field';
    container.style.cssText = `
      position: relative;
      margin: 8px 0;
    `;
    
    this.element = document.createElement('input');
    this.element.type = this.type;
    this.element.placeholder = this.placeholder;
    this.element.className = 'mdc-text-field__input';
    this.element.style.cssText = `
      width: 100%;
      padding: 12px 16px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 16px;
      outline: none;
      transition: border-color 0.2s;
    `;
    
    container.appendChild(this.element);
    return container;
  }
  
  getValue() {
    return this.element ? this.element.value : '';
  }
  
  setValue(value) {
    if (this.element) {
      this.element.value = value;
    }
  }
}

class MaterialModal extends Modal {
  constructor(title, content) {
    super();
    this.title = title;
    this.content = content;
    this.element = null;
  }
  
  render() {
    this.element = document.createElement('div');
    this.element.className = 'material-modal';
    this.element.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    `;
    
    const modalContent = document.createElement('div');
    modalContent.style.cssText = `
      background: white;
      border-radius: 8px;
      padding: 24px;
      max-width: 500px;
      width: 90%;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
    `;
    
    const titleElement = document.createElement('h2');
    titleElement.textContent = this.title;
    titleElement.style.cssText = `
      margin: 0 0 16px 0;
      font-size: 20px;
      font-weight: 500;
    `;
    
    const contentElement = document.createElement('div');
    contentElement.innerHTML = this.content;
    
    modalContent.appendChild(titleElement);
    modalContent.appendChild(contentElement);
    this.element.appendChild(modalContent);
    
    return this.element;
  }
  
  show() {
    if (this.element) {
      this.element.style.display = 'flex';
      document.body.appendChild(this.element);
    }
  }
  
  hide() {
    if (this.element && this.element.parentNode) {
      this.element.style.display = 'none';
      this.element.parentNode.removeChild(this.element);
    }
  }
}

// 具体产品 - Bootstrap
class BootstrapButton extends Button {
  constructor(text, variant = 'primary') {
    super();
    this.text = text;
    this.variant = variant;
    this.element = null;
  }
  
  render() {
    this.element = document.createElement('button');
    this.element.textContent = this.text;
    this.element.className = `btn btn-${this.variant}`;
    this.element.style.cssText = `
      background-color: #007bff;
      color: white;
      border: 1px solid #007bff;
      padding: 8px 16px;
      border-radius: 4px;
      font-size: 14px;
      cursor: pointer;
      transition: all 0.15s;
    `;
    return this.element;
  }
  
  onClick(handler) {
    if (this.element) {
      this.element.addEventListener('click', handler);
    }
  }
}

class BootstrapInput extends Input {
  constructor(placeholder, type = 'text') {
    super();
    this.placeholder = placeholder;
    this.type = type;
    this.element = null;
  }
  
  render() {
    this.element = document.createElement('input');
    this.element.type = this.type;
    this.element.placeholder = this.placeholder;
    this.element.className = 'form-control';
    this.element.style.cssText = `
      width: 100%;
      padding: 8px 12px;
      border: 1px solid #ced4da;
      border-radius: 4px;
      font-size: 14px;
      margin: 4px 0;
      outline: none;
      transition: border-color 0.15s, box-shadow 0.15s;
    `;
    return this.element;
  }
  
  getValue() {
    return this.element ? this.element.value : '';
  }
  
  setValue(value) {
    if (this.element) {
      this.element.value = value;
    }
  }
}

class BootstrapModal extends Modal {
  constructor(title, content) {
    super();
    this.title = title;
    this.content = content;
    this.element = null;
  }
  
  render() {
    this.element = document.createElement('div');
    this.element.className = 'modal fade';
    this.element.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
      display: none;
      z-index: 1050;
    `;
    
    const modalDialog = document.createElement('div');
    modalDialog.className = 'modal-dialog';
    modalDialog.style.cssText = `
      position: relative;
      width: auto;
      margin: 1.75rem auto;
      max-width: 500px;
    `;
    
    const modalContent = document.createElement('div');
    modalContent.className = 'modal-content';
    modalContent.style.cssText = `
      background: white;
      border-radius: 6px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    `;
    
    const modalHeader = document.createElement('div');
    modalHeader.className = 'modal-header';
    modalHeader.style.cssText = `
      padding: 16px;
      border-bottom: 1px solid #dee2e6;
    `;
    
    const titleElement = document.createElement('h5');
    titleElement.textContent = this.title;
    titleElement.style.cssText = `
      margin: 0;
      font-size: 18px;
      font-weight: 500;
    `;
    
    const modalBody = document.createElement('div');
    modalBody.className = 'modal-body';
    modalBody.innerHTML = this.content;
    modalBody.style.cssText = `
      padding: 16px;
    `;
    
    modalHeader.appendChild(titleElement);
    modalContent.appendChild(modalHeader);
    modalContent.appendChild(modalBody);
    modalDialog.appendChild(modalContent);
    this.element.appendChild(modalDialog);
    
    return this.element;
  }
  
  show() {
    if (this.element) {
      this.element.style.display = 'block';
      document.body.appendChild(this.element);
    }
  }
  
  hide() {
    if (this.element && this.element.parentNode) {
      this.element.style.display = 'none';
      this.element.parentNode.removeChild(this.element);
    }
  }
}

// 抽象工厂
class UIFactory {
  createButton(text, variant) {
    throw new Error('createButton method must be implemented');
  }
  
  createInput(placeholder, type) {
    throw new Error('createInput method must be implemented');
  }
  
  createModal(title, content) {
    throw new Error('createModal method must be implemented');
  }
}

// 具体工厂
class MaterialUIFactory extends UIFactory {
  createButton(text, variant = 'contained') {
    return new MaterialButton(text, variant);
  }
  
  createInput(placeholder, type = 'text') {
    return new MaterialInput(placeholder, type);
  }
  
  createModal(title, content) {
    return new MaterialModal(title, content);
  }
}

class BootstrapUIFactory extends UIFactory {
  createButton(text, variant = 'primary') {
    return new BootstrapButton(text, variant);
  }
  
  createInput(placeholder, type = 'text') {
    return new BootstrapInput(placeholder, type);
  }
  
  createModal(title, content) {
    return new BootstrapModal(title, content);
  }
}
```

### 5.2 主题工厂系统

```javascript
// 主题配置抽象工厂
class ThemeFactory {
  createColors() {
    throw new Error('createColors method must be implemented');
  }
  
  createTypography() {
    throw new Error('createTypography method must be implemented');
  }
  
  createSpacing() {
    throw new Error('createSpacing method must be implemented');
  }
  
  createShadows() {
    throw new Error('createShadows method must be implemented');
  }
}

// 颜色配置
class Colors {
  constructor(config) {
    this.primary = config.primary;
    this.secondary = config.secondary;
    this.success = config.success;
    this.warning = config.warning;
    this.error = config.error;
    this.background = config.background;
    this.surface = config.surface;
    this.text = config.text;
  }
  
  getCSSVariables() {
    return Object.entries(this).map(([key, value]) => 
      `--color-${key}: ${value};`
    ).join('\n');
  }
}

// 字体配置
class Typography {
  constructor(config) {
    this.fontFamily = config.fontFamily;
    this.fontSize = config.fontSize;
    this.fontWeight = config.fontWeight;
    this.lineHeight = config.lineHeight;
    this.letterSpacing = config.letterSpacing;
  }
  
  getCSSVariables() {
    return Object.entries(this).map(([key, value]) => {
      if (typeof value === 'object') {
        return Object.entries(value).map(([subKey, subValue]) => 
          `--typography-${key}-${subKey}: ${subValue};`
        ).join('\n');
      }
      return `--typography-${key}: ${value};`;
    }).join('\n');
  }
}

// 间距配置
class Spacing {
  constructor(config) {
    this.base = config.base;
    this.scale = config.scale;
  }
  
  get(multiplier) {
    return `${this.base * Math.pow(this.scale, multiplier)}px`;
  }
  
  getCSSVariables() {
    const variables = [`--spacing-base: ${this.base}px;`];
    for (let i = 0; i <= 8; i++) {
      variables.push(`--spacing-${i}: ${this.get(i)};`);
    }
    return variables.join('\n');
  }
}

// 阴影配置
class Shadows {
  constructor(config) {
    this.elevation = config.elevation;
  }
  
  get(level) {
    return this.elevation[level] || this.elevation[0];
  }
  
  getCSSVariables() {
    return this.elevation.map((shadow, index) => 
      `--shadow-${index}: ${shadow};`
    ).join('\n');
  }
}

// 亮色主题工厂
class LightThemeFactory extends ThemeFactory {
  createColors() {
    return new Colors({
      primary: '#1976d2',
      secondary: '#dc004e',
      success: '#388e3c',
      warning: '#f57c00',
      error: '#d32f2f',
      background: '#ffffff',
      surface: '#f5f5f5',
      text: {
        primary: '#212121',
        secondary: '#757575',
        disabled: '#bdbdbd'
      }
    });
  }
  
  createTypography() {
    return new Typography({
      fontFamily: '"Roboto", "Helvetica", "Arial", sans-serif',
      fontSize: {
        xs: '12px',
        sm: '14px',
        md: '16px',
        lg: '18px',
        xl: '20px'
      },
      fontWeight: {
        light: 300,
        regular: 400,
        medium: 500,
        bold: 700
      },
      lineHeight: 1.5,
      letterSpacing: '0.00938em'
    });
  }
  
  createSpacing() {
    return new Spacing({
      base: 8,
      scale: 1.5
    });
  }
  
  createShadows() {
    return new Shadows({
      elevation: [
        'none',
        '0px 2px 1px -1px rgba(0,0,0,0.2)',
        '0px 3px 1px -2px rgba(0,0,0,0.2)',
        '0px 3px 3px -2px rgba(0,0,0,0.2)',
        '0px 2px 4px -1px rgba(0,0,0,0.2)',
        '0px 3px 5px -1px rgba(0,0,0,0.2)'
      ]
    });
  }
}

// 暗色主题工厂
class DarkThemeFactory extends ThemeFactory {
  createColors() {
    return new Colors({
      primary: '#90caf9',
      secondary: '#f48fb1',
      success: '#66bb6a',
      warning: '#ffb74d',
      error: '#f44336',
      background: '#121212',
      surface: '#1e1e1e',
      text: {
        primary: '#ffffff',
        secondary: '#aaaaaa',
        disabled: '#666666'
      }
    });
  }
  
  createTypography() {
    return new Typography({
      fontFamily: '"Roboto", "Helvetica", "Arial", sans-serif',
      fontSize: {
        xs: '12px',
        sm: '14px',
        md: '16px',
        lg: '18px',
        xl: '20px'
      },
      fontWeight: {
        light: 300,
        regular: 400,
        medium: 500,
        bold: 700
      },
      lineHeight: 1.5,
      letterSpacing: '0.00938em'
    });
  }
  
  createSpacing() {
    return new Spacing({
      base: 8,
      scale: 1.5
    });
  }
  
  createShadows() {
    return new Shadows({
      elevation: [
        'none',
        '0px 2px 1px -1px rgba(0,0,0,0.4)',
        '0px 3px 1px -2px rgba(0,0,0,0.4)',
        '0px 3px 3px -2px rgba(0,0,0,0.4)',
        '0px 2px 4px -1px rgba(0,0,0,0.4)',
        '0px 3px 5px -1px rgba(0,0,0,0.4)'
      ]
    });
  }
}

// 主题管理器
class ThemeManager {
  constructor() {
    this.currentTheme = null;
    this.factories = new Map();
    
    // 注册默认主题工厂
    this.registerFactory('light', new LightThemeFactory());
    this.registerFactory('dark', new DarkThemeFactory());
  }
  
  registerFactory(name, factory) {
    this.factories.set(name, factory);
  }
  
  createTheme(name) {
    const factory = this.factories.get(name);
    if (!factory) {
      throw new Error(`Theme factory '${name}' not found`);
    }
    
    return {
      name,
      colors: factory.createColors(),
      typography: factory.createTypography(),
      spacing: factory.createSpacing(),
      shadows: factory.createShadows()
    };
  }
  
  applyTheme(themeName) {
    this.currentTheme = this.createTheme(themeName);
    
    // 生成 CSS 变量
    const cssVariables = [
      this.currentTheme.colors.getCSSVariables(),
      this.currentTheme.typography.getCSSVariables(),
      this.currentTheme.spacing.getCSSVariables(),
      this.currentTheme.shadows.getCSSVariables()
    ].join('\n');
    
    // 应用到页面
    let styleElement = document.getElementById('theme-variables');
    if (!styleElement) {
      styleElement = document.createElement('style');
      styleElement.id = 'theme-variables';
      document.head.appendChild(styleElement);
    }
    
    styleElement.textContent = `:root {\n${cssVariables}\n}`;
    
    console.log(`Applied theme: ${themeName}`);
    return this.currentTheme;
  }
  
  getCurrentTheme() {
    return this.currentTheme;
  }
  
  getAvailableThemes() {
    return Array.from(this.factories.keys());
  }
}
```

### 5.3 使用示例

```javascript
// UI 组件工厂使用示例
function demonstrateUIFactory() {
  // 根据用户偏好选择 UI 框架
  const userPreference = 'material'; // 或 'bootstrap'
  
  let uiFactory;
  if (userPreference === 'material') {
    uiFactory = new MaterialUIFactory();
  } else {
    uiFactory = new BootstrapUIFactory();
  }
  
  // 创建一致风格的 UI 组件
  const loginButton = uiFactory.createButton('Login', 'primary');
  const usernameInput = uiFactory.createInput('Username');
  const passwordInput = uiFactory.createInput('Password', 'password');
  const welcomeModal = uiFactory.createModal(
    'Welcome',
    '<p>Welcome to our application!</p>'
  );
  
  // 渲染组件
  const container = document.createElement('div');
  container.appendChild(usernameInput.render());
  container.appendChild(passwordInput.render());
  container.appendChild(loginButton.render());
  
  // 添加事件处理
  loginButton.onClick(() => {
    const username = usernameInput.getValue();
    const password = passwordInput.getValue();
    
    if (username && password) {
      welcomeModal.render();
      welcomeModal.show();
      
      // 3秒后自动关闭
      setTimeout(() => {
        welcomeModal.hide();
      }, 3000);
    }
  });
  
  document.body.appendChild(container);
}

// 主题管理使用示例
function demonstrateThemeManager() {
  const themeManager = new ThemeManager();
  
  console.log('Available themes:', themeManager.getAvailableThemes());
  // 输出: ['light', 'dark']
  
  // 应用亮色主题
  const lightTheme = themeManager.applyTheme('light');
  console.log('Light theme colors:', lightTheme.colors);
  
  // 创建主题切换器
  const themeToggle = document.createElement('button');
  themeToggle.textContent = 'Toggle Theme';
  themeToggle.style.cssText = `
    position: fixed;
    top: 20px;
    right: 20px;
    padding: 10px 20px;
    background: var(--color-primary);
    color: var(--color-text-primary);
    border: none;
    border-radius: 4px;
    cursor: pointer;
  `;
  
  let isDark = false;
  themeToggle.addEventListener('click', () => {
    const themeName = isDark ? 'light' : 'dark';
    themeManager.applyTheme(themeName);
    isDark = !isDark;
    
    themeToggle.textContent = `Switch to ${isDark ? 'Light' : 'Dark'} Theme`;
  });
  
  document.body.appendChild(themeToggle);
}

// 运行演示
// demonstrateUIFactory();
// demonstrateThemeManager();

console.log('抽象工厂模式演示完成');
```

## 六、总结与最佳实践

### 6.1 创建型模式对比

| 模式 | 使用场景 | 优点 | 缺点 |
|------|----------|------|------|
| 单例模式 | 全局状态管理、配置管理 | 确保唯一实例、全局访问 | 难以测试、违反单一职责 |
| 工厂模式 | 对象创建逻辑复杂 | 解耦创建和使用、易于扩展 | 增加代码复杂度 |
| 建造者模式 | 复杂对象构建 | 分步构建、参数灵活 | 代码量较大 |
| 原型模式 | 对象克隆、性能优化 | 避免重复初始化、性能好 | 深拷贝复杂 |
| 抽象工厂 | 产品族创建 | 确保产品一致性 | 扩展困难 |

### 6.2 最佳实践建议

1. **选择合适的模式**
   - 根据具体需求选择，不要为了使用模式而使用
   - 考虑代码的可维护性和可扩展性

2. **避免过度设计**
   - 简单场景使用简单方案
   - 复杂场景才考虑设计模式

3. **注意性能影响**
   - 原型模式的深拷贝开销
   - 工厂模式的额外抽象层

4. **保持代码清晰**
   - 良好的命名和注释
   - 合理的文件组织结构

### 6.3 现代 JavaScript 中的应用

```javascript
// ES6+ 语法优化
class ModernSingleton {
  static #instance = null;
  
  static getInstance() {
    if (!this.#instance) {
      this.#instance = new this();
    }
    return this.#instance;
  }
  
  #data = new Map();
  
  set(key, value) {
    this.#data.set(key, value);
  }
  
  get(key) {
    return this.#data.get(key);
  }
}

// 使用 Proxy 的工厂模式
const ComponentFactory = new Proxy({}, {
  get(target, prop) {
    if (prop in target) {
      return target[prop];
    }
    
    // 动态创建组件工厂方法
    const componentName = prop.replace('create', '');
    return function(props = {}) {
      return {
        type: componentName.toLowerCase(),
        props,
        render() {
          console.log(`Rendering ${componentName} with props:`, props);
        }
      };
    };
  }
});

// 使用示例
const button = ComponentFactory.createButton({ text: 'Click me' });
const input = ComponentFactory.createInput({ placeholder: 'Enter text' });

button.render(); // 输出: Rendering button with props: { text: 'Click me' }
input.render();  // 输出: Rendering input with props: { placeholder: 'Enter text' }
```

通过本文的学习，我们深入了解了五种核心的创建型设计模式。这些模式在现代前端开发中有着广泛的应用，掌握它们将帮助你写出更加优雅、可维护的代码。

在下一篇文章中，我们将探讨结构型模式，学习如何优雅地组合对象和类，构建更加灵活的系统架构。