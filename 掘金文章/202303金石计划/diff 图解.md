# Vue2 diff 算法图解

## 前言

看 Vue 2 的源代码已经很久了，从用 flow 到如今使用 TypeScript，我每次都会打开它的源代码看一看，但是每次都只看到了 **数据初始化** 部分，也就是 `beforeMount` 的阶段，对于如何生成 VNode（Visual Dom Node， 也可以直接称为 vdom） 以及组件更新时如何比较 VNode（diff）始终没有仔细研究，只知道采用了 **双端 diff 算法**，至于这个双端是怎么开始怎么结束的也一直没有去看过，所以这次趁写文章的机会仔细研究一下。如果内容有误，希望大家能帮我指出，非常感谢~

## 什么是 diff ?

在我的理解中，diff 指代的是 `differences`，即 **新旧内容之间的区别计算**；Vue 中的 diff 算法，则是通过一种 **简单且高效** 的手段快速对比出 **新旧 VNode 节点数组之间的区别** 以便 **以最少的 dom 操作来更新页面内容**。

此时这里有两个必须的前提：

1. 对比的是 VNode 数组
2. 同时存在新旧两组 VNode 数组

所以它一般只发生在 **数据更新造成页面内容需要更新时执行**，即 `renderWatcher.run()`。

## 为什么是 VNode ?

上面说了，diff 中比较的是 VNode，而不是真实的 dom 节点，相信为什么会使用 VNode 大部分人都比较清楚，笔者就简单带过吧😝~

在 Vue 中使用 VNode 的原因大致有两个方面：

1. VNode 作为框架设计者根据框架需求设计的 JavaScript 对象，本身属性相对真实的 dom 节点要简单，并且操作时不需要进行 dom 查询，可以大幅优化计算时的性能消耗
2. 在 VNode 到真实 dom 的这个渲染过程，可以根据不同平台（web、微信小程序）进行不同的处理，生成适配各平台的真实 dom 元素

在 diff 过程中会遍历新旧节点数据进行对比，所以使用 VNode 能带来很大的性能提升。

## 结构梳理

在网页中，真实的 dom 节点都是以 **树** 的形式存在的，根节点都是 `<html>`，为了保证虚拟节点能与真实 dom 节点一致，VNode 也一样采用的是树形结构。

如果在组件更新时，需要对比全部 VNode 节点的话，新旧两组节点都需要进行 **深度遍历** 和比较，会产生很大的性能开销；所以，Vue 中默认 **同层级节点比较**，即 **如果新旧 VNode 树的层级不同的话，多余层级的内容会直接新建或者舍弃**，只在同层级进行 diff 操作。

一般来说，diff 操作一般发生在 `v-for` 循环或者有 `v-if/v-else` 、`component` 这类 **动态生成** 的节点对象上（静态节点一般不会改变，对比起来很快），并且这个过程是为了更新 dom，所以在源码中，这个过程对应的方法名是 `updateChildren`，位于 `src/core/vdom/patch.ts` 中。

## 前置内容

既然是对比新旧 VNode 数组，那么首先肯定有 **对比** 的判断方法：`sameNode(a, b)`、新增节点的方法 `addVnodes`、移除节点的方法 `removeVnodes`，当然，即使 `sameNode` 判断了 VNode 一致之后，依然会使用 `patchVnode` 对单个新旧 VNode 的内容进行深度比较，确认内部数据是否需要更新。

### sameNode(a, b)

这个方法就一个目的：**比较新旧节点是否相同**。

在这个方法中，首先比较的就是 a 和 b 的 `key` 是否相同，这也是为什么 Vue 在文档中注明了 `v-for、v-if、v-else` 等动态节点必须要设置 `key` 来标识节点唯一性，如果 `key` 存在且相同，则只需要比较内部是否发生了改变，一般情况下可以减少很多 dom 操作；而如果没有设置的话，则会直接销毁重建对应的节点元素。

然后会比较是不是异步组件，这里会比较他们的构造函数是不是一致。

然后会进入两种不同的情况比较：

- 非异步组件：标签一样、都不是注释节点、都有数据、同类型文本输入框
- 异步组件：旧节点占位符和新节点的错误提示都为 `undefined`

函数整体过程如下

![image-20230315153803745](./docs-images/diff%20%E5%9B%BE%E8%A7%A3/image-20230315153803745.png)

### addNodes

顾名思义，添加新的 VNode 节点，



### removeVnodes





### patchVnode
