## 前言

在使用 `bpmn-js` 绘制流程图时，可能会存在需要开发者自己定义属性或者元素的情况，为了保证符合官方定义，对官方文档进行了汉化说明。以下说明基于个人理解，可能与真实作用有出入，希望大家指出不正确或者意义不明的地方，我好加以改正，谢谢！

## 说明文件配置属性

> 原文见 `bpmn` 官方仓库 [bpmn-io/moddle](https://github.com/bpmn-io/moddle/blob/master/docs/descriptor.md) 。

```javascript
definitionJson = {
  "name": "self",
  "uri": "https://self",
  "prefix": "se", // 前缀
  "xml": {
    "tagAlias": "lowerCase" // xml 标签转为小写驼峰
  },
  "types": [ // 自定义标签类型数组
    {
      // name: 自定义标签名，在xml中显示为 se:attrOne 
      "name": "AttrOne",
      
      // isAbstract: 规定在实例文档中是否可以使用复杂类型。
      // 如果该值为 true，则元素不能直接使用该复杂类型，而是必须使用从该复杂类型派生的复杂类型。
      "isAbstract": true,
      
      /**
       * extends: Some meta-models require it to plug-in new properties that to certain existing model elements. 
       *          This can be acomplished using the extends field
       * 一些元模型要求它为某些现有模型元素插入新属性。可以使用扩展字段来完成
       * 比如 camunda 中的 camunda:FormalExpression extends => bpmn:FormalExpression,
       * 并且在camunda:FormalExpression 中声明的属性 Properties: { name: "resource", type: "String", isAttr: true }
       * 则创建的连线条件 moddle.create("bpmn:FormalExpression") 可以设置新定义属性 resource
       * 打印结果如下: businessObject: {
       *     $type: "bpmn:SequenceFlow"
       *     conditionExpression: { 
       *         $type: "bpmn:FormalExpression"
       *         language: "123123"
       *         resource: "123123123"
       *     }
       * }
       */
      "extends": [], // 扩展选中的类型属性，每次创建数组内的元素实例时都会自动插入新的属性AttrOne
      
      /**
       * superClass: Types can inherit from one or more super types by specifying the superClass property.
       * 指定向上继承所有超类的属性。
       * 例如 camunda:FormalExpression extends 
       * 	=> bpmn:FormalExpression superClass
       *	=> bpmn:Expression superClass
       *	=> bpmn:BaseElement
       * 按照类型结构层级顺序，依次将属性添加到该类型上
       * 如果继承其他自定义配置文件的属性（比如 b.json [ prefix: "b", types: [{ name: "TextB" }] ]）
       * 则当前文件的superClass必须写完整的带前缀的名称 superClass: [ "b:TextB" ]
       * 如果要将该类型作为标签插入到xml中，继承的superClass超类中必须包含 BaseElement 或者 Element 类型
       */
      "superClass": [
        "Element"
      ],
      
      // 自定义标签属性
      "properties": [
        {
          // name: 属性名
          "name": "name",
          
          // type: 属性值类型，可以为任意基础类型或者其他自定义类型。
          // 比如属性值需要设置为另一个自定义类型 AttrTwo时，则 "type": "AttrTwo"
          "type": "String",
          
          // isAttr: 作为标签属性，体现为<se:attrOne name="xxx"></se:attrOne>
          "isAttr": true
          
          // isBody: 属性值插入到标签内部，体现为<se:attrOne>xxx</se:attrOne>; 
          // 另外 isBody 为 true 时，name 只能设置为 value
          // "isBody": false
          
          // isMany: 属性值是否用数组保存，注意与其他配置的互斥：type不能为String、Number等简单类型，isAttr不能为true等等
          // "isMany": true
          
          // default: 默认值
          // "default": "xxx"
          
          // redefines: 重新定义从超类型继承的属性、重写名称、类型和限定符
          // "redefines": String
          
          // isReference: 是否通过其 id 属性引用另一个对象作为属性值，通常在任务节点/网关等设置默认路径时使用
          // "isReference": false
          
          // "xml": {
          //	  serialize: 添加关于如何序列化的额外注释。支持的值:xsi -- 类型序列化为数据类型，而不是元素
          //      "serialize": "xsi:type"
          //  }
        },
        {
          "name": "value",
          "type": "Number",
          "isAttr": "true",
          "default": 2
        }
      ]
    },
    {
      "name": "AttrTwo",
      "superClass": [
        "Element"
      ],
      "meta": {
        "allowedIn": [ "*" ] // 允许进入哪些元素标签内
      },
      "properties": [
        {
          "name": "value",
          "type": "String",
          "isBody": true // 作为内容填充，体现为<se:attrOne>xxx</se:attrOne>
        }
      ]
    }
  ],
  // The enumerations and associations properties are reserved for future use.
  // 枚举和关联属性保留供将来使用。
  enumerations: [],
  associations: []
}
```
